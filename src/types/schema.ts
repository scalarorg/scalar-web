/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/scalar/scalarnet/add_cosmos_based_chain": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["AddCosmosBasedChain"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/scalarnet/call_contract": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["CallContract"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/scalarnet/confirm_deposit": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["ScalarConfirmDeposit"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/scalarnet/execute_pending_transfers": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["ExecutePendingTransfers"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/scalarnet/link": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["ScalarLink"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/scalarnet/register_asset": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["RegisterAsset"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/scalarnet/register_fee_collector": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["RegisterFeeCollector"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/scalarnet/retry_ibc_transfer": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["RetryIBCTransfer"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/scalarnet/route_ibc_transfers": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["RouteIBCTransfers"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/scalarnet/route_message": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["RouteMessage"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/scalarnet/v1beta1/chain_by_ibc_path/{ibc_path}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["ChainByIBCPath"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/scalarnet/v1beta1/ibc_path/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["IBCPath"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/scalarnet/v1beta1/ibc_transfer_count": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** PendingIBCTransferCount queries the pending ibc transfers for all chains */
    get: operations["PendingIBCTransferCount"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/scalarnet/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["ScalarParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/confirm_transfer_key": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["ConfirmTransferKey"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/add_chain": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["AddChain"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/batched_commands/{chain}/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** BatchedCommands queries the batched commands for a specified chain and
     *     BatchedCommandsID if no BatchedCommandsID is specified, then it returns the
     *     latest batched commands */
    get: operations["BatchedCommands"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/burner_info": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["BurnerInfo"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/bytecode/{chain}/{contract}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Bytecode queries the bytecode of a specified gateway at the specified
     *     chain */
    get: operations["Bytecode"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/chains": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Chains queries the available chains */
    get: operations["ScalarChains"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/command_request": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Command queries the command of a chain provided the command id */
    get: operations["Command"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/confirm_deposit": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["ChainsConfirmDeposit"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/confirm_source_txs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["ConfirmSourceTxs"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/confirm_token": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["ConfirmToken"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/confirmation_height/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ConfirmationHeight queries the confirmation height for the specified chain */
    get: operations["ConfirmationHeight"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/create_burn_tokens": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["CreateBurnTokens"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/create_deploy_token": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["CreateDeployToken"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/create_pending_transfers": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["CreatePendingTransfers"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/create_transfer_operatorship": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["CreateTransferOperatorship"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/erc20_tokens/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ERC20Tokens queries the ERC20 tokens registered for a chain */
    get: operations["ERC20Tokens"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/event/{chain}/{event_id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Event queries an event at the specified chain */
    get: operations["Event"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/gateway_address/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GatewayAddress queries the address of scalar gateway at the specified
     *     chain */
    get: operations["GatewayAddress"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/key_address/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** KeyAddress queries the address of key of a chain */
    get: operations["KeyAddress"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/link": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["ChainsLink"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/params/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["ChainsParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/pending_commands/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** PendingCommands queries the pending commands for the specified chain */
    get: operations["PendingCommands"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/redeem_session/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["RedeemSession"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/retry-failed-event": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["RetryFailedEvent"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/set_gateway": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["SetGateway"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/sign_btc_commands": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["SignBtcCommand"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/sign_commands": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["SignCommands"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/token_info/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** TokenInfo queries the token info for a registered ERC20 Token */
    get: operations["TokenInfo"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/register_custodian_group": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["RegisterCustodianGroup"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/protocol/v1beta1": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetProtocols returns all Protocol */
    get: operations["Protocols"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/protocol/v1beta1/add_supported_chain": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Add DestinationChain into protocol */
    post: operations["AddSupportedChain"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/protocol/v1beta1/create_protocol": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create protocol */
    post: operations["CreateProtocol"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/protocol/v1beta1/protocol": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["Protocol"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/protocol/v1beta1/update_protocol": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["UpdateProtocol"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/protocol/v1beta1/update_supported_chain": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Delete DestinationChain from protocol */
    post: operations["UpdateSupportedChain"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/chains/v1beta1/reserve_redeem_utxo": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["ReserveRedeemUtxo"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/convenant/v1beta1/custodians": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get custodians */
    get: operations["Custodians"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/add_custodian_to_group": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Add Custodian to custodian group
     *     recalculate taproot pubkey when adding custodian to custodian group */
    post: operations["AddCustodianToGroup"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/confirm_redeem_txs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["ConfirmRedeemTxs"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/confirm_switched_phase": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["ConfirmSwitchedPhase"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/create_custodian": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create custodian */
    post: operations["CreateCustodian"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/create_custodian_group": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create custodian group */
    post: operations["CreateCustodianGroup"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/custodian_groups": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get custodian groups */
    get: operations["Groups"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/initialize_utxo": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["InitializeUtxo"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["CovenantParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/redeem_session": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["CovenantRedeemSession"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/remove_custodian_from_group": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Remove Custodian from custodian group
     *     recalculate taproot address when deleting custodian from custodian group */
    post: operations["RemoveCustodianFromGroup"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/rotate_key": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["CovenantRotateKey"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/standalone_command": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["StandaloneCommand"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/submit_tap_script_sigs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["SubmitTapScriptSigs"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/update_custodian": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update custodian */
    post: operations["UpdateCustodian"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/update_custodian_group": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update Custodian group */
    post: operations["UpdateCustodianGroup"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/covenant/v1beta1/utxo_snapshot": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["UTXOSnapshot"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/multisig/rotate_key": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["RotateKey"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/multisig/start_keygen": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["StartKeygen"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/multisig/submit_pub_key": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["SubmitPubKey"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/multisig/submit_signature": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["SubmitSignature"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/multisig/v1beta1/key": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Key returns the key corresponding to a given key ID.
     *     If no key is found, it returns the grpc NOT_FOUND error. */
    get: operations["Key"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/multisig/v1beta1/key_id/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** KeyID returns the key ID of a key assigned to a given chain.
     *     If no key is assigned, it returns the grpc NOT_FOUND error. */
    get: operations["KeyID"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/multisig/v1beta1/keygen_opt_in": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["KeygenOptIn"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/multisig/v1beta1/keygen_opt_out": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["KeygenOptOut"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/multisig/v1beta1/keygen_session": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** KeygenSession returns the keygen session info for a given key ID.
     *     If no key is found, it returns the grpc NOT_FOUND error. */
    get: operations["KeygenSession"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/multisig/v1beta1/next_key_id/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** NextKeyID returns the key ID assigned for the next rotation on a given
     *     chain. If no key rotation is in progress, it returns the grpc NOT_FOUND
     *     error. */
    get: operations["NextKeyID"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/multisig/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["MultisigParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/activate_chain": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["ActivateChain"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/deactivate_chain": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["DeactivateChain"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/deregister_chain_maintainer": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["DeregisterChainMaintainer"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/register_asset_fee": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["RegisterAssetFee"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/register_chain_maintainer": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["RegisterChainMaintainer"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/set_transfer_rate_limit": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["SetTransferRateLimit"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/assets/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Assets queries the assets registered for a chain */
    get: operations["Assets"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/chain_maintainers/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ChainMaintainers queries the chain maintainers for a given chain */
    get: operations["ChainMaintainers"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/chain_state/{chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ChainState queries the state of a registered chain on the network */
    get: operations["ChainState"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/chains": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Chains queries the chains registered on the network */
    get: operations["Chains"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/chains_by_asset/{asset}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ChainsByAsset queries the chains that support an asset on the network */
    get: operations["ChainsByAsset"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/fee": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** FeeInfo queries the fee info by chain and asset */
    get: operations["FeeInfo2"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/fee_info/{chain}/{asset}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** FeeInfo queries the fee info by chain and asset */
    get: operations["FeeInfo"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/latest_deposit_address/{recipient_addr}/{recipient_chain}/{deposit_chain}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** LatestDepositAddress queries the a deposit address by recipient */
    get: operations["LatestDepositAddress"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/message": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["Message"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["NexusParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/recipient_address/{deposit_chain}/{deposit_addr}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** RecipientAddress queries the recipient address for a given deposit address */
    get: operations["RecipientAddress"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/transfer_fee": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** TransferFee queries the transfer fee by the source, destination chain,
     *     and amount. If amount is 0, the min fee is returned */
    get: operations["TransferFee2"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/transfer_fee/{source_chain}/{destination_chain}/{amount}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** TransferFee queries the transfer fee by the source, destination chain,
     *     and amount. If amount is 0, the min fee is returned */
    get: operations["TransferFee"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/transfer_rate_limit/{chain}/{asset}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** TransferRateLimit queries the transfer rate limit for a given chain and
     *     asset. If a rate limit is not set, nil is returned. */
    get: operations["TransferRateLimit"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/nexus/v1beta1/transfers_for_chain/{chain}/{state}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** TransfersForChain queries transfers by chain */
    get: operations["TransfersForChain"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/reward/refund_message": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["RefundMsg"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/reward/v1beta1/inflation_rate": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["InflationRate2"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/reward/v1beta1/inflation_rate/{validator}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["InflationRate"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/reward/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["RewardParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/snapshot/deactivate_proxy": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** DeactivateProxy defines a method for deregistering a proxy account. */
    post: operations["DeactivateProxy"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/snapshot/register_proxy": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** RegisterProxy defines a method for registering a proxy account that can act
     *     in a validator account's stead. */
    post: operations["RegisterProxy"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/snapshot/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["SnapshotParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/tss/heartbeat": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["HeartBeat"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/tss/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["TSSParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/permission/deregister_controller": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["DeregisterController"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/permission/register_controller": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["RegisterController"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/permission/update_governance_key": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["UpdateGovernanceKey"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/permission/v1beta1/governance_key": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GovernanceKey returns the multisig governance key */
    get: operations["GovernanceKey"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/permission/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["PermissionParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/vote/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations["VoteParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/scalar/vote/vote": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: operations["ScalarVote"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/auth/v1beta1/accounts": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Accounts returns all the existing accounts
     * @description Since: cosmos-sdk 0.43
     */
    get: operations["Accounts"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/auth/v1beta1/accounts/{address}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Account returns account details based on address. */
    get: operations["Account"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/auth/v1beta1/module_accounts/{name}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ModuleAccountByName returns the module account info by module name */
    get: operations["ModuleAccountByName"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/auth/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Params queries all parameters. */
    get: operations["AuthParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/bank/v1beta1/balances/{address}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** AllBalances queries the balance of all coins for a single account. */
    get: operations["AllBalances"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/bank/v1beta1/balances/{address}/by_denom": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Balance queries the balance of a single coin for a single account. */
    get: operations["Balance"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/bank/v1beta1/denoms_metadata": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DenomsMetadata queries the client metadata for all registered coin denominations. */
    get: operations["DenomsMetadata"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/bank/v1beta1/denoms_metadata/{denom}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DenomsMetadata queries the client metadata of a given coin denomination. */
    get: operations["DenomMetadata"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/bank/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Params queries the parameters of x/bank module. */
    get: operations["BankParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/bank/v1beta1/spendable_balances/{address}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** SpendableBalances queries the spenable balance of all coins for a single
     *     account. */
    get: operations["SpendableBalances"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/bank/v1beta1/supply": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** TotalSupply queries the total supply of all coins. */
    get: operations["TotalSupply"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/bank/v1beta1/supply/{denom}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** SupplyOf queries the supply of a single coin. */
    get: operations["SupplyOf"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/base/tendermint/v1beta1/blocks/latest": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetLatestBlock returns the latest block. */
    get: operations["GetLatestBlock"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/base/tendermint/v1beta1/blocks/{height}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetBlockByHeight queries block for given height. */
    get: operations["GetBlockByHeight"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/base/tendermint/v1beta1/node_info": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetNodeInfo queries the current node info. */
    get: operations["GetNodeInfo"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/base/tendermint/v1beta1/syncing": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetSyncing queries node syncing. */
    get: operations["GetSyncing"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/base/tendermint/v1beta1/validatorsets/latest": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetLatestValidatorSet queries latest validator-set. */
    get: operations["GetLatestValidatorSet"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/base/tendermint/v1beta1/validatorsets/{height}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetValidatorSetByHeight queries validator-set at a given height. */
    get: operations["GetValidatorSetByHeight"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/distribution/v1beta1/community_pool": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** CommunityPool queries the community pool coins. */
    get: operations["CommunityPool"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DelegationTotalRewards queries the total rewards accrued by a each
     *     validator. */
    get: operations["DelegationTotalRewards"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DelegationRewards queries the total rewards accrued by a delegation. */
    get: operations["DelegationRewards"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DelegatorValidators queries the validators of a delegator. */
    get: operations["DelegatorValidators"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DelegatorWithdrawAddress queries withdraw address of a delegator. */
    get: operations["DelegatorWithdrawAddress"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/distribution/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Params queries params of the distribution module. */
    get: operations["DistributionParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/distribution/v1beta1/validators/{validator_address}/commission": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ValidatorCommission queries accumulated commission for a validator. */
    get: operations["ValidatorCommission"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ValidatorOutstandingRewards queries rewards of a validator address. */
    get: operations["ValidatorOutstandingRewards"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/distribution/v1beta1/validators/{validator_address}/slashes": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ValidatorSlashes queries slash events of a validator. */
    get: operations["ValidatorSlashes"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Allowance returns fee granted to the grantee by the granter. */
    get: operations["Allowance"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/feegrant/v1beta1/allowances/{grantee}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Allowances returns all the grants for address. */
    get: operations["Allowances"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/feegrant/v1beta1/issued/{granter}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** AllowancesByGranter returns all the grants given by an address
     *     Since v0.46 */
    get: operations["AllowancesByGranter"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/evidence/v1beta1/evidence": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** AllEvidence queries all evidence. */
    get: operations["AllEvidence"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/evidence/v1beta1/evidence/{evidence_hash}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Evidence queries evidence based on evidence hash. */
    get: operations["Evidence"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/gov/v1beta1/params/{params_type}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Params queries all parameters of the gov module. */
    get: operations["GovParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/gov/v1beta1/proposals": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Proposals queries all proposals based on given status. */
    get: operations["Proposals"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/gov/v1beta1/proposals/{proposal_id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Proposal queries proposal details based on ProposalID. */
    get: operations["Proposal"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Deposits queries all deposits of a single proposal. */
    get: operations["Deposits"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Deposit queries single deposit information based proposalID, depositAddr. */
    get: operations["Deposit"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/gov/v1beta1/proposals/{proposal_id}/tally": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** TallyResult queries the tally of a proposal vote. */
    get: operations["TallyResult"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Votes queries votes of a given proposal. */
    get: operations["Votes"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Vote queries voted information based on proposalID, voterAddr. */
    get: operations["Vote"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/mint/v1beta1/annual_provisions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** AnnualProvisions current minting annual provisions value. */
    get: operations["AnnualProvisions"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/mint/v1beta1/inflation": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Inflation returns the current minting inflation value. */
    get: operations["Inflation"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/mint/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Params returns the total set of minting parameters. */
    get: operations["MintParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/params/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Params queries a specific parameter of a module, given its subspace and
     *     key. */
    get: operations["Params"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/slashing/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Params queries the parameters of slashing module */
    get: operations["SlashingParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/slashing/v1beta1/signing_infos": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** SigningInfos queries signing info of all validators */
    get: operations["SigningInfos"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/slashing/v1beta1/signing_infos/{cons_address}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** SigningInfo queries the signing info of given cons address */
    get: operations["SigningInfo"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/delegations/{delegator_addr}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DelegatorDelegations queries all delegations of a given delegator address. */
    get: operations["DelegatorDelegations"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Redelegations queries redelegations of given address. */
    get: operations["Redelegations"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DelegatorUnbondingDelegations queries all unbonding delegations of a given
     *     delegator address. */
    get: operations["DelegatorUnbondingDelegations"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DelegatorValidators queries all validators info for given delegator
     *     address. */
    get: operations["StakingDelegatorValidators"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DelegatorValidator queries validator info for given delegator validator
     *     pair. */
    get: operations["DelegatorValidator"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/historical_info/{height}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** HistoricalInfo queries the historical info for given height. */
    get: operations["HistoricalInfo"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Parameters queries the staking parameters. */
    get: operations["StakingParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/pool": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Pool queries the pool info. */
    get: operations["StakingPool"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/validators": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Validators queries all validators that match the given status. */
    get: operations["Validators"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/validators/{validator_addr}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Validator queries validator info for given validator address. */
    get: operations["Validator"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ValidatorDelegations queries delegate info for given validator. */
    get: operations["ValidatorDelegations"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Delegation queries delegate info for given validator delegator pair. */
    get: operations["Delegation"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** UnbondingDelegation queries unbonding info for given validator delegator
     *     pair. */
    get: operations["UnbondingDelegation"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ValidatorUnbondingDelegations queries unbonding delegations of a validator. */
    get: operations["ValidatorUnbondingDelegations"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/tx/v1beta1/simulate": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Simulate simulates executing a transaction for estimating gas usage. */
    post: operations["Simulate"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/tx/v1beta1/txs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetTxsEvent fetches txs by event. */
    get: operations["GetTxsEvent"];
    put?: never;
    /** BroadcastTx broadcast transaction. */
    post: operations["BroadcastTx"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/tx/v1beta1/txs/block/{height}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * GetBlockWithTxs fetches a block with decoded txs.
     * @description Since: cosmos-sdk 0.45.2
     */
    get: operations["GetBlockWithTxs"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/tx/v1beta1/txs/{hash}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetTx fetches a tx by hash. */
    get: operations["GetTx"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/upgrade/v1beta1/applied_plan/{name}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** AppliedPlan queries a previously applied upgrade plan by its name. */
    get: operations["AppliedPlan"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/upgrade/v1beta1/current_plan": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** CurrentPlan queries the current upgrade plan. */
    get: operations["CurrentPlan"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/upgrade/v1beta1/module_versions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * ModuleVersions queries the list of module versions from state.
     * @description Since: cosmos-sdk 0.43
     */
    get: operations["ModuleVersions"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** UpgradedConsensusState queries the consensus state that will serve
     *     as a trusted kernel for the next version of this chain. It will only be
     *     stored at the last height of this chain.
     *     UpgradedConsensusState RPC not supported with legacy querier
     *     This rpc is deprecated now that IBC has its own replacement
     *     (https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54) */
    get: operations["DeprecatedUpgradedConsensusState"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/channel/v1/channels": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Channels queries all the IBC channels of a chain. */
    get: operations["Channels"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Channel queries an IBC Channel. */
    get: operations["Channel"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ChannelClientState queries for the client state for the channel associated
     *     with the provided channel identifiers. */
    get: operations["ChannelClientState"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ChannelConsensusState queries for the consensus state for the channel
     *     associated with the provided channel identifiers. */
    get: operations["ChannelConsensusState"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** NextSequenceReceive returns the next receive sequence for a given channel. */
    get: operations["NextSequenceReceive"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** PacketAcknowledgements returns all the packet acknowledgements associated
     *     with a channel. */
    get: operations["PacketAcknowledgements"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** PacketAcknowledgement queries a stored packet acknowledgement hash. */
    get: operations["PacketAcknowledgement"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** PacketCommitments returns all the packet commitments hashes associated
     *     with a channel. */
    get: operations["PacketCommitments"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** UnreceivedAcks returns all the unreceived IBC acknowledgements associated
     *     with a channel and sequences. */
    get: operations["UnreceivedAcks"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** UnreceivedPackets returns all the unreceived IBC packets associated with a
     *     channel and sequences. */
    get: operations["UnreceivedPackets"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** PacketCommitment queries a stored packet commitment hash. */
    get: operations["PacketCommitment"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** PacketReceipt queries if a given packet sequence has been received on the
     *     queried chain */
    get: operations["PacketReceipt"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/channel/v1/connections/{connection}/channels": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ConnectionChannels queries all the channels associated with a connection
     *     end. */
    get: operations["ConnectionChannels"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/client/v1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ClientParams queries all parameters of the ibc client. */
    get: operations["ClientParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/client/v1/client_states": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ClientStates queries all the IBC light clients of a chain. */
    get: operations["ClientStates"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/client/v1/client_states/{client_id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ClientState queries an IBC light client. */
    get: operations["ClientState"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/client/v1/client_status/{client_id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Status queries the status of an IBC client. */
    get: operations["ClientStatus"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/client/v1/consensus_states/{client_id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ConsensusStates queries all the consensus state associated with a given
     *     client. */
    get: operations["ConsensusStates"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/client/v1/consensus_states/{client_id}/heights": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ConsensusStateHeights queries the height of every consensus states associated with a given client. */
    get: operations["ConsensusStateHeights"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ConsensusState queries a consensus state associated with a client state at
     *     a given height. */
    get: operations["ConsensusState"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/client/v1/upgraded_client_states": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** UpgradedClientState queries an Upgraded IBC light client. */
    get: operations["UpgradedClientState"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/client/v1/upgraded_consensus_states": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** UpgradedConsensusState queries an Upgraded IBC consensus state. */
    get: operations["UpgradedConsensusState"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/connection/v1/client_connections/{client_id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ClientConnections queries the connection paths associated with a client
     *     state. */
    get: operations["ClientConnections"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/connection/v1/connections": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Connections queries all the IBC connections of a chain. */
    get: operations["Connections"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/connection/v1/connections/{connection_id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Connection queries an IBC connection end. */
    get: operations["Connection"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/connection/v1/connections/{connection_id}/client_state": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ConnectionClientState queries the client state associated with the
     *     connection. */
    get: operations["ConnectionClientState"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ConnectionConsensusState queries the consensus state associated with the
     *     connection. */
    get: operations["ConnectionConsensusState"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** EscrowAddress returns the escrow address for a particular port and channel id. */
    get: operations["EscrowAddress"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/apps/transfer/v1/denom_hashes/{trace}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DenomHash queries a denomination hash information. */
    get: operations["DenomHash"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/apps/transfer/v1/denom_traces": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DenomTraces queries all denomination traces. */
    get: operations["DenomTraces"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/apps/transfer/v1/denom_traces/{hash}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DenomTrace queries a denomination trace information. */
    get: operations["DenomTrace"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ibc/apps/transfer/v1/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Params queries all parameters of the ibc-transfer module. */
    get: operations["IBCTransferParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmwasm/wasm/v1/code": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Codes gets the metadata for all stored wasm codes */
    get: operations["Codes"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmwasm/wasm/v1/code/{code_id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Code gets the binary code and metadata for a singe wasm code */
    get: operations["Code"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmwasm/wasm/v1/code/{code_id}/contracts": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ContractsByCode lists all smart contracts for a code id */
    get: operations["ContractsByCode"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmwasm/wasm/v1/codes/params": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Params gets the module params */
    get: operations["WasmParams"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmwasm/wasm/v1/codes/pinned": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** PinnedCodes gets the pinned code ids */
    get: operations["PinnedCodes"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmwasm/wasm/v1/contract/{address}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ContractInfo gets the contract meta data */
    get: operations["ContractInfo"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmwasm/wasm/v1/contract/{address}/history": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ContractHistory gets the contract code history */
    get: operations["ContractHistory"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmwasm/wasm/v1/contract/{address}/raw/{query_data}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** RawContractState gets single key from the raw store data of a contract */
    get: operations["RawContractState"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmwasm/wasm/v1/contract/{address}/smart/{query_data}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** SmartContractState get smart query result from the contract */
    get: operations["SmartContractState"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmwasm/wasm/v1/contract/{address}/state": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** AllContractState gets all raw store data for a single contract */
    get: operations["AllContractState"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cosmwasm/wasm/v1/contracts/creator/{creator_address}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ContractsByCreator gets the contracts by creator */
    get: operations["ContractsByCreator"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
     *     URL that describes the type of the serialized message.
     *
     *     Protobuf library provides support to pack/unpack Any values in the form
     *     of utility functions or additional generated methods of the Any type.
     *
     *     Example 1: Pack and unpack a message in C++.
     *
     *         Foo foo = ...;
     *         Any any;
     *         any.PackFrom(foo);
     *         ...
     *         if (any.UnpackTo(&foo)) {
     *           ...
     *         }
     *
     *     Example 2: Pack and unpack a message in Java.
     *
     *         Foo foo = ...;
     *         Any any = Any.pack(foo);
     *         ...
     *         if (any.is(Foo.class)) {
     *           foo = any.unpack(Foo.class);
     *         }
     *
     *      Example 3: Pack and unpack a message in Python.
     *
     *         foo = Foo(...)
     *         any = Any()
     *         any.Pack(foo)
     *         ...
     *         if any.Is(Foo.DESCRIPTOR):
     *           any.Unpack(foo)
     *           ...
     *
     *      Example 4: Pack and unpack a message in Go
     *
     *          foo := &pb.Foo{...}
     *          any, err := anypb.New(foo)
     *          if err != nil {
     *            ...
     *          }
     *          ...
     *          foo := &pb.Foo{}
     *          if err := any.UnmarshalTo(foo); err != nil {
     *            ...
     *          }
     *
     *     The pack methods provided by protobuf library will by default use
     *     'type.googleapis.com/full.type.name' as the type URL and the unpack
     *     methods only use the fully qualified type name after the last '/'
     *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
     *     name "y.z".
     *
     *
     *     JSON
     *     ====
     *     The JSON representation of an `Any` value uses the regular
     *     representation of the deserialized, embedded message, with an
     *     additional field `@type` which contains the type URL. Example:
     *
     *         package google.profile;
     *         message Person {
     *           string first_name = 1;
     *           string last_name = 2;
     *         }
     *
     *         {
     *           "@type": "type.googleapis.com/google.profile.Person",
     *           "firstName": <string>,
     *           "lastName": <string>
     *         }
     *
     *     If the embedded message type is well-known and has a custom JSON
     *     representation, that representation will be embedded adding a field
     *     `value` which holds the custom JSON in addition to the `@type`
     *     field. Example (for message [google.protobuf.Duration][]):
     *
     *         {
     *           "@type": "type.googleapis.com/google.protobuf.Duration",
     *           "value": "1.212s"
     *         } */
    "google.protobuf.Any": {
      /** @description A URL/resource name that uniquely identifies the type of the serialized
       *     protocol buffer message. This string must contain at least
       *     one "/" character. The last segment of the URL's path must represent
       *     the fully qualified name of the type (as in
       *     `path/google.protobuf.Duration`). The name should be in a canonical form
       *     (e.g., leading "." is not accepted).
       *
       *     In practice, teams usually precompile into the binary all types that they
       *     expect it to use in the context of Any. However, for URLs which use the
       *     scheme `http`, `https`, or no scheme, one can optionally set up a type
       *     server that maps type URLs to message definitions as follows:
       *
       *     * If no scheme is provided, `https` is assumed.
       *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *       value in binary format, or produce an error.
       *     * Applications are allowed to cache lookup results based on the
       *       URL, or have them precompiled into a binary to avoid any
       *       lookup. Therefore, binary compatibility needs to be preserved
       *       on changes to types. (Use versioned type names to manage
       *       breaking changes.)
       *
       *     Note: this functionality is not currently available in the official
       *     protobuf release, and it is not used for type URLs beginning with
       *     type.googleapis.com.
       *
       *     Schemes other than `http`, `https` (or the empty scheme) might be
       *     used with implementation specific semantics. */
      type_url?: string;
      /**
       * Format: byte
       * @description Must be a valid serialized protocol buffer of the above specified type.
       */
      value?: string;
    };
    "grpc.gateway.runtime.Error": {
      error?: string;
      /** Format: int32 */
      code?: number;
      message?: string;
      details?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
    };
    /** @description Coin defines a token with a denomination and an amount.
     *
     *     NOTE: The amount field is an Int which implements the custom method
     *     signatures required by gogoproto. */
    "cosmos.base.v1beta1.Coin": {
      denom?: string;
      amount?: string;
    };
    "scalar.nexus.exported.v1beta1.Asset": {
      denom?: string;
      /** Format: boolean */
      is_native_asset?: boolean;
    };
    /** Chain represents the properties of a registered blockchain */
    "scalar.nexus.exported.v1beta1.Chain": {
      /** The descriptor of the chain, e.g. "evm|11155111" */
      name?: string;
      /** Format: boolean */
      supports_foreign_assets?: boolean;
      /**
       * @default KEY_TYPE_UNSPECIFIED
       * @enum {string}
       */
      key_type:
        | "KEY_TYPE_UNSPECIFIED"
        | "KEY_TYPE_NONE"
        | "KEY_TYPE_THRESHOLD"
        | "KEY_TYPE_MULTISIG";
      /** the module has two types: chains and scalarnet */
      module?: string;
    };
    /** MsgAddCosmosBasedChain represents a message to register a cosmos based chain
     *     to nexus */
    "scalar.scalarnet.v1beta1.AddCosmosBasedChainRequest": {
      /** Format: byte */
      sender?: string;
      /** Chain represents the properties of a registered blockchain */
      chain?: {
        /** The descriptor of the chain, e.g. "evm|11155111" */
        name?: string;
        /** Format: boolean */
        supports_foreign_assets?: boolean;
        /**
         * @default KEY_TYPE_UNSPECIFIED
         * @enum {string}
         */
        key_type:
          | "KEY_TYPE_UNSPECIFIED"
          | "KEY_TYPE_NONE"
          | "KEY_TYPE_THRESHOLD"
          | "KEY_TYPE_MULTISIG";
        /** the module has two types: chains and scalarnet */
        module?: string;
      };
      addr_prefix?: string;
      native_assets?: {
        denom?: string;
        /** Format: boolean */
        is_native_asset?: boolean;
      }[];
      /** TODO: Rename this to `chain` after v1beta1 -> v1 version bump */
      cosmos_chain?: string;
      ibc_path?: string;
    };
    "scalar.scalarnet.v1beta1.AddCosmosBasedChainResponse": Record<
      string,
      never
    >;
    "scalar.scalarnet.v1beta1.CallContractProposalMinDeposit": {
      chain?: string;
      contract_address?: string;
      min_deposits?: {
        denom?: string;
        amount?: string;
      }[];
    };
    "scalar.scalarnet.v1beta1.CallContractRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      contract_address?: string;
      /** Format: byte */
      payload?: string;
      fee?: {
        /** @description Coin defines a token with a denomination and an amount.
         *
         *     NOTE: The amount field is an Int which implements the custom method
         *     signatures required by gogoproto. */
        amount?: {
          denom?: string;
          amount?: string;
        };
        /** Format: byte */
        recipient?: string;
        /** Format: byte */
        refund_recipient?: string;
      };
    };
    "scalar.scalarnet.v1beta1.CallContractResponse": Record<string, never>;
    "scalar.scalarnet.v1beta1.ChainByIBCPathResponse": {
      chain?: string;
    };
    /** MsgConfirmDeposit represents a deposit confirmation message */
    "scalar.scalarnet.v1beta1.ConfirmDepositRequest": {
      /** Format: byte */
      sender?: string;
      /** Format: byte */
      deposit_address?: string;
      denom?: string;
    };
    "scalar.scalarnet.v1beta1.ConfirmDepositResponse": Record<string, never>;
    /** MsgExecutePendingTransfers represents a message to trigger transfer all
     *     pending transfers */
    "scalar.scalarnet.v1beta1.ExecutePendingTransfersRequest": {
      /** Format: byte */
      sender?: string;
    };
    "scalar.scalarnet.v1beta1.ExecutePendingTransfersResponse": Record<
      string,
      never
    >;
    "scalar.scalarnet.v1beta1.Fee": {
      /** @description Coin defines a token with a denomination and an amount.
       *
       *     NOTE: The amount field is an Int which implements the custom method
       *     signatures required by gogoproto. */
      amount?: {
        denom?: string;
        amount?: string;
      };
      /** Format: byte */
      recipient?: string;
      /** Format: byte */
      refund_recipient?: string;
    };
    "scalar.scalarnet.v1beta1.IBCPathResponse": {
      ibc_path?: string;
    };
    /** MsgLink represents a message to link a cross-chain address to an Scalar
     *     address */
    "scalar.scalarnet.v1beta1.LinkRequest": {
      /** Format: byte */
      sender?: string;
      recipient_addr?: string;
      recipient_chain?: string;
      asset?: string;
    };
    "scalar.scalarnet.v1beta1.LinkResponse": {
      deposit_addr?: string;
    };
    /** Params represent the genesis parameters for the module */
    "scalar.scalarnet.v1beta1.Params": {
      /**
       * IBC packet route timeout window
       * Format: uint64
       */
      route_timeout_window?: string;
      /** Format: uint64 */
      transfer_limit?: string;
      /** Format: uint64 */
      end_blocker_limit?: string;
      /** Format: int64 */
      version?: number;
      /** Format: byte */
      tag?: string;
      call_contracts_proposal_min_deposits?: {
        chain?: string;
        contract_address?: string;
        min_deposits?: {
          denom?: string;
          amount?: string;
        }[];
      }[];
    };
    "scalar.scalarnet.v1beta1.ParamsResponse": {
      /** Params represent the genesis parameters for the module */
      params?: {
        /**
         * IBC packet route timeout window
         * Format: uint64
         */
        route_timeout_window?: string;
        /** Format: uint64 */
        transfer_limit?: string;
        /** Format: uint64 */
        end_blocker_limit?: string;
        /** Format: int64 */
        version?: number;
        /** Format: byte */
        tag?: string;
        call_contracts_proposal_min_deposits?: {
          chain?: string;
          contract_address?: string;
          min_deposits?: {
            denom?: string;
            amount?: string;
          }[];
        }[];
      };
    };
    "scalar.scalarnet.v1beta1.PendingIBCTransferCountResponse": {
      transfers_by_chain?: {
        [key: string]: number;
      };
    };
    /** RegisterAssetRequest represents a message to register an asset to a cosmos
     *     based chain */
    "scalar.scalarnet.v1beta1.RegisterAssetRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      asset?: {
        denom?: string;
        /** Format: boolean */
        is_native_asset?: boolean;
      };
      /** Format: byte */
      limit?: string;
      window?: string;
    };
    "scalar.scalarnet.v1beta1.RegisterAssetResponse": Record<string, never>;
    /** RegisterFeeCollectorRequest represents a message to register scalarnet fee
     *     collector account */
    "scalar.scalarnet.v1beta1.RegisterFeeCollectorRequest": {
      /** Format: byte */
      sender?: string;
      /** Format: byte */
      fee_collector?: string;
    };
    "scalar.scalarnet.v1beta1.RegisterFeeCollectorResponse": Record<
      string,
      never
    >;
    "scalar.scalarnet.v1beta1.RetryIBCTransferRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      /** Format: uint64 */
      id?: string;
    };
    "scalar.scalarnet.v1beta1.RetryIBCTransferResponse": Record<string, never>;
    /** RouteIBCTransfersRequest represents a message to route pending transfers to
     *     cosmos based chains */
    "scalar.scalarnet.v1beta1.RouteIBCTransfersRequest": {
      /** Format: byte */
      sender?: string;
    };
    "scalar.scalarnet.v1beta1.RouteIBCTransfersResponse": Record<string, never>;
    "scalar.scalarnet.v1beta1.RouteMessageRequest": {
      /** Format: byte */
      sender?: string;
      id?: string;
      /** Format: byte */
      payload?: string;
      /** Format: byte */
      feegranter?: string;
    };
    "scalar.scalarnet.v1beta1.RouteMessageResponse": Record<string, never>;
    /**
     * @default KEY_TYPE_UNSPECIFIED
     * @enum {string}
     */
    "scalar.tss.exported.v1beta1.KeyType":
      | "KEY_TYPE_UNSPECIFIED"
      | "KEY_TYPE_NONE"
      | "KEY_TYPE_THRESHOLD"
      | "KEY_TYPE_MULTISIG";
    "scalar.chains.v1beta1.AddChainRequest": {
      /** Format: byte */
      sender?: string;
      name?: string;
      /** Format: byte */
      params?: string;
    };
    "scalar.chains.v1beta1.AddChainResponse": Record<string, never>;
    "scalar.chains.v1beta1.Asset": {
      chain?: string;
      symbol?: string;
    };
    "scalar.chains.v1beta1.BatchedCommandsResponse": {
      id?: string;
      data?: string;
      /**
       * @default BATCHED_COMMANDS_STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "BATCHED_COMMANDS_STATUS_UNSPECIFIED"
        | "BATCHED_COMMANDS_STATUS_SIGNING"
        | "BATCHED_COMMANDS_STATUS_ABORTED"
        | "BATCHED_COMMANDS_STATUS_SIGNED";
      key_id?: string;
      execute_data?: string;
      prev_batched_commands_id?: string;
      command_ids?: string[];
      proof?: {
        addresses?: string[];
        weights?: string[];
        threshold?: string;
        signatures?: string[];
      };
    };
    /**
     * @default BATCHED_COMMANDS_STATUS_UNSPECIFIED
     * @enum {string}
     */
    "scalar.chains.v1beta1.BatchedCommandsStatus":
      | "BATCHED_COMMANDS_STATUS_UNSPECIFIED"
      | "BATCHED_COMMANDS_STATUS_SIGNING"
      | "BATCHED_COMMANDS_STATUS_ABORTED"
      | "BATCHED_COMMANDS_STATUS_SIGNED";
    "scalar.chains.v1beta1.BurnerInfo": {
      /** Format: byte */
      burner_address?: string;
      /** Format: byte */
      token_address?: string;
      destination_chain?: string;
      symbol?: string;
      asset?: string;
      /** Format: byte */
      salt?: string;
    };
    "scalar.chains.v1beta1.BurnerInfoResponse": {
      chain?: string;
      burner_info?: {
        /** Format: byte */
        burner_address?: string;
        /** Format: byte */
        token_address?: string;
        destination_chain?: string;
        symbol?: string;
        asset?: string;
        /** Format: byte */
        salt?: string;
      };
    };
    "scalar.chains.v1beta1.BytecodeResponse": {
      bytecode?: string;
    };
    /**
     * @default CHAIN_STATUS_UNSPECIFIED
     * @enum {string}
     */
    "scalar.chains.v1beta1.ChainStatus":
      | "CHAIN_STATUS_UNSPECIFIED"
      | "CHAIN_STATUS_ACTIVATED"
      | "CHAIN_STATUS_DEACTIVATED";
    "scalar.chains.v1beta1.ChainsResponse": {
      chains?: string[];
    };
    "scalar.chains.v1beta1.CommandResponse": {
      id?: string;
      type?: string;
      params?: {
        [key: string]: string;
      };
      key_id?: string;
      /** Format: int64 */
      max_gas_cost?: number;
    };
    /** MsgConfirmDeposit represents an erc20 deposit confirmation message */
    "scalar.chains.v1beta1.ConfirmDepositRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      /** Format: byte */
      tx_id?: string;
      /** Format: byte */
      amount?: string;
      /** Format: byte */
      burner_address?: string;
    };
    "scalar.chains.v1beta1.ConfirmDepositResponse": Record<string, never>;
    "scalar.chains.v1beta1.ConfirmSourceTxsRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      tx_ids?: string[];
    };
    "scalar.chains.v1beta1.ConfirmSourceTxsResponse": Record<string, never>;
    /** MsgConfirmToken represents a token deploy confirmation message */
    "scalar.chains.v1beta1.ConfirmTokenRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      /** Format: byte */
      tx_id?: string;
      asset?: {
        chain?: string;
        symbol?: string;
      };
    };
    "scalar.chains.v1beta1.ConfirmTokenResponse": Record<string, never>;
    "scalar.chains.v1beta1.ConfirmTransferKeyRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      /** Format: byte */
      tx_id?: string;
    };
    "scalar.chains.v1beta1.ConfirmTransferKeyResponse": Record<string, never>;
    "scalar.chains.v1beta1.ConfirmationHeightResponse": {
      /** Format: uint64 */
      height?: string;
    };
    /** CreateBurnTokensRequest represents the message to create commands to burn
     *     tokens with scalarGateway */
    "scalar.chains.v1beta1.CreateBurnTokensRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
    };
    "scalar.chains.v1beta1.CreateBurnTokensResponse": Record<string, never>;
    /** CreateDeployTokenRequest represents the message to create a deploy token
     *     command for scalarGateway */
    "scalar.chains.v1beta1.CreateDeployTokenRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      token_symbol?: string;
      aliased_token_name?: string;
      /** Format: byte */
      address?: string;
    };
    "scalar.chains.v1beta1.CreateDeployTokenResponse": Record<string, never>;
    /** CreatePendingTransfersRequest represents a message to trigger the creation of
     *     commands handling all pending transfers */
    "scalar.chains.v1beta1.CreatePendingTransfersRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
    };
    "scalar.chains.v1beta1.CreatePendingTransfersResponse": Record<
      string,
      never
    >;
    "scalar.chains.v1beta1.CreateTransferOperatorshipRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      key_id?: string;
    };
    "scalar.chains.v1beta1.CreateTransferOperatorshipResponse": Record<
      string,
      never
    >;
    /** ERC20TokensResponse describes the asset and symbol for all
     *     ERC20 tokens requested for a chain */
    "scalar.chains.v1beta1.ERC20TokensResponse": {
      tokens?: {
        asset?: string;
        symbol?: string;
      }[];
    };
    "scalar.chains.v1beta1.ERC20TokensResponse.Token": {
      asset?: string;
      symbol?: string;
    };
    "scalar.chains.v1beta1.Event": {
      chain?: string;
      /** Format: byte */
      tx_id?: string;
      /**
       * @default STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "STATUS_UNSPECIFIED"
        | "STATUS_CONFIRMED"
        | "STATUS_COMPLETED"
        | "STATUS_FAILED";
      /** Format: uint64 */
      index?: string;
      token_sent?: {
        chain?: string;
        event_id?: string;
        /** Format: uint64 */
        transfer_id?: string;
        command_id?: string;
        sender?: string;
        destination_chain?: string;
        destination_address?: string;
        /** @description Coin defines a token with a denomination and an amount.
         *
         *     NOTE: The amount field is an Int which implements the custom method
         *     signatures required by gogoproto. */
        asset?: {
          denom?: string;
          amount?: string;
        };
        /**
         * Extra fields for form new utxo
         * Format: byte
         */
        script_pubkey?: string;
        /** Format: int64 */
        vout?: number;
      };
      contract_call?: {
        /** Format: byte */
        sender?: string;
        destination_chain?: string;
        contract_address?: string;
        /** Format: byte */
        payload_hash?: string;
      };
      contract_call_with_token?: {
        /** Format: byte */
        sender?: string;
        destination_chain?: string;
        contract_address?: string;
        /** Format: byte */
        payload_hash?: string;
        symbol?: string;
        /** Format: byte */
        amount?: string;
        /** Format: byte */
        payload?: string;
      };
      contract_call_with_mint_approved?: {
        chain?: string;
        event_id?: string;
        /** Format: byte */
        command_id?: string;
        sender?: string;
        destination_chain?: string;
        contract_address?: string;
        /** Format: byte */
        payload_hash?: string;
        /** @description Coin defines a token with a denomination and an amount.
         *
         *     NOTE: The amount field is an Int which implements the custom method
         *     signatures required by gogoproto. */
        asset?: {
          denom?: string;
          amount?: string;
        };
      };
      transfer?: {
        /** Format: byte */
        to?: string;
        /** Format: byte */
        amount?: string;
      };
      token_deployed?: {
        symbol?: string;
        /** Format: byte */
        token_address?: string;
      };
      multisig_operatorship_transferred?: {
        new_operators?: string[];
        /** Format: byte */
        new_threshold?: string;
        new_weights?: string[];
      };
      /** for general chains */
      source_tx_confirmation_event?: {
        sender?: string;
        destination_chain?: string;
        /** Format: uint64 */
        amount?: string;
        asset?: string;
        /** Format: byte */
        payload_hash?: string;
        /** Format: byte */
        payload?: string;
        destination_contract_address?: string;
        destination_recipient_address?: string;
      };
    };
    /**
     * @default STATUS_UNSPECIFIED
     * @enum {string}
     */
    "scalar.chains.v1beta1.Event.Status":
      | "STATUS_UNSPECIFIED"
      | "STATUS_CONFIRMED"
      | "STATUS_COMPLETED"
      | "STATUS_FAILED";
    "scalar.chains.v1beta1.EventContractCall": {
      /** Format: byte */
      sender?: string;
      destination_chain?: string;
      contract_address?: string;
      /** Format: byte */
      payload_hash?: string;
    };
    "scalar.chains.v1beta1.EventContractCallWithMintApproved": {
      chain?: string;
      event_id?: string;
      /** Format: byte */
      command_id?: string;
      sender?: string;
      destination_chain?: string;
      contract_address?: string;
      /** Format: byte */
      payload_hash?: string;
      /** @description Coin defines a token with a denomination and an amount.
       *
       *     NOTE: The amount field is an Int which implements the custom method
       *     signatures required by gogoproto. */
      asset?: {
        denom?: string;
        amount?: string;
      };
    };
    "scalar.chains.v1beta1.EventContractCallWithToken": {
      /** Format: byte */
      sender?: string;
      destination_chain?: string;
      contract_address?: string;
      /** Format: byte */
      payload_hash?: string;
      symbol?: string;
      /** Format: byte */
      amount?: string;
      /** Format: byte */
      payload?: string;
    };
    "scalar.chains.v1beta1.EventMultisigOperatorshipTransferred": {
      new_operators?: string[];
      /** Format: byte */
      new_threshold?: string;
      new_weights?: string[];
    };
    "scalar.chains.v1beta1.EventResponse": {
      event?: {
        chain?: string;
        /** Format: byte */
        tx_id?: string;
        /**
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_CONFIRMED"
          | "STATUS_COMPLETED"
          | "STATUS_FAILED";
        /** Format: uint64 */
        index?: string;
        token_sent?: {
          chain?: string;
          event_id?: string;
          /** Format: uint64 */
          transfer_id?: string;
          command_id?: string;
          sender?: string;
          destination_chain?: string;
          destination_address?: string;
          /** @description Coin defines a token with a denomination and an amount.
           *
           *     NOTE: The amount field is an Int which implements the custom method
           *     signatures required by gogoproto. */
          asset?: {
            denom?: string;
            amount?: string;
          };
          /**
           * Extra fields for form new utxo
           * Format: byte
           */
          script_pubkey?: string;
          /** Format: int64 */
          vout?: number;
        };
        contract_call?: {
          /** Format: byte */
          sender?: string;
          destination_chain?: string;
          contract_address?: string;
          /** Format: byte */
          payload_hash?: string;
        };
        contract_call_with_token?: {
          /** Format: byte */
          sender?: string;
          destination_chain?: string;
          contract_address?: string;
          /** Format: byte */
          payload_hash?: string;
          symbol?: string;
          /** Format: byte */
          amount?: string;
          /** Format: byte */
          payload?: string;
        };
        contract_call_with_mint_approved?: {
          chain?: string;
          event_id?: string;
          /** Format: byte */
          command_id?: string;
          sender?: string;
          destination_chain?: string;
          contract_address?: string;
          /** Format: byte */
          payload_hash?: string;
          /** @description Coin defines a token with a denomination and an amount.
           *
           *     NOTE: The amount field is an Int which implements the custom method
           *     signatures required by gogoproto. */
          asset?: {
            denom?: string;
            amount?: string;
          };
        };
        transfer?: {
          /** Format: byte */
          to?: string;
          /** Format: byte */
          amount?: string;
        };
        token_deployed?: {
          symbol?: string;
          /** Format: byte */
          token_address?: string;
        };
        multisig_operatorship_transferred?: {
          new_operators?: string[];
          /** Format: byte */
          new_threshold?: string;
          new_weights?: string[];
        };
        /** for general chains */
        source_tx_confirmation_event?: {
          sender?: string;
          destination_chain?: string;
          /** Format: uint64 */
          amount?: string;
          asset?: string;
          /** Format: byte */
          payload_hash?: string;
          /** Format: byte */
          payload?: string;
          destination_contract_address?: string;
          destination_recipient_address?: string;
        };
      };
    };
    "scalar.chains.v1beta1.EventTokenDeployed": {
      symbol?: string;
      /** Format: byte */
      token_address?: string;
    };
    "scalar.chains.v1beta1.EventTokenSent": {
      chain?: string;
      event_id?: string;
      /** Format: uint64 */
      transfer_id?: string;
      command_id?: string;
      sender?: string;
      destination_chain?: string;
      destination_address?: string;
      /** @description Coin defines a token with a denomination and an amount.
       *
       *     NOTE: The amount field is an Int which implements the custom method
       *     signatures required by gogoproto. */
      asset?: {
        denom?: string;
        amount?: string;
      };
      /**
       * Extra fields for form new utxo
       * Format: byte
       */
      script_pubkey?: string;
      /** Format: int64 */
      vout?: number;
    };
    "scalar.chains.v1beta1.EventTransfer": {
      /** Format: byte */
      to?: string;
      /** Format: byte */
      amount?: string;
    };
    "scalar.chains.v1beta1.GatewayAddressResponse": {
      address?: string;
    };
    "scalar.chains.v1beta1.KeyAddressResponse": {
      key_id?: string;
      addresses?: {
        address?: string;
        weight?: string;
      }[];
      threshold?: string;
    };
    "scalar.chains.v1beta1.KeyAddressResponse.WeightedAddress": {
      address?: string;
      weight?: string;
    };
    /** MsgLink represents the message that links a cross chain address to a burner
     *     address */
    "scalar.chains.v1beta1.LinkRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      recipient_addr?: string;
      asset?: string;
      recipient_chain?: string;
    };
    "scalar.chains.v1beta1.LinkResponse": {
      deposit_addr?: string;
    };
    "scalar.chains.v1beta1.Params": {
      chain?: string;
      /** Format: uint64 */
      confirmation_height?: string;
      /** Format: int64 */
      network_kind?: number;
      /** Format: byte */
      token_code?: string;
      /** Format: byte */
      burnable?: string;
      /** Format: int64 */
      revote_locking_period?: string;
      /** Format: byte */
      chain_id?: string;
      voting_threshold?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      /** Format: int64 */
      min_voter_count?: string;
      /** Format: int64 */
      commands_gas_limit?: number;
      /** Format: int64 */
      voting_grace_period?: string;
      /** Format: int64 */
      end_blocker_limit?: string;
      /** Format: uint64 */
      transfer_limit?: string;
      metadata?: {
        [key: string]: string;
      };
    };
    "scalar.chains.v1beta1.ParamsResponse": {
      params?: {
        chain?: string;
        /** Format: uint64 */
        confirmation_height?: string;
        /** Format: int64 */
        network_kind?: number;
        /** Format: byte */
        token_code?: string;
        /** Format: byte */
        burnable?: string;
        /** Format: int64 */
        revote_locking_period?: string;
        /** Format: byte */
        chain_id?: string;
        voting_threshold?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        /** Format: int64 */
        min_voter_count?: string;
        /** Format: int64 */
        commands_gas_limit?: number;
        /** Format: int64 */
        voting_grace_period?: string;
        /** Format: int64 */
        end_blocker_limit?: string;
        /** Format: uint64 */
        transfer_limit?: string;
        metadata?: {
          [key: string]: string;
        };
      };
    };
    "scalar.chains.v1beta1.PendingCommandsResponse": {
      commands?: {
        id?: string;
        type?: string;
        params?: {
          [key: string]: string;
        };
        key_id?: string;
        /** Format: int64 */
        max_gas_cost?: number;
        /** Format: byte */
        payload?: string;
      }[];
    };
    "scalar.chains.v1beta1.Proof": {
      addresses?: string[];
      weights?: string[];
      threshold?: string;
      signatures?: string[];
    };
    "scalar.chains.v1beta1.QueryCommandResponse": {
      id?: string;
      type?: string;
      params?: {
        [key: string]: string;
      };
      key_id?: string;
      /** Format: int64 */
      max_gas_cost?: number;
      /** Format: byte */
      payload?: string;
    };
    "scalar.chains.v1beta1.RedeemSession": {
      /** Format: byte */
      custodian_group_uid?: string;
      /** Format: uint64 */
      sequence?: string;
      /**
       * @default PHASE_PREPARING
       * @enum {string}
       */
      current_phase: "PHASE_PREPARING" | "PHASE_EXECUTING";
    };
    "scalar.chains.v1beta1.RedeemSessionResponse": {
      redeem_session?: {
        /** Format: byte */
        custodian_group_uid?: string;
        /** Format: uint64 */
        sequence?: string;
        /**
         * @default PHASE_PREPARING
         * @enum {string}
         */
        current_phase: "PHASE_PREPARING" | "PHASE_EXECUTING";
      }[];
    };
    "scalar.chains.v1beta1.RegisterCustodianGroupRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      /** Format: byte */
      custodian_group_uid?: string;
    };
    "scalar.chains.v1beta1.RegisterCustodianGroupResponse": Record<
      string,
      never
    >;
    "scalar.chains.v1beta1.RetryFailedEventRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      event_id?: string;
    };
    "scalar.chains.v1beta1.RetryFailedEventResponse": Record<string, never>;
    "scalar.chains.v1beta1.SetGatewayRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      /** Format: byte */
      address?: string;
    };
    "scalar.chains.v1beta1.SetGatewayResponse": Record<string, never>;
    "scalar.chains.v1beta1.SignBtcCommandsRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
    };
    "scalar.chains.v1beta1.SignCommandsRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
    };
    "scalar.chains.v1beta1.SignCommandsResponse": {
      /** Format: byte */
      batched_commands_id?: string;
      /** Format: int64 */
      command_count?: number;
    };
    "scalar.chains.v1beta1.SourceTxConfirmationEvent": {
      sender?: string;
      destination_chain?: string;
      /** Format: uint64 */
      amount?: string;
      asset?: string;
      /** Format: byte */
      payload_hash?: string;
      /** Format: byte */
      payload?: string;
      destination_contract_address?: string;
      destination_recipient_address?: string;
    };
    "scalar.chains.v1beta1.TokenInfoResponse": {
      asset?: string;
      details?: {
        token_name?: string;
        symbol?: string;
        /** Format: int64 */
        decimals?: number;
        /** Format: byte */
        capacity?: string;
      };
      address?: string;
      /** Format: boolean */
      confirmed?: boolean;
      /** Format: boolean */
      is_external?: boolean;
      burner_code_hash?: string;
    };
    /**
     * @default TOKEN_TYPE_UNSPECIFIED
     * @enum {string}
     */
    "scalar.chains.v1beta1.TokenType":
      | "TOKEN_TYPE_UNSPECIFIED"
      | "TOKEN_TYPE_INTERNAL"
      | "TOKEN_TYPE_EXTERNAL";
    /**
     * @default PHASE_PREPARING
     * @enum {string}
     */
    "scalar.covenant.exported.v1beta1.Phase":
      | "PHASE_PREPARING"
      | "PHASE_EXECUTING";
    "scalar.nexus.exported.v1beta1.TokenDetails": {
      token_name?: string;
      symbol?: string;
      /** Format: int64 */
      decimals?: number;
      /** Format: byte */
      capacity?: string;
    };
    "scalar.utils.v1beta1.Threshold": {
      /**
       * split threshold into Numerator and denominator to avoid floating point
       *     errors down the line
       * Format: int64
       */
      numerator?: string;
      /** Format: int64 */
      denominator?: string;
    };
    /** Custodian represents an individual custodian configuration */
    "scalar.covenant.exported.v1beta1.Custodian": {
      name?: string;
      val_address?: string;
      /** Format: byte */
      bitcoin_pubkey?: string;
      /**
       * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
       * @default STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "STATUS_UNSPECIFIED"
        | "STATUS_ACTIVATED"
        | "STATUS_DEACTIVATED"
        | "STATUS_PENDING";
      description?: string;
    };
    /** CustodianGroup represents a group of custodians with their configuration
     *     uid is used as identity of the group, btc_pubkey is change by list of
     *     custodians */
    "scalar.covenant.exported.v1beta1.CustodianGroup": {
      /**
       * the UID is unique, to distinguish between custodian groups
       * Format: byte
       */
      uid?: string;
      name?: string;
      /** Format: byte */
      bitcoin_pubkey?: string;
      /**
       * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
       * Format: int64
       */
      quorum?: number;
      /**
       * @default STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "STATUS_UNSPECIFIED"
        | "STATUS_ACTIVATED"
        | "STATUS_DEACTIVATED"
        | "STATUS_PENDING";
      description?: string;
      custodians?: {
        name?: string;
        val_address?: string;
        /** Format: byte */
        bitcoin_pubkey?: string;
        /**
         * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        description?: string;
      }[];
    };
    /**
     * @default STATUS_UNSPECIFIED
     * @enum {string}
     */
    "scalar.covenant.exported.v1beta1.Status":
      | "STATUS_UNSPECIFIED"
      | "STATUS_ACTIVATED"
      | "STATUS_DEACTIVATED"
      | "STATUS_PENDING";
    /**
     * @default LIQUIDITY_MODEL_UNSPECIFIED
     * @enum {string}
     */
    "scalar.protocol.exported.v1beta1.LiquidityModel":
      | "LIQUIDITY_MODEL_UNSPECIFIED"
      | "LIQUIDITY_MODEL_POOL"
      | "LIQUIDITY_MODEL_UPC";
    "scalar.protocol.exported.v1beta1.ProtocolAttributes": {
      /**
       * @default LIQUIDITY_MODEL_UNSPECIFIED
       * @enum {string}
       */
      model:
        | "LIQUIDITY_MODEL_UNSPECIFIED"
        | "LIQUIDITY_MODEL_POOL"
        | "LIQUIDITY_MODEL_UPC";
    };
    /**
     * @default STATUS_UNSPECIFIED
     * @enum {string}
     */
    "scalar.protocol.exported.v1beta1.Status":
      | "STATUS_UNSPECIFIED"
      | "STATUS_ACTIVATED"
      | "STATUS_DEACTIVATED"
      | "STATUS_PENDING";
    "scalar.protocol.exported.v1beta1.SupportedChain": {
      chain?: string;
      name?: string;
      address?: string;
    };
    "scalar.protocol.v1beta1.AddSupportedChainRequest": {
      /** Format: byte */
      sender?: string;
      chain?: {
        chain?: string;
        name?: string;
        address?: string;
      };
    };
    "scalar.protocol.v1beta1.AddSupportedChainResponse": {
      protocol?: {
        /** Format: byte */
        bitcoin_pubkey?: string;
        /** Format: byte */
        scalar_address?: string;
        name?: string;
        /** Format: byte */
        tag?: string;
        attributes?: {
          /**
           * @default LIQUIDITY_MODEL_UNSPECIFIED
           * @enum {string}
           */
          model:
            | "LIQUIDITY_MODEL_UNSPECIFIED"
            | "LIQUIDITY_MODEL_POOL"
            | "LIQUIDITY_MODEL_UPC";
        };
        /**
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        /** Format: byte */
        custodian_group_uid?: string;
        chains?: {
          chain?: string;
          name?: string;
          address?: string;
        }[];
        /** Format: byte */
        avatar?: string;
        asset?: {
          chain?: string;
          symbol?: string;
        };
        token_details?: {
          token_name?: string;
          symbol?: string;
          /** Format: int64 */
          decimals?: number;
          /** Format: byte */
          capacity?: string;
        };
        /** Format: byte */
        token_daily_mint_limit?: string;
      };
    };
    "scalar.protocol.v1beta1.CreateProtocolRequest": {
      /**
       * // TODO: Consider to add rbac for this message
       *     option (permission.exported.v1beta1.permission_role) =
       *     ROLE_CHAIN_MANAGEMENT;
       * Format: byte
       */
      sender?: string;
      /** Format: byte */
      bitcoin_pubkey?: string;
      name?: string;
      tag?: string;
      attributes?: {
        /**
         * @default LIQUIDITY_MODEL_UNSPECIFIED
         * @enum {string}
         */
        model:
          | "LIQUIDITY_MODEL_UNSPECIFIED"
          | "LIQUIDITY_MODEL_POOL"
          | "LIQUIDITY_MODEL_UPC";
      };
      /** Format: byte */
      custodian_group_uid?: string;
      /** Format: byte */
      avatar?: string;
      asset?: {
        chain?: string;
        symbol?: string;
      };
      token_name?: string;
      /** Format: int64 */
      token_decimals?: number;
      token_capacity?: string;
      token_daily_mint_limit?: string;
    };
    "scalar.protocol.v1beta1.CreateProtocolResponse": {
      protocol?: {
        /** Format: byte */
        bitcoin_pubkey?: string;
        /** Format: byte */
        scalar_address?: string;
        name?: string;
        /** Format: byte */
        tag?: string;
        attributes?: {
          /**
           * @default LIQUIDITY_MODEL_UNSPECIFIED
           * @enum {string}
           */
          model:
            | "LIQUIDITY_MODEL_UNSPECIFIED"
            | "LIQUIDITY_MODEL_POOL"
            | "LIQUIDITY_MODEL_UPC";
        };
        /**
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        /** Format: byte */
        custodian_group_uid?: string;
        chains?: {
          chain?: string;
          name?: string;
          address?: string;
        }[];
        /** Format: byte */
        avatar?: string;
        asset?: {
          chain?: string;
          symbol?: string;
        };
        token_details?: {
          token_name?: string;
          symbol?: string;
          /** Format: int64 */
          decimals?: number;
          /** Format: byte */
          capacity?: string;
        };
        /** Format: byte */
        token_daily_mint_limit?: string;
      };
    };
    "scalar.protocol.v1beta1.Protocol": {
      /** Format: byte */
      bitcoin_pubkey?: string;
      /** Format: byte */
      scalar_address?: string;
      name?: string;
      /** Format: byte */
      tag?: string;
      attributes?: {
        /**
         * @default LIQUIDITY_MODEL_UNSPECIFIED
         * @enum {string}
         */
        model:
          | "LIQUIDITY_MODEL_UNSPECIFIED"
          | "LIQUIDITY_MODEL_POOL"
          | "LIQUIDITY_MODEL_UPC";
      };
      /**
       * @default STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "STATUS_UNSPECIFIED"
        | "STATUS_ACTIVATED"
        | "STATUS_DEACTIVATED"
        | "STATUS_PENDING";
      /** Format: byte */
      custodian_group_uid?: string;
      chains?: {
        chain?: string;
        name?: string;
        address?: string;
      }[];
      /** Format: byte */
      avatar?: string;
      asset?: {
        chain?: string;
        symbol?: string;
      };
      token_details?: {
        token_name?: string;
        symbol?: string;
        /** Format: int64 */
        decimals?: number;
        /** Format: byte */
        capacity?: string;
      };
      /** Format: byte */
      token_daily_mint_limit?: string;
    };
    "scalar.protocol.v1beta1.ProtocolDetails": {
      /** Format: byte */
      scalar_address?: string;
      /** Format: byte */
      bitcoin_pubkey?: string;
      name?: string;
      /** Format: byte */
      tag?: string;
      attributes?: {
        /**
         * @default LIQUIDITY_MODEL_UNSPECIFIED
         * @enum {string}
         */
        model:
          | "LIQUIDITY_MODEL_UNSPECIFIED"
          | "LIQUIDITY_MODEL_POOL"
          | "LIQUIDITY_MODEL_UPC";
      };
      /**
       * @default STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "STATUS_UNSPECIFIED"
        | "STATUS_ACTIVATED"
        | "STATUS_DEACTIVATED"
        | "STATUS_PENDING";
      /** Format: byte */
      custodian_group_uid?: string;
      chains?: {
        chain?: string;
        name?: string;
        address?: string;
      }[];
      /** Format: byte */
      avatar?: string;
      /** CustodianGroup represents a group of custodians with their configuration
       *     uid is used as identity of the group, btc_pubkey is change by list of
       *     custodians */
      custodian_group?: {
        /**
         * the UID is unique, to distinguish between custodian groups
         * Format: byte
         */
        uid?: string;
        name?: string;
        /** Format: byte */
        bitcoin_pubkey?: string;
        /**
         * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
         * Format: int64
         */
        quorum?: number;
        /**
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        description?: string;
        custodians?: {
          name?: string;
          val_address?: string;
          /** Format: byte */
          bitcoin_pubkey?: string;
          /**
           * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
           * @default STATUS_UNSPECIFIED
           * @enum {string}
           */
          status:
            | "STATUS_UNSPECIFIED"
            | "STATUS_ACTIVATED"
            | "STATUS_DEACTIVATED"
            | "STATUS_PENDING";
          description?: string;
        }[];
      };
      asset?: {
        chain?: string;
        symbol?: string;
      };
      token_details?: {
        token_name?: string;
        symbol?: string;
        /** Format: int64 */
        decimals?: number;
        /** Format: byte */
        capacity?: string;
      };
      /** Format: byte */
      token_daily_mint_limit?: string;
    };
    "scalar.protocol.v1beta1.ProtocolResponse": {
      protocol?: {
        /** Format: byte */
        scalar_address?: string;
        /** Format: byte */
        bitcoin_pubkey?: string;
        name?: string;
        /** Format: byte */
        tag?: string;
        attributes?: {
          /**
           * @default LIQUIDITY_MODEL_UNSPECIFIED
           * @enum {string}
           */
          model:
            | "LIQUIDITY_MODEL_UNSPECIFIED"
            | "LIQUIDITY_MODEL_POOL"
            | "LIQUIDITY_MODEL_UPC";
        };
        /**
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        /** Format: byte */
        custodian_group_uid?: string;
        chains?: {
          chain?: string;
          name?: string;
          address?: string;
        }[];
        /** Format: byte */
        avatar?: string;
        /** CustodianGroup represents a group of custodians with their configuration
         *     uid is used as identity of the group, btc_pubkey is change by list of
         *     custodians */
        custodian_group?: {
          /**
           * the UID is unique, to distinguish between custodian groups
           * Format: byte
           */
          uid?: string;
          name?: string;
          /** Format: byte */
          bitcoin_pubkey?: string;
          /**
           * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
           * Format: int64
           */
          quorum?: number;
          /**
           * @default STATUS_UNSPECIFIED
           * @enum {string}
           */
          status:
            | "STATUS_UNSPECIFIED"
            | "STATUS_ACTIVATED"
            | "STATUS_DEACTIVATED"
            | "STATUS_PENDING";
          description?: string;
          custodians?: {
            name?: string;
            val_address?: string;
            /** Format: byte */
            bitcoin_pubkey?: string;
            /**
             * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
             * @default STATUS_UNSPECIFIED
             * @enum {string}
             */
            status:
              | "STATUS_UNSPECIFIED"
              | "STATUS_ACTIVATED"
              | "STATUS_DEACTIVATED"
              | "STATUS_PENDING";
            description?: string;
          }[];
        };
        asset?: {
          chain?: string;
          symbol?: string;
        };
        token_details?: {
          token_name?: string;
          symbol?: string;
          /** Format: int64 */
          decimals?: number;
          /** Format: byte */
          capacity?: string;
        };
        /** Format: byte */
        token_daily_mint_limit?: string;
      };
    };
    "scalar.protocol.v1beta1.ProtocolsResponse": {
      protocols?: {
        /** Format: byte */
        scalar_address?: string;
        /** Format: byte */
        bitcoin_pubkey?: string;
        name?: string;
        /** Format: byte */
        tag?: string;
        attributes?: {
          /**
           * @default LIQUIDITY_MODEL_UNSPECIFIED
           * @enum {string}
           */
          model:
            | "LIQUIDITY_MODEL_UNSPECIFIED"
            | "LIQUIDITY_MODEL_POOL"
            | "LIQUIDITY_MODEL_UPC";
        };
        /**
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        /** Format: byte */
        custodian_group_uid?: string;
        chains?: {
          chain?: string;
          name?: string;
          address?: string;
        }[];
        /** Format: byte */
        avatar?: string;
        /** CustodianGroup represents a group of custodians with their configuration
         *     uid is used as identity of the group, btc_pubkey is change by list of
         *     custodians */
        custodian_group?: {
          /**
           * the UID is unique, to distinguish between custodian groups
           * Format: byte
           */
          uid?: string;
          name?: string;
          /** Format: byte */
          bitcoin_pubkey?: string;
          /**
           * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
           * Format: int64
           */
          quorum?: number;
          /**
           * @default STATUS_UNSPECIFIED
           * @enum {string}
           */
          status:
            | "STATUS_UNSPECIFIED"
            | "STATUS_ACTIVATED"
            | "STATUS_DEACTIVATED"
            | "STATUS_PENDING";
          description?: string;
          custodians?: {
            name?: string;
            val_address?: string;
            /** Format: byte */
            bitcoin_pubkey?: string;
            /**
             * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
             * @default STATUS_UNSPECIFIED
             * @enum {string}
             */
            status:
              | "STATUS_UNSPECIFIED"
              | "STATUS_ACTIVATED"
              | "STATUS_DEACTIVATED"
              | "STATUS_PENDING";
            description?: string;
          }[];
        };
        asset?: {
          chain?: string;
          symbol?: string;
        };
        token_details?: {
          token_name?: string;
          symbol?: string;
          /** Format: int64 */
          decimals?: number;
          /** Format: byte */
          capacity?: string;
        };
        /** Format: byte */
        token_daily_mint_limit?: string;
      }[];
      /** Format: uint64 */
      total?: string;
    };
    /** pubkey used as protocol unique id */
    "scalar.protocol.v1beta1.UpdateProtocolRequest": {
      /** Format: byte */
      sender?: string;
      name?: string;
      tag?: string;
    };
    "scalar.protocol.v1beta1.UpdateProtocolResponse": {
      protocol?: {
        /** Format: byte */
        bitcoin_pubkey?: string;
        /** Format: byte */
        scalar_address?: string;
        name?: string;
        /** Format: byte */
        tag?: string;
        attributes?: {
          /**
           * @default LIQUIDITY_MODEL_UNSPECIFIED
           * @enum {string}
           */
          model:
            | "LIQUIDITY_MODEL_UNSPECIFIED"
            | "LIQUIDITY_MODEL_POOL"
            | "LIQUIDITY_MODEL_UPC";
        };
        /**
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        /** Format: byte */
        custodian_group_uid?: string;
        chains?: {
          chain?: string;
          name?: string;
          address?: string;
        }[];
        /** Format: byte */
        avatar?: string;
        asset?: {
          chain?: string;
          symbol?: string;
        };
        token_details?: {
          token_name?: string;
          symbol?: string;
          /** Format: int64 */
          decimals?: number;
          /** Format: byte */
          capacity?: string;
        };
        /** Format: byte */
        token_daily_mint_limit?: string;
      };
    };
    "scalar.protocol.v1beta1.UpdateSupportedChainRequest": {
      /** Format: byte */
      sender?: string;
      chain_family?: string;
      /** Format: uint64 */
      chain_id?: string;
      /**
       * @default STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "STATUS_UNSPECIFIED"
        | "STATUS_ACTIVATED"
        | "STATUS_DEACTIVATED"
        | "STATUS_PENDING";
    };
    "scalar.protocol.v1beta1.UpdateSupportedChainResponse": {
      protocol?: {
        /** Format: byte */
        bitcoin_pubkey?: string;
        /** Format: byte */
        scalar_address?: string;
        name?: string;
        /** Format: byte */
        tag?: string;
        attributes?: {
          /**
           * @default LIQUIDITY_MODEL_UNSPECIFIED
           * @enum {string}
           */
          model:
            | "LIQUIDITY_MODEL_UNSPECIFIED"
            | "LIQUIDITY_MODEL_POOL"
            | "LIQUIDITY_MODEL_UPC";
        };
        /**
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        /** Format: byte */
        custodian_group_uid?: string;
        chains?: {
          chain?: string;
          name?: string;
          address?: string;
        }[];
        /** Format: byte */
        avatar?: string;
        asset?: {
          chain?: string;
          symbol?: string;
        };
        token_details?: {
          token_name?: string;
          symbol?: string;
          /** Format: int64 */
          decimals?: number;
          /** Format: byte */
          capacity?: string;
        };
        /** Format: byte */
        token_daily_mint_limit?: string;
      };
    };
    "scalar.covenant.exported.v1beta1.TapScriptSig": {
      /** Format: byte */
      key_x_only?: string;
      /** Format: byte */
      leaf_hash?: string;
      /** Format: byte */
      signature?: string;
    };
    "scalar.covenant.exported.v1beta1.TapScriptSigsEntry": {
      /** Format: uint64 */
      index?: string;
      sigs?: {
        list?: {
          /** Format: byte */
          key_x_only?: string;
          /** Format: byte */
          leaf_hash?: string;
          /** Format: byte */
          signature?: string;
        }[];
      };
    };
    "scalar.covenant.exported.v1beta1.TapScriptSigsList": {
      list?: {
        /** Format: byte */
        key_x_only?: string;
        /** Format: byte */
        leaf_hash?: string;
        /** Format: byte */
        signature?: string;
      }[];
    };
    /** The reason we use a list instead of a map is because the map is not ensured
     *     the deterministic order of the entries */
    "scalar.covenant.exported.v1beta1.TapScriptSigsMap": {
      inner?: {
        /** Format: uint64 */
        index?: string;
        sigs?: {
          list?: {
            /** Format: byte */
            key_x_only?: string;
            /** Format: byte */
            leaf_hash?: string;
            /** Format: byte */
            signature?: string;
          }[];
        };
      }[];
    };
    "scalar.covenant.v1beta1.AddCustodianToGroupRequest": {
      /** Format: byte */
      sender?: string;
      guid?: string;
      /** Format: byte */
      custodian_pubkey?: string;
      description?: string;
    };
    /** Confirm exectuted transaction on bitcoin */
    "scalar.covenant.v1beta1.ConfirmRedeemTxsRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      tx_ids?: string[];
      /** Format: byte */
      custodian_group_uid?: string;
    };
    "scalar.covenant.v1beta1.ConfirmRedeemTxsResponse": Record<string, never>;
    "scalar.covenant.v1beta1.ConfirmSwitchedPhaseRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      /** Format: byte */
      custodian_group_uid?: string;
      /** Format: byte */
      tx_id?: string;
    };
    "scalar.covenant.v1beta1.ConfirmSwitchedPhaseResponse": Record<
      string,
      never
    >;
    "scalar.covenant.v1beta1.CreateCustodianGroupRequest": {
      /** Format: byte */
      sender?: string;
      uid?: string;
      name?: string;
      /** Format: int64 */
      quorum?: number;
      /**
       * @default STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "STATUS_UNSPECIFIED"
        | "STATUS_ACTIVATED"
        | "STATUS_DEACTIVATED"
        | "STATUS_PENDING";
      description?: string;
      custodian?: string[];
    };
    "scalar.covenant.v1beta1.CreateCustodianGroupResponse": {
      /** CustodianGroup represents a group of custodians with their configuration
       *     uid is used as identity of the group, btc_pubkey is change by list of
       *     custodians */
      group?: {
        /**
         * the UID is unique, to distinguish between custodian groups
         * Format: byte
         */
        uid?: string;
        name?: string;
        /** Format: byte */
        bitcoin_pubkey?: string;
        /**
         * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
         * Format: int64
         */
        quorum?: number;
        /**
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        description?: string;
        custodians?: {
          name?: string;
          val_address?: string;
          /** Format: byte */
          bitcoin_pubkey?: string;
          /**
           * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
           * @default STATUS_UNSPECIFIED
           * @enum {string}
           */
          status:
            | "STATUS_UNSPECIFIED"
            | "STATUS_ACTIVATED"
            | "STATUS_DEACTIVATED"
            | "STATUS_PENDING";
          description?: string;
        }[];
      };
    };
    "scalar.covenant.v1beta1.CreateCustodianRequest": {
      /** Format: byte */
      sender?: string;
      name?: string;
      /** Format: byte */
      bitcoin_pubkey?: string;
      /**
       * @default STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "STATUS_UNSPECIFIED"
        | "STATUS_ACTIVATED"
        | "STATUS_DEACTIVATED"
        | "STATUS_PENDING";
      description?: string;
    };
    "scalar.covenant.v1beta1.CreateCustodianResponse": {
      /** Custodian represents an individual custodian configuration */
      custodian?: {
        name?: string;
        val_address?: string;
        /** Format: byte */
        bitcoin_pubkey?: string;
        /**
         * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        description?: string;
      };
    };
    "scalar.covenant.v1beta1.CustodianToGroupResponse": {
      /** CustodianGroup represents a group of custodians with their configuration
       *     uid is used as identity of the group, btc_pubkey is change by list of
       *     custodians */
      group?: {
        /**
         * the UID is unique, to distinguish between custodian groups
         * Format: byte
         */
        uid?: string;
        name?: string;
        /** Format: byte */
        bitcoin_pubkey?: string;
        /**
         * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
         * Format: int64
         */
        quorum?: number;
        /**
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        description?: string;
        custodians?: {
          name?: string;
          val_address?: string;
          /** Format: byte */
          bitcoin_pubkey?: string;
          /**
           * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
           * @default STATUS_UNSPECIFIED
           * @enum {string}
           */
          status:
            | "STATUS_UNSPECIFIED"
            | "STATUS_ACTIVATED"
            | "STATUS_DEACTIVATED"
            | "STATUS_PENDING";
          description?: string;
        }[];
      };
    };
    "scalar.covenant.v1beta1.CustodiansResponse": {
      custodians?: {
        name?: string;
        val_address?: string;
        /** Format: byte */
        bitcoin_pubkey?: string;
        /**
         * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        description?: string;
      }[];
    };
    "scalar.covenant.v1beta1.GroupsResponse": {
      groups?: {
        /**
         * the UID is unique, to distinguish between custodian groups
         * Format: byte
         */
        uid?: string;
        name?: string;
        /** Format: byte */
        bitcoin_pubkey?: string;
        /**
         * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
         * Format: int64
         */
        quorum?: number;
        /**
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        description?: string;
        custodians?: {
          name?: string;
          val_address?: string;
          /** Format: byte */
          bitcoin_pubkey?: string;
          /**
           * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
           * @default STATUS_UNSPECIFIED
           * @enum {string}
           */
          status:
            | "STATUS_UNSPECIFIED"
            | "STATUS_ACTIVATED"
            | "STATUS_DEACTIVATED"
            | "STATUS_PENDING";
          description?: string;
        }[];
      }[];
    };
    "scalar.covenant.v1beta1.InitializeUtxoRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      /** Format: uint64 */
      block_checkpoint?: string;
    };
    "scalar.covenant.v1beta1.InitializeUtxoResponse": Record<string, never>;
    /** Params represent the genesis parameters for the module */
    "scalar.covenant.v1beta1.Params": {
      signing_threshold?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      /** Format: int64 */
      signing_timeout?: string;
      /** Format: int64 */
      signing_grace_period?: string;
      /** Format: uint64 */
      active_epoch_count?: string;
      /** Format: uint64 */
      block_limit_per_session?: string;
    };
    "scalar.covenant.v1beta1.ParamsResponse": {
      /** Params represent the genesis parameters for the module */
      params?: {
        signing_threshold?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        /** Format: int64 */
        signing_timeout?: string;
        /** Format: int64 */
        signing_grace_period?: string;
        /** Format: uint64 */
        active_epoch_count?: string;
        /** Format: uint64 */
        block_limit_per_session?: string;
      };
    };
    "scalar.covenant.v1beta1.RedeemSession": {
      /** Format: byte */
      custodian_group_uid?: string;
      /** Format: uint64 */
      sequence?: string;
      /**
       * @default PHASE_PREPARING
       * @enum {string}
       */
      current_phase: "PHASE_PREPARING" | "PHASE_EXECUTING";
      /** Format: byte */
      last_redeem_tx?: string;
      /** Format: boolean */
      is_switching?: boolean;
      /** Format: uint64 */
      phase_expired_at?: string;
    };
    "scalar.covenant.v1beta1.RedeemSessionResponse": {
      session?: {
        /** Format: byte */
        custodian_group_uid?: string;
        /** Format: uint64 */
        sequence?: string;
        /**
         * @default PHASE_PREPARING
         * @enum {string}
         */
        current_phase: "PHASE_PREPARING" | "PHASE_EXECUTING";
        /** Format: byte */
        last_redeem_tx?: string;
        /** Format: boolean */
        is_switching?: boolean;
        /** Format: uint64 */
        phase_expired_at?: string;
      };
    };
    "scalar.covenant.v1beta1.RemoveCustodianFromGroupRequest": {
      /** Format: byte */
      sender?: string;
      guid?: string;
      /** Format: byte */
      custodian_pubkey?: string;
      description?: string;
    };
    "scalar.covenant.v1beta1.ReserveRedeemUtxoRequest": {
      /** Format: byte */
      sender?: string;
      address?: string;
      source_chain?: string;
      dest_chain?: string;
      symbol?: string;
      /** Format: uint64 */
      amount?: string;
      /** Format: byte */
      locking_script?: string;
    };
    "scalar.covenant.v1beta1.ReserveRedeemUtxoResponse": Record<string, never>;
    /** Rotate key for custodian group */
    "scalar.covenant.v1beta1.RotateKeyRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
    };
    "scalar.covenant.v1beta1.RotateKeyResponse": Record<string, never>;
    "scalar.covenant.v1beta1.StandaloneCommandResponse": {
      /** Format: byte */
      id?: string;
      data?: string;
      /**
       * @default STANDALONE_COMMAND_STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "STANDALONE_COMMAND_STATUS_UNSPECIFIED"
        | "STANDALONE_COMMAND_STATUS_SIGNING"
        | "STANDALONE_COMMAND_STATUS_ABORTED"
        | "STANDALONE_COMMAND_STATUS_SIGNED";
      key_id?: string;
      execute_data?: string;
    };
    /**
     * @default STANDALONE_COMMAND_STATUS_UNSPECIFIED
     * @enum {string}
     */
    "scalar.covenant.v1beta1.StandaloneCommandStatus":
      | "STANDALONE_COMMAND_STATUS_UNSPECIFIED"
      | "STANDALONE_COMMAND_STATUS_SIGNING"
      | "STANDALONE_COMMAND_STATUS_ABORTED"
      | "STANDALONE_COMMAND_STATUS_SIGNED";
    "scalar.covenant.v1beta1.SubmitTapScriptSigsRequest": {
      /** Format: byte */
      sender?: string;
      /** Format: uint64 */
      sig_id?: string;
      list_of_tap_script_sigs_map?: {
        inner?: {
          /** Format: uint64 */
          index?: string;
          sigs?: {
            list?: {
              /** Format: byte */
              key_x_only?: string;
              /** Format: byte */
              leaf_hash?: string;
              /** Format: byte */
              signature?: string;
            }[];
          };
        }[];
      }[];
    };
    "scalar.covenant.v1beta1.SubmitTapScriptSigsResponse": Record<
      string,
      never
    >;
    "scalar.covenant.v1beta1.UTXO": {
      /** Format: byte */
      txid?: string;
      /** Format: int64 */
      vout?: number;
      /** Format: byte */
      script_pubkey?: string;
      /** Format: uint64 */
      amount_in_sats?: string;
      /** Reserved amount for each request id */
      reserved?: {
        [key: string]: string;
      };
    };
    "scalar.covenant.v1beta1.UTXOSnapshot": {
      /** Format: byte */
      custodian_group_uid?: string;
      /** Format: uint64 */
      block_height?: string;
      utxos?: {
        /** Format: byte */
        txid?: string;
        /** Format: int64 */
        vout?: number;
        /** Format: byte */
        script_pubkey?: string;
        /** Format: uint64 */
        amount_in_sats?: string;
        /** Reserved amount for each request id */
        reserved?: {
          [key: string]: string;
        };
      }[];
    };
    "scalar.covenant.v1beta1.UTXOSnapshotResponse": {
      utxo_snapshot?: {
        /** Format: byte */
        custodian_group_uid?: string;
        /** Format: uint64 */
        block_height?: string;
        utxos?: {
          /** Format: byte */
          txid?: string;
          /** Format: int64 */
          vout?: number;
          /** Format: byte */
          script_pubkey?: string;
          /** Format: uint64 */
          amount_in_sats?: string;
          /** Reserved amount for each request id */
          reserved?: {
            [key: string]: string;
          };
        }[];
      };
    };
    "scalar.covenant.v1beta1.UpdateCustodianGroupRequest": {
      /** Format: byte */
      sender?: string;
      uid?: string;
      name?: string;
      /** Format: int64 */
      quorum?: number;
      /**
       * @default STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "STATUS_UNSPECIFIED"
        | "STATUS_ACTIVATED"
        | "STATUS_DEACTIVATED"
        | "STATUS_PENDING";
      description?: string;
      custodian?: string[];
    };
    "scalar.covenant.v1beta1.UpdateCustodianGroupResponse": {
      /** CustodianGroup represents a group of custodians with their configuration
       *     uid is used as identity of the group, btc_pubkey is change by list of
       *     custodians */
      group?: {
        /**
         * the UID is unique, to distinguish between custodian groups
         * Format: byte
         */
        uid?: string;
        name?: string;
        /** Format: byte */
        bitcoin_pubkey?: string;
        /**
         * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
         * Format: int64
         */
        quorum?: number;
        /**
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        description?: string;
        custodians?: {
          name?: string;
          val_address?: string;
          /** Format: byte */
          bitcoin_pubkey?: string;
          /**
           * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
           * @default STATUS_UNSPECIFIED
           * @enum {string}
           */
          status:
            | "STATUS_UNSPECIFIED"
            | "STATUS_ACTIVATED"
            | "STATUS_DEACTIVATED"
            | "STATUS_PENDING";
          description?: string;
        }[];
      };
    };
    /** Pubkey used as key for lookup custodian to update other values */
    "scalar.covenant.v1beta1.UpdateCustodianRequest": {
      /** Format: byte */
      sender?: string;
      /** Format: byte */
      bitcoin_pubkey?: string;
      name?: string;
      /**
       * @default STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "STATUS_UNSPECIFIED"
        | "STATUS_ACTIVATED"
        | "STATUS_DEACTIVATED"
        | "STATUS_PENDING";
      description?: string;
    };
    "scalar.covenant.v1beta1.UpdateCustodianResponse": {
      /** Custodian represents an individual custodian configuration */
      custodian?: {
        name?: string;
        val_address?: string;
        /** Format: byte */
        bitcoin_pubkey?: string;
        /**
         * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
        description?: string;
      };
    };
    /**
     * @default KEY_STATE_UNSPECIFIED
     * @enum {string}
     */
    "scalar.multisig.exported.v1beta1.KeyState":
      | "KEY_STATE_UNSPECIFIED"
      | "KEY_STATE_ASSIGNED"
      | "KEY_STATE_ACTIVE";
    /**
     * @default MULTISIG_STATE_UNSPECIFIED
     * @enum {string}
     */
    "scalar.multisig.exported.v1beta1.MultisigState":
      | "MULTISIG_STATE_UNSPECIFIED"
      | "MULTISIG_STATE_PENDING"
      | "MULTISIG_STATE_COMPLETED";
    /** @description KeyIDResponse contains the key ID of the key assigned to a given chain. */
    "scalar.multisig.v1beta1.KeyIDResponse": {
      key_id?: string;
    };
    /** @description KeyResponse contains the key corresponding to a given key id. */
    "scalar.multisig.v1beta1.KeyResponse": {
      key_id?: string;
      /**
       * @default KEY_STATE_UNSPECIFIED
       * @enum {string}
       */
      state:
        | "KEY_STATE_UNSPECIFIED"
        | "KEY_STATE_ASSIGNED"
        | "KEY_STATE_ACTIVE";
      /** Format: int64 */
      started_at?: string;
      /** Format: date-time */
      started_at_timestamp?: string;
      /** Format: byte */
      threshold_weight?: string;
      /** Format: byte */
      bonded_weight?: string;
      /** Keygen participants in descending order by weight */
      participants?: {
        address?: string;
        /** Format: byte */
        weight?: string;
        pub_key?: string;
      }[];
    };
    "scalar.multisig.v1beta1.KeygenOptInRequest": {
      /** Format: byte */
      sender?: string;
    };
    "scalar.multisig.v1beta1.KeygenOptInResponse": Record<string, never>;
    "scalar.multisig.v1beta1.KeygenOptOutRequest": {
      /** Format: byte */
      sender?: string;
    };
    "scalar.multisig.v1beta1.KeygenOptOutResponse": Record<string, never>;
    "scalar.multisig.v1beta1.KeygenParticipant": {
      address?: string;
      /** Format: byte */
      weight?: string;
      pub_key?: string;
    };
    /** @description KeygenSessionResponse contains the keygen session info for a given key ID. */
    "scalar.multisig.v1beta1.KeygenSessionResponse": {
      /** Format: int64 */
      started_at?: string;
      /** Format: date-time */
      started_at_timestamp?: string;
      /** Format: int64 */
      expires_at?: string;
      /** Format: int64 */
      completed_at?: string;
      /** Format: int64 */
      grace_period?: string;
      /**
       * @default MULTISIG_STATE_UNSPECIFIED
       * @enum {string}
       */
      state:
        | "MULTISIG_STATE_UNSPECIFIED"
        | "MULTISIG_STATE_PENDING"
        | "MULTISIG_STATE_COMPLETED";
      /** Format: byte */
      keygen_threshold_weight?: string;
      /** Format: byte */
      signing_threshold_weight?: string;
      /** Format: byte */
      bonded_weight?: string;
      /** Keygen candidates in descending order by weight */
      participants?: {
        address?: string;
        /** Format: byte */
        weight?: string;
        pub_key?: string;
      }[];
    };
    /** NextKeyIDResponse contains the key ID for the next rotation on the given
     *     chain */
    "scalar.multisig.v1beta1.NextKeyIDResponse": {
      key_id?: string;
    };
    /** Params represent the genesis parameters for the module */
    "scalar.multisig.v1beta1.Params": {
      keygen_threshold?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      signing_threshold?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      /** Format: int64 */
      keygen_timeout?: string;
      /** Format: int64 */
      keygen_grace_period?: string;
      /** Format: int64 */
      signing_timeout?: string;
      /** Format: int64 */
      signing_grace_period?: string;
      /** Format: uint64 */
      active_epoch_count?: string;
    };
    "scalar.multisig.v1beta1.ParamsResponse": {
      /** Params represent the genesis parameters for the module */
      params?: {
        keygen_threshold?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        signing_threshold?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        /** Format: int64 */
        keygen_timeout?: string;
        /** Format: int64 */
        keygen_grace_period?: string;
        /** Format: int64 */
        signing_timeout?: string;
        /** Format: int64 */
        signing_grace_period?: string;
        /** Format: uint64 */
        active_epoch_count?: string;
      };
    };
    "scalar.multisig.v1beta1.RotateKeyRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      key_id?: string;
    };
    "scalar.multisig.v1beta1.RotateKeyResponse": Record<string, never>;
    "scalar.multisig.v1beta1.StartKeygenRequest": {
      sender?: string;
      key_id?: string;
    };
    "scalar.multisig.v1beta1.StartKeygenResponse": Record<string, never>;
    "scalar.multisig.v1beta1.SubmitPubKeyRequest": {
      sender?: string;
      key_id?: string;
      /** Format: byte */
      pub_key?: string;
      /** Format: byte */
      signature?: string;
    };
    "scalar.multisig.v1beta1.SubmitPubKeyResponse": Record<string, never>;
    "scalar.multisig.v1beta1.SubmitSignatureRequest": {
      sender?: string;
      /** Format: uint64 */
      sig_id?: string;
      /** Format: byte */
      signature?: string;
    };
    "scalar.multisig.v1beta1.SubmitSignatureResponse": Record<string, never>;
    /**
     * PageRequest is to be embedded in gRPC request messages for efficient
     *     pagination. Ex:
     * @description message SomeRequest {
     *              Foo some_parameter = 1;
     *              PageRequest pagination = 2;
     *      }
     */
    "cosmos.base.query.v1beta1.PageRequest": {
      /**
       * Format: byte
       * @description key is a value returned in PageResponse.next_key to begin
       *     querying the next page most efficiently. Only one of offset or key
       *     should be set.
       */
      key?: string;
      /**
       * Format: uint64
       * @description offset is a numeric offset that can be used when key is unavailable.
       *     It is less efficient than using key. Only one of offset or key should
       *     be set.
       */
      offset?: string;
      /**
       * Format: uint64
       * @description limit is the total number of results to be returned in the result page.
       *     If left empty it will default to a value to be set by each app.
       */
      limit?: string;
      /**
       * Format: boolean
       * @description count_total is set to true  to indicate that the result set should include
       *     a count of the total number of items available for pagination in UIs.
       *     count_total is only respected when offset is used. It is ignored when key
       *     is set.
       */
      count_total?: boolean;
      /**
       * Format: boolean
       * @description reverse is set to true if results are to be returned in the descending order.
       *
       *     Since: cosmos-sdk 0.43
       */
      reverse?: boolean;
    };
    /** @description PageResponse is to be embedded in gRPC response messages where the
     *     corresponding request message has used PageRequest.
     *
     *      message SomeResponse {
     *              repeated Bar results = 1;
     *              PageResponse page = 2;
     *      } */
    "cosmos.base.query.v1beta1.PageResponse": {
      /**
       * next_key is the key to be passed to PageRequest.key to
       *     query the next page most efficiently
       * Format: byte
       */
      next_key?: string;
      /**
       * total is total number of results available if PageRequest.count_total
       *     was set, its value is undefined otherwise
       * Format: uint64
       */
      total?: string;
    };
    /** CrossChainAddress represents a generalized address on any registered chain */
    "scalar.nexus.exported.v1beta1.CrossChainAddress": {
      /** Chain represents the properties of a registered blockchain */
      chain?: {
        /** The descriptor of the chain, e.g. "evm|11155111" */
        name?: string;
        /** Format: boolean */
        supports_foreign_assets?: boolean;
        /**
         * @default KEY_TYPE_UNSPECIFIED
         * @enum {string}
         */
        key_type:
          | "KEY_TYPE_UNSPECIFIED"
          | "KEY_TYPE_NONE"
          | "KEY_TYPE_THRESHOLD"
          | "KEY_TYPE_MULTISIG";
        /** the module has two types: chains and scalarnet */
        module?: string;
      };
      address?: string;
    };
    /** CrossChainTransfer represents a generalized transfer of some asset to a
     *     registered blockchain */
    "scalar.nexus.exported.v1beta1.CrossChainTransfer": {
      /** CrossChainAddress represents a generalized address on any registered chain */
      recipient?: {
        /** Chain represents the properties of a registered blockchain */
        chain?: {
          /** The descriptor of the chain, e.g. "evm|11155111" */
          name?: string;
          /** Format: boolean */
          supports_foreign_assets?: boolean;
          /**
           * @default KEY_TYPE_UNSPECIFIED
           * @enum {string}
           */
          key_type:
            | "KEY_TYPE_UNSPECIFIED"
            | "KEY_TYPE_NONE"
            | "KEY_TYPE_THRESHOLD"
            | "KEY_TYPE_MULTISIG";
          /** the module has two types: chains and scalarnet */
          module?: string;
        };
        address?: string;
      };
      /** @description Coin defines a token with a denomination and an amount.
       *
       *     NOTE: The amount field is an Int which implements the custom method
       *     signatures required by gogoproto. */
      asset?: {
        denom?: string;
        amount?: string;
      };
      /** Format: uint64 */
      id?: string;
      /**
       * @default TRANSFER_STATE_UNSPECIFIED
       * @enum {string}
       */
      state:
        | "TRANSFER_STATE_UNSPECIFIED"
        | "TRANSFER_STATE_PENDING"
        | "TRANSFER_STATE_ARCHIVED"
        | "TRANSFER_STATE_INSUFFICIENT_AMOUNT"
        | "TRANSFER_STATE_FAILED";
      /** Format: byte */
      source_tx_hash?: string;
    };
    "scalar.nexus.exported.v1beta1.FeeInfo": {
      chain?: string;
      asset?: string;
      /** Format: byte */
      fee_rate?: string;
      /** Format: byte */
      min_fee?: string;
      /** Format: byte */
      max_fee?: string;
    };
    "scalar.nexus.exported.v1beta1.GeneralMessage": {
      id?: string;
      /** CrossChainAddress represents a generalized address on any registered chain */
      sender?: {
        /** Chain represents the properties of a registered blockchain */
        chain?: {
          /** The descriptor of the chain, e.g. "evm|11155111" */
          name?: string;
          /** Format: boolean */
          supports_foreign_assets?: boolean;
          /**
           * @default KEY_TYPE_UNSPECIFIED
           * @enum {string}
           */
          key_type:
            | "KEY_TYPE_UNSPECIFIED"
            | "KEY_TYPE_NONE"
            | "KEY_TYPE_THRESHOLD"
            | "KEY_TYPE_MULTISIG";
          /** the module has two types: chains and scalarnet */
          module?: string;
        };
        address?: string;
      };
      /** CrossChainAddress represents a generalized address on any registered chain */
      recipient?: {
        /** Chain represents the properties of a registered blockchain */
        chain?: {
          /** The descriptor of the chain, e.g. "evm|11155111" */
          name?: string;
          /** Format: boolean */
          supports_foreign_assets?: boolean;
          /**
           * @default KEY_TYPE_UNSPECIFIED
           * @enum {string}
           */
          key_type:
            | "KEY_TYPE_UNSPECIFIED"
            | "KEY_TYPE_NONE"
            | "KEY_TYPE_THRESHOLD"
            | "KEY_TYPE_MULTISIG";
          /** the module has two types: chains and scalarnet */
          module?: string;
        };
        address?: string;
      };
      /** Format: byte */
      payload_hash?: string;
      /**
       * @default STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "STATUS_UNSPECIFIED"
        | "STATUS_APPROVED"
        | "STATUS_PROCESSING"
        | "STATUS_EXECUTED"
        | "STATUS_FAILED";
      /** @description Coin defines a token with a denomination and an amount.
       *
       *     NOTE: The amount field is an Int which implements the custom method
       *     signatures required by gogoproto. */
      asset?: {
        denom?: string;
        amount?: string;
      };
      /** Format: byte */
      source_tx_id?: string;
      /** Format: uint64 */
      source_tx_index?: string;
      /**
       * Additional data for the message, metadata is encoded in the payload, it can
       *     be fee information, etc. It will be used later when enqueuing the command
       *     and batch command. Currently, the main purpose is use to form the psbt for
       *     btc
       * Format: byte
       */
      payload?: string;
    };
    /**
     * @default STATUS_UNSPECIFIED
     * @enum {string}
     */
    "scalar.nexus.exported.v1beta1.GeneralMessage.Status":
      | "STATUS_UNSPECIFIED"
      | "STATUS_APPROVED"
      | "STATUS_PROCESSING"
      | "STATUS_EXECUTED"
      | "STATUS_FAILED";
    /**
     * @default TRANSFER_STATE_UNSPECIFIED
     * @enum {string}
     */
    "scalar.nexus.exported.v1beta1.TransferState":
      | "TRANSFER_STATE_UNSPECIFIED"
      | "TRANSFER_STATE_PENDING"
      | "TRANSFER_STATE_ARCHIVED"
      | "TRANSFER_STATE_INSUFFICIENT_AMOUNT"
      | "TRANSFER_STATE_FAILED";
    /** ActivateChainRequest represents a message to activate chains */
    "scalar.nexus.v1beta1.ActivateChainRequest": {
      /** Format: byte */
      sender?: string;
      chains?: string[];
    };
    "scalar.nexus.v1beta1.ActivateChainResponse": Record<string, never>;
    "scalar.nexus.v1beta1.AssetsResponse": {
      assets?: string[];
    };
    "scalar.nexus.v1beta1.ChainMaintainersResponse": {
      maintainers?: string[];
    };
    /** ChainState represents the state of a registered blockchain */
    "scalar.nexus.v1beta1.ChainState": {
      /** Chain represents the properties of a registered blockchain */
      chain?: {
        /** The descriptor of the chain, e.g. "evm|11155111" */
        name?: string;
        /** Format: boolean */
        supports_foreign_assets?: boolean;
        /**
         * @default KEY_TYPE_UNSPECIFIED
         * @enum {string}
         */
        key_type:
          | "KEY_TYPE_UNSPECIFIED"
          | "KEY_TYPE_NONE"
          | "KEY_TYPE_THRESHOLD"
          | "KEY_TYPE_MULTISIG";
        /** the module has two types: chains and scalarnet */
        module?: string;
      };
      /** Format: boolean */
      activated?: boolean;
      assets?: {
        denom?: string;
        /** Format: boolean */
        is_native_asset?: boolean;
      }[];
      maintainer_states?: {
        /** Format: byte */
        address?: string;
        missing_votes?: {
          true_count_cache?: {
            cumulative_value?: string[];
            /** Format: int32 */
            index?: number;
            /** Format: int32 */
            max_size?: number;
          };
        };
        incorrect_votes?: {
          true_count_cache?: {
            cumulative_value?: string[];
            /** Format: int32 */
            index?: number;
            /** Format: int32 */
            max_size?: number;
          };
        };
        chain?: string;
      }[];
    };
    "scalar.nexus.v1beta1.ChainStateResponse": {
      /** ChainState represents the state of a registered blockchain */
      state?: {
        /** Chain represents the properties of a registered blockchain */
        chain?: {
          /** The descriptor of the chain, e.g. "evm|11155111" */
          name?: string;
          /** Format: boolean */
          supports_foreign_assets?: boolean;
          /**
           * @default KEY_TYPE_UNSPECIFIED
           * @enum {string}
           */
          key_type:
            | "KEY_TYPE_UNSPECIFIED"
            | "KEY_TYPE_NONE"
            | "KEY_TYPE_THRESHOLD"
            | "KEY_TYPE_MULTISIG";
          /** the module has two types: chains and scalarnet */
          module?: string;
        };
        /** Format: boolean */
        activated?: boolean;
        assets?: {
          denom?: string;
          /** Format: boolean */
          is_native_asset?: boolean;
        }[];
        maintainer_states?: {
          /** Format: byte */
          address?: string;
          missing_votes?: {
            true_count_cache?: {
              cumulative_value?: string[];
              /** Format: int32 */
              index?: number;
              /** Format: int32 */
              max_size?: number;
            };
          };
          incorrect_votes?: {
            true_count_cache?: {
              cumulative_value?: string[];
              /** Format: int32 */
              index?: number;
              /** Format: int32 */
              max_size?: number;
            };
          };
          chain?: string;
        }[];
      };
    };
    /**
     * @default CHAIN_STATUS_UNSPECIFIED
     * @enum {string}
     */
    "scalar.nexus.v1beta1.ChainStatus":
      | "CHAIN_STATUS_UNSPECIFIED"
      | "CHAIN_STATUS_ACTIVATED"
      | "CHAIN_STATUS_DEACTIVATED";
    "scalar.nexus.v1beta1.ChainsByAssetResponse": {
      chains?: string[];
    };
    "scalar.nexus.v1beta1.ChainsResponse": {
      chains?: string[];
    };
    /** DeactivateChainRequest represents a message to deactivate chains */
    "scalar.nexus.v1beta1.DeactivateChainRequest": {
      /** Format: byte */
      sender?: string;
      chains?: string[];
    };
    "scalar.nexus.v1beta1.DeactivateChainResponse": Record<string, never>;
    "scalar.nexus.v1beta1.DeregisterChainMaintainerRequest": {
      /** Format: byte */
      sender?: string;
      chains?: string[];
    };
    "scalar.nexus.v1beta1.DeregisterChainMaintainerResponse": Record<
      string,
      never
    >;
    "scalar.nexus.v1beta1.FeeInfoResponse": {
      fee_info?: {
        chain?: string;
        asset?: string;
        /** Format: byte */
        fee_rate?: string;
        /** Format: byte */
        min_fee?: string;
        /** Format: byte */
        max_fee?: string;
      };
    };
    "scalar.nexus.v1beta1.LatestDepositAddressResponse": {
      deposit_addr?: string;
    };
    "scalar.nexus.v1beta1.MaintainerState": {
      /** Format: byte */
      address?: string;
      missing_votes?: {
        true_count_cache?: {
          cumulative_value?: string[];
          /** Format: int32 */
          index?: number;
          /** Format: int32 */
          max_size?: number;
        };
      };
      incorrect_votes?: {
        true_count_cache?: {
          cumulative_value?: string[];
          /** Format: int32 */
          index?: number;
          /** Format: int32 */
          max_size?: number;
        };
      };
      chain?: string;
    };
    "scalar.nexus.v1beta1.MessageResponse": {
      message?: {
        id?: string;
        /** CrossChainAddress represents a generalized address on any registered chain */
        sender?: {
          /** Chain represents the properties of a registered blockchain */
          chain?: {
            /** The descriptor of the chain, e.g. "evm|11155111" */
            name?: string;
            /** Format: boolean */
            supports_foreign_assets?: boolean;
            /**
             * @default KEY_TYPE_UNSPECIFIED
             * @enum {string}
             */
            key_type:
              | "KEY_TYPE_UNSPECIFIED"
              | "KEY_TYPE_NONE"
              | "KEY_TYPE_THRESHOLD"
              | "KEY_TYPE_MULTISIG";
            /** the module has two types: chains and scalarnet */
            module?: string;
          };
          address?: string;
        };
        /** CrossChainAddress represents a generalized address on any registered chain */
        recipient?: {
          /** Chain represents the properties of a registered blockchain */
          chain?: {
            /** The descriptor of the chain, e.g. "evm|11155111" */
            name?: string;
            /** Format: boolean */
            supports_foreign_assets?: boolean;
            /**
             * @default KEY_TYPE_UNSPECIFIED
             * @enum {string}
             */
            key_type:
              | "KEY_TYPE_UNSPECIFIED"
              | "KEY_TYPE_NONE"
              | "KEY_TYPE_THRESHOLD"
              | "KEY_TYPE_MULTISIG";
            /** the module has two types: chains and scalarnet */
            module?: string;
          };
          address?: string;
        };
        /** Format: byte */
        payload_hash?: string;
        /**
         * @default STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "STATUS_UNSPECIFIED"
          | "STATUS_APPROVED"
          | "STATUS_PROCESSING"
          | "STATUS_EXECUTED"
          | "STATUS_FAILED";
        /** @description Coin defines a token with a denomination and an amount.
         *
         *     NOTE: The amount field is an Int which implements the custom method
         *     signatures required by gogoproto. */
        asset?: {
          denom?: string;
          amount?: string;
        };
        /** Format: byte */
        source_tx_id?: string;
        /** Format: uint64 */
        source_tx_index?: string;
        /**
         * Additional data for the message, metadata is encoded in the payload, it can
         *     be fee information, etc. It will be used later when enqueuing the command
         *     and batch command. Currently, the main purpose is use to form the psbt for
         *     btc
         * Format: byte
         */
        payload?: string;
      };
    };
    /** Params represent the genesis parameters for the module */
    "scalar.nexus.v1beta1.Params": {
      chain_activation_threshold?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      chain_maintainer_missing_vote_threshold?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      chain_maintainer_incorrect_vote_threshold?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      /** Format: int32 */
      chain_maintainer_check_window?: number;
      /** Format: byte */
      gateway?: string;
      /** Format: uint64 */
      end_blocker_limit?: string;
    };
    "scalar.nexus.v1beta1.ParamsResponse": {
      /** Params represent the genesis parameters for the module */
      params?: {
        chain_activation_threshold?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        chain_maintainer_missing_vote_threshold?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        chain_maintainer_incorrect_vote_threshold?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        /** Format: int32 */
        chain_maintainer_check_window?: number;
        /** Format: byte */
        gateway?: string;
        /** Format: uint64 */
        end_blocker_limit?: string;
      };
    };
    "scalar.nexus.v1beta1.RecipientAddressResponse": {
      recipient_addr?: string;
      recipient_chain?: string;
    };
    /** RegisterAssetFeeRequest represents a message to register the transfer fee
     *     info associated to an asset on a chain */
    "scalar.nexus.v1beta1.RegisterAssetFeeRequest": {
      /** Format: byte */
      sender?: string;
      fee_info?: {
        chain?: string;
        asset?: string;
        /** Format: byte */
        fee_rate?: string;
        /** Format: byte */
        min_fee?: string;
        /** Format: byte */
        max_fee?: string;
      };
    };
    "scalar.nexus.v1beta1.RegisterAssetFeeResponse": Record<string, never>;
    "scalar.nexus.v1beta1.RegisterChainMaintainerRequest": {
      /** Format: byte */
      sender?: string;
      chains?: string[];
    };
    "scalar.nexus.v1beta1.RegisterChainMaintainerResponse": Record<
      string,
      never
    >;
    /** SetTransferRateLimitRequest represents a message to set rate limits on
     *     transfers */
    "scalar.nexus.v1beta1.SetTransferRateLimitRequest": {
      /** Format: byte */
      sender?: string;
      chain?: string;
      /** @description Coin defines a token with a denomination and an amount.
       *
       *     NOTE: The amount field is an Int which implements the custom method
       *     signatures required by gogoproto. */
      limit?: {
        denom?: string;
        amount?: string;
      };
      window?: string;
    };
    "scalar.nexus.v1beta1.SetTransferRateLimitResponse": Record<string, never>;
    "scalar.nexus.v1beta1.TransferFeeResponse": {
      /** @description Coin defines a token with a denomination and an amount.
       *
       *     NOTE: The amount field is an Int which implements the custom method
       *     signatures required by gogoproto. */
      fee?: {
        denom?: string;
        amount?: string;
      };
    };
    "scalar.nexus.v1beta1.TransferRateLimit": {
      /** Format: byte */
      limit?: string;
      window?: string;
      /** Format: byte */
      incoming?: string;
      /** Format: byte */
      outgoing?: string;
      /** time_left indicates the time left in the rate limit window */
      time_left?: string;
      /** Format: byte */
      from?: string;
      /** Format: byte */
      to?: string;
    };
    "scalar.nexus.v1beta1.TransferRateLimitResponse": {
      transfer_rate_limit?: {
        /** Format: byte */
        limit?: string;
        window?: string;
        /** Format: byte */
        incoming?: string;
        /** Format: byte */
        outgoing?: string;
        /** time_left indicates the time left in the rate limit window */
        time_left?: string;
        /** Format: byte */
        from?: string;
        /** Format: byte */
        to?: string;
      };
    };
    "scalar.nexus.v1beta1.TransfersForChainResponse": {
      transfers?: {
        /** CrossChainAddress represents a generalized address on any registered chain */
        recipient?: {
          /** Chain represents the properties of a registered blockchain */
          chain?: {
            /** The descriptor of the chain, e.g. "evm|11155111" */
            name?: string;
            /** Format: boolean */
            supports_foreign_assets?: boolean;
            /**
             * @default KEY_TYPE_UNSPECIFIED
             * @enum {string}
             */
            key_type:
              | "KEY_TYPE_UNSPECIFIED"
              | "KEY_TYPE_NONE"
              | "KEY_TYPE_THRESHOLD"
              | "KEY_TYPE_MULTISIG";
            /** the module has two types: chains and scalarnet */
            module?: string;
          };
          address?: string;
        };
        /** @description Coin defines a token with a denomination and an amount.
         *
         *     NOTE: The amount field is an Int which implements the custom method
         *     signatures required by gogoproto. */
        asset?: {
          denom?: string;
          amount?: string;
        };
        /** Format: uint64 */
        id?: string;
        /**
         * @default TRANSFER_STATE_UNSPECIFIED
         * @enum {string}
         */
        state:
          | "TRANSFER_STATE_UNSPECIFIED"
          | "TRANSFER_STATE_PENDING"
          | "TRANSFER_STATE_ARCHIVED"
          | "TRANSFER_STATE_INSUFFICIENT_AMOUNT"
          | "TRANSFER_STATE_FAILED";
        /** Format: byte */
        source_tx_hash?: string;
      }[];
      /** @description PageResponse is to be embedded in gRPC response messages where the
       *     corresponding request message has used PageRequest.
       *
       *      message SomeResponse {
       *              repeated Bar results = 1;
       *              PageResponse page = 2;
       *      } */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    "scalar.utils.v1beta1.Bitmap": {
      true_count_cache?: {
        cumulative_value?: string[];
        /** Format: int32 */
        index?: number;
        /** Format: int32 */
        max_size?: number;
      };
    };
    "scalar.utils.v1beta1.CircularBuffer": {
      cumulative_value?: string[];
      /** Format: int32 */
      index?: number;
      /** Format: int32 */
      max_size?: number;
    };
    "scalar.reward.v1beta1.InflationRateResponse": {
      /** Format: byte */
      inflation_rate?: string;
    };
    /** Params represent the genesis parameters for the module */
    "scalar.reward.v1beta1.Params": {
      /** Format: byte */
      external_chain_voting_inflation_rate?: string;
      /** Format: byte */
      key_mgmt_relative_inflation_rate?: string;
    };
    "scalar.reward.v1beta1.ParamsResponse": {
      /** Params represent the genesis parameters for the module */
      params?: {
        /** Format: byte */
        external_chain_voting_inflation_rate?: string;
        /** Format: byte */
        key_mgmt_relative_inflation_rate?: string;
      };
    };
    "scalar.reward.v1beta1.RefundMsgRequest": {
      /** Format: byte */
      sender?: string;
      /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         } */
      inner_message?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    "scalar.reward.v1beta1.RefundMsgResponse": {
      /** Format: byte */
      data?: string;
      log?: string;
    };
    "scalar.snapshot.v1beta1.DeactivateProxyRequest": {
      /** Format: byte */
      sender?: string;
    };
    "scalar.snapshot.v1beta1.DeactivateProxyResponse": Record<string, never>;
    /** Params represent the genesis parameters for the module */
    "scalar.snapshot.v1beta1.Params": {
      /** Format: int64 */
      min_proxy_balance?: string;
    };
    "scalar.snapshot.v1beta1.ParamsResponse": {
      /** Params represent the genesis parameters for the module */
      params?: {
        /** Format: int64 */
        min_proxy_balance?: string;
      };
    };
    "scalar.snapshot.v1beta1.RegisterProxyRequest": {
      /** Format: byte */
      sender?: string;
      /** Format: byte */
      proxy_addr?: string;
    };
    "scalar.snapshot.v1beta1.RegisterProxyResponse": Record<string, never>;
    /** KeyRequirement defines requirements for keys */
    "scalar.tss.exported.v1beta1.KeyRequirement": {
      /**
       * @default KEY_ROLE_UNSPECIFIED
       * @enum {string}
       */
      key_role:
        | "KEY_ROLE_UNSPECIFIED"
        | "KEY_ROLE_MASTER_KEY"
        | "KEY_ROLE_SECONDARY_KEY"
        | "KEY_ROLE_EXTERNAL_KEY";
      /**
       * @default KEY_TYPE_UNSPECIFIED
       * @enum {string}
       */
      key_type:
        | "KEY_TYPE_UNSPECIFIED"
        | "KEY_TYPE_NONE"
        | "KEY_TYPE_THRESHOLD"
        | "KEY_TYPE_MULTISIG";
      min_keygen_threshold?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      safety_threshold?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      /**
       * @default KEY_SHARE_DISTRIBUTION_POLICY_UNSPECIFIED
       * @enum {string}
       */
      key_share_distribution_policy:
        | "KEY_SHARE_DISTRIBUTION_POLICY_UNSPECIFIED"
        | "KEY_SHARE_DISTRIBUTION_POLICY_WEIGHTED_BY_STAKE"
        | "KEY_SHARE_DISTRIBUTION_POLICY_ONE_PER_VALIDATOR";
      /** Format: int64 */
      max_total_share_count?: string;
      /** Format: int64 */
      min_total_share_count?: string;
      keygen_voting_threshold?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      sign_voting_threshold?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      /** Format: int64 */
      keygen_timeout?: string;
      /** Format: int64 */
      sign_timeout?: string;
    };
    /**
     * @default KEY_ROLE_UNSPECIFIED
     * @enum {string}
     */
    "scalar.tss.exported.v1beta1.KeyRole":
      | "KEY_ROLE_UNSPECIFIED"
      | "KEY_ROLE_MASTER_KEY"
      | "KEY_ROLE_SECONDARY_KEY"
      | "KEY_ROLE_EXTERNAL_KEY";
    /**
     * @default KEY_SHARE_DISTRIBUTION_POLICY_UNSPECIFIED
     * @enum {string}
     */
    "scalar.tss.exported.v1beta1.KeyShareDistributionPolicy":
      | "KEY_SHARE_DISTRIBUTION_POLICY_UNSPECIFIED"
      | "KEY_SHARE_DISTRIBUTION_POLICY_WEIGHTED_BY_STAKE"
      | "KEY_SHARE_DISTRIBUTION_POLICY_ONE_PER_VALIDATOR";
    "scalar.tss.v1beta1.HeartBeatRequest": {
      /** Format: byte */
      sender?: string;
      /** Deprecated: this field will be removed in the next release */
      key_ids?: string[];
    };
    "scalar.tss.v1beta1.HeartBeatResponse": Record<string, never>;
    /** Params is the parameter set for this module */
    "scalar.tss.v1beta1.Params": {
      /** KeyRequirements defines the requirement for each key role */
      key_requirements?: {
        /**
         * @default KEY_ROLE_UNSPECIFIED
         * @enum {string}
         */
        key_role:
          | "KEY_ROLE_UNSPECIFIED"
          | "KEY_ROLE_MASTER_KEY"
          | "KEY_ROLE_SECONDARY_KEY"
          | "KEY_ROLE_EXTERNAL_KEY";
        /**
         * @default KEY_TYPE_UNSPECIFIED
         * @enum {string}
         */
        key_type:
          | "KEY_TYPE_UNSPECIFIED"
          | "KEY_TYPE_NONE"
          | "KEY_TYPE_THRESHOLD"
          | "KEY_TYPE_MULTISIG";
        min_keygen_threshold?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        safety_threshold?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        /**
         * @default KEY_SHARE_DISTRIBUTION_POLICY_UNSPECIFIED
         * @enum {string}
         */
        key_share_distribution_policy:
          | "KEY_SHARE_DISTRIBUTION_POLICY_UNSPECIFIED"
          | "KEY_SHARE_DISTRIBUTION_POLICY_WEIGHTED_BY_STAKE"
          | "KEY_SHARE_DISTRIBUTION_POLICY_ONE_PER_VALIDATOR";
        /** Format: int64 */
        max_total_share_count?: string;
        /** Format: int64 */
        min_total_share_count?: string;
        keygen_voting_threshold?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        sign_voting_threshold?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        /** Format: int64 */
        keygen_timeout?: string;
        /** Format: int64 */
        sign_timeout?: string;
      }[];
      /**
       * SuspendDurationInBlocks defines the number of blocks a
       *     validator is disallowed to participate in any TSS ceremony after
       *     committing a malicious behaviour during signing
       * Format: int64
       */
      suspend_duration_in_blocks?: string;
      /**
       * HeartBeatPeriodInBlocks defines the time period in blocks for tss to
       *     emit the event asking validators to send their heartbeats
       * Format: int64
       */
      heartbeat_period_in_blocks?: string;
      max_missed_blocks_per_window?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      /** Format: int64 */
      unbonding_locking_key_rotation_count?: string;
      external_multisig_threshold?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      /** Format: int64 */
      max_sign_queue_size?: string;
      /** Format: int64 */
      max_simultaneous_sign_shares?: string;
      /** Format: int64 */
      tss_signed_blocks_window?: string;
    };
    "scalar.tss.v1beta1.ParamsResponse": {
      /** Params is the parameter set for this module */
      params?: {
        /** KeyRequirements defines the requirement for each key role */
        key_requirements?: {
          /**
           * @default KEY_ROLE_UNSPECIFIED
           * @enum {string}
           */
          key_role:
            | "KEY_ROLE_UNSPECIFIED"
            | "KEY_ROLE_MASTER_KEY"
            | "KEY_ROLE_SECONDARY_KEY"
            | "KEY_ROLE_EXTERNAL_KEY";
          /**
           * @default KEY_TYPE_UNSPECIFIED
           * @enum {string}
           */
          key_type:
            | "KEY_TYPE_UNSPECIFIED"
            | "KEY_TYPE_NONE"
            | "KEY_TYPE_THRESHOLD"
            | "KEY_TYPE_MULTISIG";
          min_keygen_threshold?: {
            /**
             * split threshold into Numerator and denominator to avoid floating point
             *     errors down the line
             * Format: int64
             */
            numerator?: string;
            /** Format: int64 */
            denominator?: string;
          };
          safety_threshold?: {
            /**
             * split threshold into Numerator and denominator to avoid floating point
             *     errors down the line
             * Format: int64
             */
            numerator?: string;
            /** Format: int64 */
            denominator?: string;
          };
          /**
           * @default KEY_SHARE_DISTRIBUTION_POLICY_UNSPECIFIED
           * @enum {string}
           */
          key_share_distribution_policy:
            | "KEY_SHARE_DISTRIBUTION_POLICY_UNSPECIFIED"
            | "KEY_SHARE_DISTRIBUTION_POLICY_WEIGHTED_BY_STAKE"
            | "KEY_SHARE_DISTRIBUTION_POLICY_ONE_PER_VALIDATOR";
          /** Format: int64 */
          max_total_share_count?: string;
          /** Format: int64 */
          min_total_share_count?: string;
          keygen_voting_threshold?: {
            /**
             * split threshold into Numerator and denominator to avoid floating point
             *     errors down the line
             * Format: int64
             */
            numerator?: string;
            /** Format: int64 */
            denominator?: string;
          };
          sign_voting_threshold?: {
            /**
             * split threshold into Numerator and denominator to avoid floating point
             *     errors down the line
             * Format: int64
             */
            numerator?: string;
            /** Format: int64 */
            denominator?: string;
          };
          /** Format: int64 */
          keygen_timeout?: string;
          /** Format: int64 */
          sign_timeout?: string;
        }[];
        /**
         * SuspendDurationInBlocks defines the number of blocks a
         *     validator is disallowed to participate in any TSS ceremony after
         *     committing a malicious behaviour during signing
         * Format: int64
         */
        suspend_duration_in_blocks?: string;
        /**
         * HeartBeatPeriodInBlocks defines the time period in blocks for tss to
         *     emit the event asking validators to send their heartbeats
         * Format: int64
         */
        heartbeat_period_in_blocks?: string;
        max_missed_blocks_per_window?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        /** Format: int64 */
        unbonding_locking_key_rotation_count?: string;
        external_multisig_threshold?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        /** Format: int64 */
        max_sign_queue_size?: string;
        /** Format: int64 */
        max_simultaneous_sign_shares?: string;
        /** Format: int64 */
        tss_signed_blocks_window?: string;
      };
    };
    /** @description LegacyAminoPubKey specifies a public key type
     *     which nests multiple public keys and a threshold,
     *     it uses legacy amino address rules. */
    "cosmos.crypto.multisig.LegacyAminoPubKey": {
      /** Format: int64 */
      threshold?: number;
      public_keys?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
    };
    /** DeregisterController represents a message to deregister a controller account */
    "scalar.permission.v1beta1.DeregisterControllerRequest": {
      /** Format: byte */
      sender?: string;
      /** Format: byte */
      controller?: string;
    };
    "scalar.permission.v1beta1.DeregisterControllerResponse": Record<
      string,
      never
    >;
    /** Params represent the genesis parameters for the module */
    "scalar.permission.v1beta1.Params": Record<string, never>;
    "scalar.permission.v1beta1.ParamsResponse": {
      /** Params represent the genesis parameters for the module */
      params?: Record<string, never>;
    };
    /** QueryGovernanceKeyResponse is the response type for the
     *     Query/GovernanceKey RPC method */
    "scalar.permission.v1beta1.QueryGovernanceKeyResponse": {
      /** @description LegacyAminoPubKey specifies a public key type
       *     which nests multiple public keys and a threshold,
       *     it uses legacy amino address rules. */
      governance_key?: {
        /** Format: int64 */
        threshold?: number;
        public_keys?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        }[];
      };
    };
    /** MsgRegisterController represents a message to register a controller account */
    "scalar.permission.v1beta1.RegisterControllerRequest": {
      /** Format: byte */
      sender?: string;
      /** Format: byte */
      controller?: string;
    };
    "scalar.permission.v1beta1.RegisterControllerResponse": Record<
      string,
      never
    >;
    "scalar.permission.v1beta1.UpdateGovernanceKeyRequest": {
      /** Format: byte */
      sender?: string;
      /** @description LegacyAminoPubKey specifies a public key type
       *     which nests multiple public keys and a threshold,
       *     it uses legacy amino address rules. */
      governance_key?: {
        /** Format: int64 */
        threshold?: number;
        public_keys?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        }[];
      };
    };
    "scalar.permission.v1beta1.UpdateGovernanceKeyResponse": Record<
      string,
      never
    >;
    /** Params represent the genesis parameters for the module */
    "scalar.vote.v1beta1.Params": {
      default_voting_threshold?: {
        /**
         * split threshold into Numerator and denominator to avoid floating point
         *     errors down the line
         * Format: int64
         */
        numerator?: string;
        /** Format: int64 */
        denominator?: string;
      };
      /** Format: int64 */
      end_blocker_limit?: string;
    };
    "scalar.vote.v1beta1.ParamsResponse": {
      /** Params represent the genesis parameters for the module */
      params?: {
        default_voting_threshold?: {
          /**
           * split threshold into Numerator and denominator to avoid floating point
           *     errors down the line
           * Format: int64
           */
          numerator?: string;
          /** Format: int64 */
          denominator?: string;
        };
        /** Format: int64 */
        end_blocker_limit?: string;
      };
    };
    "scalar.vote.v1beta1.VoteRequest": {
      /** Format: byte */
      sender?: string;
      /** Format: uint64 */
      poll_id?: string;
      /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         } */
      vote?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    "scalar.vote.v1beta1.VoteResponse": {
      log?: string;
    };
    /** @description Params defines the parameters for the auth module. */
    "cosmos.auth.v1beta1.Params": {
      /** Format: uint64 */
      max_memo_characters?: string;
      /** Format: uint64 */
      tx_sig_limit?: string;
      /** Format: uint64 */
      tx_size_cost_per_byte?: string;
      /** Format: uint64 */
      sig_verify_cost_ed25519?: string;
      /** Format: uint64 */
      sig_verify_cost_secp256k1?: string;
    };
    /** @description QueryAccountResponse is the response type for the Query/Account RPC method. */
    "cosmos.auth.v1beta1.QueryAccountResponse": {
      /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         } */
      account?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /** @description QueryAccountsResponse is the response type for the Query/Accounts RPC method.
     *
     *     Since: cosmos-sdk 0.43 */
    "cosmos.auth.v1beta1.QueryAccountsResponse": {
      /** accounts are the existing accounts */
      accounts?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method. */
    "cosmos.auth.v1beta1.QueryModuleAccountByNameResponse": {
      /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         } */
      account?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "cosmos.auth.v1beta1.QueryParamsResponse": {
      /** @description params defines the parameters of the module. */
      params?: {
        /** Format: uint64 */
        max_memo_characters?: string;
        /** Format: uint64 */
        tx_sig_limit?: string;
        /** Format: uint64 */
        tx_size_cost_per_byte?: string;
        /** Format: uint64 */
        sig_verify_cost_ed25519?: string;
        /** Format: uint64 */
        sig_verify_cost_secp256k1?: string;
      };
    };
    /** @description DenomUnit represents a struct that describes a given
     *     denomination unit of the basic token. */
    "cosmos.bank.v1beta1.DenomUnit": {
      /** @description denom represents the string name of the given denom unit (e.g uatom). */
      denom?: string;
      /**
       * Format: int64
       * @description exponent represents power of 10 exponent that one must
       *     raise the base_denom to in order to equal the given DenomUnit's denom
       *     1 denom = 1^exponent base_denom
       *     (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
       *     exponent = 6, thus: 1 atom = 10^6 uatom).
       */
      exponent?: number;
      /** aliases is a list of string aliases for the given denom */
      aliases?: string[];
    };
    /** @description Metadata represents a struct that describes
     *     a basic token. */
    "cosmos.bank.v1beta1.Metadata": {
      description?: string;
      /** denom_units represents the list of DenomUnit's for a given coin */
      denom_units?: {
        /** @description denom represents the string name of the given denom unit (e.g uatom). */
        denom?: string;
        /**
         * Format: int64
         * @description exponent represents power of 10 exponent that one must
         *     raise the base_denom to in order to equal the given DenomUnit's denom
         *     1 denom = 1^exponent base_denom
         *     (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
         *     exponent = 6, thus: 1 atom = 10^6 uatom).
         */
        exponent?: number;
        /** aliases is a list of string aliases for the given denom */
        aliases?: string[];
      }[];
      /** @description base represents the base denom (should be the DenomUnit with exponent = 0). */
      base?: string;
      /** @description display indicates the suggested denom that should be
       *     displayed in clients. */
      display?: string;
      /**
       * name defines the name of the token (eg: Cosmos Atom)
       * @description Since: cosmos-sdk 0.43
       */
      name?: string;
      /** @description symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
       *     be the same as the display.
       *
       *     Since: cosmos-sdk 0.43 */
      symbol?: string;
    };
    /** @description Params defines the parameters for the bank module. */
    "cosmos.bank.v1beta1.Params": {
      send_enabled?: {
        denom?: string;
        /** Format: boolean */
        enabled?: boolean;
      }[];
      /** Format: boolean */
      default_send_enabled?: boolean;
    };
    /** @description QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
     *     method. */
    "cosmos.bank.v1beta1.QueryAllBalancesResponse": {
      /** @description balances is the balances of all the coins. */
      balances?: {
        denom?: string;
        amount?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryBalanceResponse is the response type for the Query/Balance RPC method. */
    "cosmos.bank.v1beta1.QueryBalanceResponse": {
      /** @description Coin defines a token with a denomination and an amount.
       *
       *     NOTE: The amount field is an Int which implements the custom method
       *     signatures required by gogoproto. */
      balance?: {
        denom?: string;
        amount?: string;
      };
    };
    /** @description QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC
     *     method. */
    "cosmos.bank.v1beta1.QueryDenomMetadataResponse": {
      /** @description Metadata represents a struct that describes
       *     a basic token. */
      metadata?: {
        description?: string;
        /** denom_units represents the list of DenomUnit's for a given coin */
        denom_units?: {
          /** @description denom represents the string name of the given denom unit (e.g uatom). */
          denom?: string;
          /**
           * Format: int64
           * @description exponent represents power of 10 exponent that one must
           *     raise the base_denom to in order to equal the given DenomUnit's denom
           *     1 denom = 1^exponent base_denom
           *     (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
           *     exponent = 6, thus: 1 atom = 10^6 uatom).
           */
          exponent?: number;
          /** aliases is a list of string aliases for the given denom */
          aliases?: string[];
        }[];
        /** @description base represents the base denom (should be the DenomUnit with exponent = 0). */
        base?: string;
        /** @description display indicates the suggested denom that should be
         *     displayed in clients. */
        display?: string;
        /**
         * name defines the name of the token (eg: Cosmos Atom)
         * @description Since: cosmos-sdk 0.43
         */
        name?: string;
        /** @description symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
         *     be the same as the display.
         *
         *     Since: cosmos-sdk 0.43 */
        symbol?: string;
      };
    };
    /** @description QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
     *     method. */
    "cosmos.bank.v1beta1.QueryDenomsMetadataResponse": {
      /** @description metadata provides the client information for all the registered tokens. */
      metadatas?: {
        description?: string;
        /** denom_units represents the list of DenomUnit's for a given coin */
        denom_units?: {
          /** @description denom represents the string name of the given denom unit (e.g uatom). */
          denom?: string;
          /**
           * Format: int64
           * @description exponent represents power of 10 exponent that one must
           *     raise the base_denom to in order to equal the given DenomUnit's denom
           *     1 denom = 1^exponent base_denom
           *     (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
           *     exponent = 6, thus: 1 atom = 10^6 uatom).
           */
          exponent?: number;
          /** aliases is a list of string aliases for the given denom */
          aliases?: string[];
        }[];
        /** @description base represents the base denom (should be the DenomUnit with exponent = 0). */
        base?: string;
        /** @description display indicates the suggested denom that should be
         *     displayed in clients. */
        display?: string;
        /**
         * name defines the name of the token (eg: Cosmos Atom)
         * @description Since: cosmos-sdk 0.43
         */
        name?: string;
        /** @description symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
         *     be the same as the display.
         *
         *     Since: cosmos-sdk 0.43 */
        symbol?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryParamsResponse defines the response type for querying x/bank parameters. */
    "cosmos.bank.v1beta1.QueryParamsResponse": {
      /** @description Params defines the parameters for the bank module. */
      params?: {
        send_enabled?: {
          denom?: string;
          /** Format: boolean */
          enabled?: boolean;
        }[];
        /** Format: boolean */
        default_send_enabled?: boolean;
      };
    };
    /** @description QuerySpendableBalancesResponse defines the gRPC response structure for querying
     *     an account's spendable balances. */
    "cosmos.bank.v1beta1.QuerySpendableBalancesResponse": {
      /** @description balances is the spendable balances of all the coins. */
      balances?: {
        denom?: string;
        amount?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method. */
    "cosmos.bank.v1beta1.QuerySupplyOfResponse": {
      /** @description Coin defines a token with a denomination and an amount.
       *
       *     NOTE: The amount field is an Int which implements the custom method
       *     signatures required by gogoproto. */
      amount?: {
        denom?: string;
        amount?: string;
      };
    };
    /** QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
     *     method */
    "cosmos.bank.v1beta1.QueryTotalSupplyResponse": {
      /** supply is the supply of the coins */
      supply?: {
        denom?: string;
        amount?: string;
      }[];
      /** @description pagination defines the pagination in the response.
       *
       *     Since: cosmos-sdk 0.43 */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description SendEnabled maps coin denom to a send_enabled status (whether a denom is
     *     sendable). */
    "cosmos.bank.v1beta1.SendEnabled": {
      denom?: string;
      /** Format: boolean */
      enabled?: boolean;
    };
    /** @description GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method. */
    "cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse": {
      /** BlockID */
      block_id?: {
        /** Format: byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** Format: int64 */
          total?: number;
          /** Format: byte */
          hash?: string;
        };
      };
      block?: {
        /** @description Header defines the structure of a block header. */
        header?: {
          /**
           * basic block info
           * @description Consensus captures the consensus rules for processing a block in the blockchain,
           *     including all blockchain data structures and the rules of the application's
           *     state transition machine.
           */
          version?: {
            /** Format: uint64 */
            block?: string;
            /** Format: uint64 */
            app?: string;
          };
          chain_id?: string;
          /** Format: int64 */
          height?: string;
          /** Format: date-time */
          time?: string;
          /** BlockID */
          last_block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /**
           * hashes of block data
           * Format: byte
           */
          last_commit_hash?: string;
          /** Format: byte */
          data_hash?: string;
          /**
           * hashes from the app output from the prev block
           * Format: byte
           */
          validators_hash?: string;
          /** Format: byte */
          next_validators_hash?: string;
          /** Format: byte */
          consensus_hash?: string;
          /** Format: byte */
          app_hash?: string;
          /** Format: byte */
          last_results_hash?: string;
          /**
           * consensus info
           * Format: byte
           */
          evidence_hash?: string;
          /** Format: byte */
          proposer_address?: string;
        };
        /** Data contains the set of transactions included in the block */
        data?: {
          /** @description Txs that will be applied by state @ block.Height+1.
           *     NOTE: not all txs here are valid.  We're just agreeing on the order first.
           *     This means that block.AppHash does not include these txs. */
          txs?: string[];
        };
        evidence?: {
          evidence?: {
            /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
            duplicate_vote_evidence?: {
              /** @description Vote represents a prevote, precommit, or commit vote from validators for
               *     consensus. */
              vote_a?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *      - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /** Format: byte */
                signature?: string;
              };
              /** @description Vote represents a prevote, precommit, or commit vote from validators for
               *     consensus. */
              vote_b?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *      - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /** Format: byte */
                signature?: string;
              };
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: int64 */
              validator_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
            /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
            light_client_attack_evidence?: {
              conflicting_block?: {
                signed_header?: {
                  /** @description Header defines the structure of a block header. */
                  header?: {
                    /**
                     * basic block info
                     * @description Consensus captures the consensus rules for processing a block in the blockchain,
                     *     including all blockchain data structures and the rules of the application's
                     *     state transition machine.
                     */
                    version?: {
                      /** Format: uint64 */
                      block?: string;
                      /** Format: uint64 */
                      app?: string;
                    };
                    chain_id?: string;
                    /** Format: int64 */
                    height?: string;
                    /** Format: date-time */
                    time?: string;
                    /** BlockID */
                    last_block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    /**
                     * hashes of block data
                     * Format: byte
                     */
                    last_commit_hash?: string;
                    /** Format: byte */
                    data_hash?: string;
                    /**
                     * hashes from the app output from the prev block
                     * Format: byte
                     */
                    validators_hash?: string;
                    /** Format: byte */
                    next_validators_hash?: string;
                    /** Format: byte */
                    consensus_hash?: string;
                    /** Format: byte */
                    app_hash?: string;
                    /** Format: byte */
                    last_results_hash?: string;
                    /**
                     * consensus info
                     * Format: byte
                     */
                    evidence_hash?: string;
                    /** Format: byte */
                    proposer_address?: string;
                  };
                  /** @description Commit contains the evidence that a block was committed by a set of validators. */
                  commit?: {
                    /** Format: int64 */
                    height?: string;
                    /** Format: int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    signatures?: {
                      /**
                       * BlockIdFlag indicates which BlcokID the signature is for
                       * @default BLOCK_ID_FLAG_UNKNOWN
                       * @enum {string}
                       */
                      block_id_flag:
                        | "BLOCK_ID_FLAG_UNKNOWN"
                        | "BLOCK_ID_FLAG_ABSENT"
                        | "BLOCK_ID_FLAG_COMMIT"
                        | "BLOCK_ID_FLAG_NIL";
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      signature?: string;
                    }[];
                  };
                };
                validator_set?: {
                  validators?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  }[];
                  proposer?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  };
                  /** Format: int64 */
                  total_voting_power?: string;
                };
              };
              /** Format: int64 */
              common_height?: string;
              byzantine_validators?: {
                /** Format: byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** Format: byte */
                  ed25519?: string;
                  /** Format: byte */
                  secp256k1?: string;
                };
                /** Format: int64 */
                voting_power?: string;
                /** Format: int64 */
                proposer_priority?: string;
              }[];
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
          }[];
        };
        /** @description Commit contains the evidence that a block was committed by a set of validators. */
        last_commit?: {
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          signatures?: {
            /**
             * BlockIdFlag indicates which BlcokID the signature is for
             * @default BLOCK_ID_FLAG_UNKNOWN
             * @enum {string}
             */
            block_id_flag:
              | "BLOCK_ID_FLAG_UNKNOWN"
              | "BLOCK_ID_FLAG_ABSENT"
              | "BLOCK_ID_FLAG_COMMIT"
              | "BLOCK_ID_FLAG_NIL";
            /** Format: byte */
            validator_address?: string;
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            signature?: string;
          }[];
        };
      };
    };
    /** @description GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method. */
    "cosmos.base.tendermint.v1beta1.GetLatestBlockResponse": {
      /** BlockID */
      block_id?: {
        /** Format: byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** Format: int64 */
          total?: number;
          /** Format: byte */
          hash?: string;
        };
      };
      block?: {
        /** @description Header defines the structure of a block header. */
        header?: {
          /**
           * basic block info
           * @description Consensus captures the consensus rules for processing a block in the blockchain,
           *     including all blockchain data structures and the rules of the application's
           *     state transition machine.
           */
          version?: {
            /** Format: uint64 */
            block?: string;
            /** Format: uint64 */
            app?: string;
          };
          chain_id?: string;
          /** Format: int64 */
          height?: string;
          /** Format: date-time */
          time?: string;
          /** BlockID */
          last_block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /**
           * hashes of block data
           * Format: byte
           */
          last_commit_hash?: string;
          /** Format: byte */
          data_hash?: string;
          /**
           * hashes from the app output from the prev block
           * Format: byte
           */
          validators_hash?: string;
          /** Format: byte */
          next_validators_hash?: string;
          /** Format: byte */
          consensus_hash?: string;
          /** Format: byte */
          app_hash?: string;
          /** Format: byte */
          last_results_hash?: string;
          /**
           * consensus info
           * Format: byte
           */
          evidence_hash?: string;
          /** Format: byte */
          proposer_address?: string;
        };
        /** Data contains the set of transactions included in the block */
        data?: {
          /** @description Txs that will be applied by state @ block.Height+1.
           *     NOTE: not all txs here are valid.  We're just agreeing on the order first.
           *     This means that block.AppHash does not include these txs. */
          txs?: string[];
        };
        evidence?: {
          evidence?: {
            /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
            duplicate_vote_evidence?: {
              /** @description Vote represents a prevote, precommit, or commit vote from validators for
               *     consensus. */
              vote_a?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *      - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /** Format: byte */
                signature?: string;
              };
              /** @description Vote represents a prevote, precommit, or commit vote from validators for
               *     consensus. */
              vote_b?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *      - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /** Format: byte */
                signature?: string;
              };
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: int64 */
              validator_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
            /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
            light_client_attack_evidence?: {
              conflicting_block?: {
                signed_header?: {
                  /** @description Header defines the structure of a block header. */
                  header?: {
                    /**
                     * basic block info
                     * @description Consensus captures the consensus rules for processing a block in the blockchain,
                     *     including all blockchain data structures and the rules of the application's
                     *     state transition machine.
                     */
                    version?: {
                      /** Format: uint64 */
                      block?: string;
                      /** Format: uint64 */
                      app?: string;
                    };
                    chain_id?: string;
                    /** Format: int64 */
                    height?: string;
                    /** Format: date-time */
                    time?: string;
                    /** BlockID */
                    last_block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    /**
                     * hashes of block data
                     * Format: byte
                     */
                    last_commit_hash?: string;
                    /** Format: byte */
                    data_hash?: string;
                    /**
                     * hashes from the app output from the prev block
                     * Format: byte
                     */
                    validators_hash?: string;
                    /** Format: byte */
                    next_validators_hash?: string;
                    /** Format: byte */
                    consensus_hash?: string;
                    /** Format: byte */
                    app_hash?: string;
                    /** Format: byte */
                    last_results_hash?: string;
                    /**
                     * consensus info
                     * Format: byte
                     */
                    evidence_hash?: string;
                    /** Format: byte */
                    proposer_address?: string;
                  };
                  /** @description Commit contains the evidence that a block was committed by a set of validators. */
                  commit?: {
                    /** Format: int64 */
                    height?: string;
                    /** Format: int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    signatures?: {
                      /**
                       * BlockIdFlag indicates which BlcokID the signature is for
                       * @default BLOCK_ID_FLAG_UNKNOWN
                       * @enum {string}
                       */
                      block_id_flag:
                        | "BLOCK_ID_FLAG_UNKNOWN"
                        | "BLOCK_ID_FLAG_ABSENT"
                        | "BLOCK_ID_FLAG_COMMIT"
                        | "BLOCK_ID_FLAG_NIL";
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      signature?: string;
                    }[];
                  };
                };
                validator_set?: {
                  validators?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  }[];
                  proposer?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  };
                  /** Format: int64 */
                  total_voting_power?: string;
                };
              };
              /** Format: int64 */
              common_height?: string;
              byzantine_validators?: {
                /** Format: byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** Format: byte */
                  ed25519?: string;
                  /** Format: byte */
                  secp256k1?: string;
                };
                /** Format: int64 */
                voting_power?: string;
                /** Format: int64 */
                proposer_priority?: string;
              }[];
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
          }[];
        };
        /** @description Commit contains the evidence that a block was committed by a set of validators. */
        last_commit?: {
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          signatures?: {
            /**
             * BlockIdFlag indicates which BlcokID the signature is for
             * @default BLOCK_ID_FLAG_UNKNOWN
             * @enum {string}
             */
            block_id_flag:
              | "BLOCK_ID_FLAG_UNKNOWN"
              | "BLOCK_ID_FLAG_ABSENT"
              | "BLOCK_ID_FLAG_COMMIT"
              | "BLOCK_ID_FLAG_NIL";
            /** Format: byte */
            validator_address?: string;
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            signature?: string;
          }[];
        };
      };
    };
    /** @description GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method. */
    "cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse": {
      /** Format: int64 */
      block_height?: string;
      validators?: {
        address?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        pub_key?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** Format: int64 */
        voting_power?: string;
        /** Format: int64 */
        proposer_priority?: string;
      }[];
      /** @description pagination defines an pagination for the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description GetNodeInfoResponse is the request type for the Query/GetNodeInfo RPC method. */
    "cosmos.base.tendermint.v1beta1.GetNodeInfoResponse": {
      default_node_info?: {
        protocol_version?: {
          /** Format: uint64 */
          p2p?: string;
          /** Format: uint64 */
          block?: string;
          /** Format: uint64 */
          app?: string;
        };
        default_node_id?: string;
        listen_addr?: string;
        network?: string;
        version?: string;
        /** Format: byte */
        channels?: string;
        moniker?: string;
        other?: {
          tx_index?: string;
          rpc_address?: string;
        };
      };
      /** @description VersionInfo is the type for the GetNodeInfoResponse message. */
      application_version?: {
        name?: string;
        app_name?: string;
        version?: string;
        git_commit?: string;
        build_tags?: string;
        go_version?: string;
        build_deps?: {
          /** module path */
          path?: string;
          /** module version */
          version?: string;
          /** checksum */
          sum?: string;
        }[];
        /** Since: cosmos-sdk 0.43 */
        cosmos_sdk_version?: string;
      };
    };
    /** @description GetSyncingResponse is the response type for the Query/GetSyncing RPC method. */
    "cosmos.base.tendermint.v1beta1.GetSyncingResponse": {
      /** Format: boolean */
      syncing?: boolean;
    };
    /** @description GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method. */
    "cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse": {
      /** Format: int64 */
      block_height?: string;
      validators?: {
        address?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        pub_key?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** Format: int64 */
        voting_power?: string;
        /** Format: int64 */
        proposer_priority?: string;
      }[];
      /** @description pagination defines an pagination for the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** Module is the type for VersionInfo */
    "cosmos.base.tendermint.v1beta1.Module": {
      /** module path */
      path?: string;
      /** module version */
      version?: string;
      /** checksum */
      sum?: string;
    };
    /** @description Validator is the type for the validator-set. */
    "cosmos.base.tendermint.v1beta1.Validator": {
      address?: string;
      /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         } */
      pub_key?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /** Format: int64 */
      voting_power?: string;
      /** Format: int64 */
      proposer_priority?: string;
    };
    /** @description VersionInfo is the type for the GetNodeInfoResponse message. */
    "cosmos.base.tendermint.v1beta1.VersionInfo": {
      name?: string;
      app_name?: string;
      version?: string;
      git_commit?: string;
      build_tags?: string;
      go_version?: string;
      build_deps?: {
        /** module path */
        path?: string;
        /** module version */
        version?: string;
        /** checksum */
        sum?: string;
      }[];
      /** Since: cosmos-sdk 0.43 */
      cosmos_sdk_version?: string;
    };
    /** PublicKey defines the keys available for use with Validators */
    "tendermint.crypto.PublicKey": {
      /** Format: byte */
      ed25519?: string;
      /** Format: byte */
      secp256k1?: string;
    };
    "tendermint.p2p.DefaultNodeInfo": {
      protocol_version?: {
        /** Format: uint64 */
        p2p?: string;
        /** Format: uint64 */
        block?: string;
        /** Format: uint64 */
        app?: string;
      };
      default_node_id?: string;
      listen_addr?: string;
      network?: string;
      version?: string;
      /** Format: byte */
      channels?: string;
      moniker?: string;
      other?: {
        tx_index?: string;
        rpc_address?: string;
      };
    };
    "tendermint.p2p.DefaultNodeInfoOther": {
      tx_index?: string;
      rpc_address?: string;
    };
    "tendermint.p2p.ProtocolVersion": {
      /** Format: uint64 */
      p2p?: string;
      /** Format: uint64 */
      block?: string;
      /** Format: uint64 */
      app?: string;
    };
    "tendermint.types.Block": {
      /** @description Header defines the structure of a block header. */
      header?: {
        /**
         * basic block info
         * @description Consensus captures the consensus rules for processing a block in the blockchain,
         *     including all blockchain data structures and the rules of the application's
         *     state transition machine.
         */
        version?: {
          /** Format: uint64 */
          block?: string;
          /** Format: uint64 */
          app?: string;
        };
        chain_id?: string;
        /** Format: int64 */
        height?: string;
        /** Format: date-time */
        time?: string;
        /** BlockID */
        last_block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        /**
         * hashes of block data
         * Format: byte
         */
        last_commit_hash?: string;
        /** Format: byte */
        data_hash?: string;
        /**
         * hashes from the app output from the prev block
         * Format: byte
         */
        validators_hash?: string;
        /** Format: byte */
        next_validators_hash?: string;
        /** Format: byte */
        consensus_hash?: string;
        /** Format: byte */
        app_hash?: string;
        /** Format: byte */
        last_results_hash?: string;
        /**
         * consensus info
         * Format: byte
         */
        evidence_hash?: string;
        /** Format: byte */
        proposer_address?: string;
      };
      /** Data contains the set of transactions included in the block */
      data?: {
        /** @description Txs that will be applied by state @ block.Height+1.
         *     NOTE: not all txs here are valid.  We're just agreeing on the order first.
         *     This means that block.AppHash does not include these txs. */
        txs?: string[];
      };
      evidence?: {
        evidence?: {
          /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
          duplicate_vote_evidence?: {
            /** @description Vote represents a prevote, precommit, or commit vote from validators for
             *     consensus. */
            vote_a?: {
              /**
               * @description SignedMsgType is a type of signed message in the consensus.
               *
               *      - SIGNED_MSG_TYPE_PREVOTE: Votes
               *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
               * @default SIGNED_MSG_TYPE_UNKNOWN
               * @enum {string}
               */
              type:
                | "SIGNED_MSG_TYPE_UNKNOWN"
                | "SIGNED_MSG_TYPE_PREVOTE"
                | "SIGNED_MSG_TYPE_PRECOMMIT"
                | "SIGNED_MSG_TYPE_PROPOSAL";
              /** Format: int64 */
              height?: string;
              /** Format: int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** Format: byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** Format: int64 */
                  total?: number;
                  /** Format: byte */
                  hash?: string;
                };
              };
              /** Format: date-time */
              timestamp?: string;
              /** Format: byte */
              validator_address?: string;
              /** Format: int32 */
              validator_index?: number;
              /** Format: byte */
              signature?: string;
            };
            /** @description Vote represents a prevote, precommit, or commit vote from validators for
             *     consensus. */
            vote_b?: {
              /**
               * @description SignedMsgType is a type of signed message in the consensus.
               *
               *      - SIGNED_MSG_TYPE_PREVOTE: Votes
               *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
               * @default SIGNED_MSG_TYPE_UNKNOWN
               * @enum {string}
               */
              type:
                | "SIGNED_MSG_TYPE_UNKNOWN"
                | "SIGNED_MSG_TYPE_PREVOTE"
                | "SIGNED_MSG_TYPE_PRECOMMIT"
                | "SIGNED_MSG_TYPE_PROPOSAL";
              /** Format: int64 */
              height?: string;
              /** Format: int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** Format: byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** Format: int64 */
                  total?: number;
                  /** Format: byte */
                  hash?: string;
                };
              };
              /** Format: date-time */
              timestamp?: string;
              /** Format: byte */
              validator_address?: string;
              /** Format: int32 */
              validator_index?: number;
              /** Format: byte */
              signature?: string;
            };
            /** Format: int64 */
            total_voting_power?: string;
            /** Format: int64 */
            validator_power?: string;
            /** Format: date-time */
            timestamp?: string;
          };
          /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
          light_client_attack_evidence?: {
            conflicting_block?: {
              signed_header?: {
                /** @description Header defines the structure of a block header. */
                header?: {
                  /**
                   * basic block info
                   * @description Consensus captures the consensus rules for processing a block in the blockchain,
                   *     including all blockchain data structures and the rules of the application's
                   *     state transition machine.
                   */
                  version?: {
                    /** Format: uint64 */
                    block?: string;
                    /** Format: uint64 */
                    app?: string;
                  };
                  chain_id?: string;
                  /** Format: int64 */
                  height?: string;
                  /** Format: date-time */
                  time?: string;
                  /** BlockID */
                  last_block_id?: {
                    /** Format: byte */
                    hash?: string;
                    /** PartsetHeader */
                    part_set_header?: {
                      /** Format: int64 */
                      total?: number;
                      /** Format: byte */
                      hash?: string;
                    };
                  };
                  /**
                   * hashes of block data
                   * Format: byte
                   */
                  last_commit_hash?: string;
                  /** Format: byte */
                  data_hash?: string;
                  /**
                   * hashes from the app output from the prev block
                   * Format: byte
                   */
                  validators_hash?: string;
                  /** Format: byte */
                  next_validators_hash?: string;
                  /** Format: byte */
                  consensus_hash?: string;
                  /** Format: byte */
                  app_hash?: string;
                  /** Format: byte */
                  last_results_hash?: string;
                  /**
                   * consensus info
                   * Format: byte
                   */
                  evidence_hash?: string;
                  /** Format: byte */
                  proposer_address?: string;
                };
                /** @description Commit contains the evidence that a block was committed by a set of validators. */
                commit?: {
                  /** Format: int64 */
                  height?: string;
                  /** Format: int32 */
                  round?: number;
                  /** BlockID */
                  block_id?: {
                    /** Format: byte */
                    hash?: string;
                    /** PartsetHeader */
                    part_set_header?: {
                      /** Format: int64 */
                      total?: number;
                      /** Format: byte */
                      hash?: string;
                    };
                  };
                  signatures?: {
                    /**
                     * BlockIdFlag indicates which BlcokID the signature is for
                     * @default BLOCK_ID_FLAG_UNKNOWN
                     * @enum {string}
                     */
                    block_id_flag:
                      | "BLOCK_ID_FLAG_UNKNOWN"
                      | "BLOCK_ID_FLAG_ABSENT"
                      | "BLOCK_ID_FLAG_COMMIT"
                      | "BLOCK_ID_FLAG_NIL";
                    /** Format: byte */
                    validator_address?: string;
                    /** Format: date-time */
                    timestamp?: string;
                    /** Format: byte */
                    signature?: string;
                  }[];
                };
              };
              validator_set?: {
                validators?: {
                  /** Format: byte */
                  address?: string;
                  /** PublicKey defines the keys available for use with Validators */
                  pub_key?: {
                    /** Format: byte */
                    ed25519?: string;
                    /** Format: byte */
                    secp256k1?: string;
                  };
                  /** Format: int64 */
                  voting_power?: string;
                  /** Format: int64 */
                  proposer_priority?: string;
                }[];
                proposer?: {
                  /** Format: byte */
                  address?: string;
                  /** PublicKey defines the keys available for use with Validators */
                  pub_key?: {
                    /** Format: byte */
                    ed25519?: string;
                    /** Format: byte */
                    secp256k1?: string;
                  };
                  /** Format: int64 */
                  voting_power?: string;
                  /** Format: int64 */
                  proposer_priority?: string;
                };
                /** Format: int64 */
                total_voting_power?: string;
              };
            };
            /** Format: int64 */
            common_height?: string;
            byzantine_validators?: {
              /** Format: byte */
              address?: string;
              /** PublicKey defines the keys available for use with Validators */
              pub_key?: {
                /** Format: byte */
                ed25519?: string;
                /** Format: byte */
                secp256k1?: string;
              };
              /** Format: int64 */
              voting_power?: string;
              /** Format: int64 */
              proposer_priority?: string;
            }[];
            /** Format: int64 */
            total_voting_power?: string;
            /** Format: date-time */
            timestamp?: string;
          };
        }[];
      };
      /** @description Commit contains the evidence that a block was committed by a set of validators. */
      last_commit?: {
        /** Format: int64 */
        height?: string;
        /** Format: int32 */
        round?: number;
        /** BlockID */
        block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        signatures?: {
          /**
           * BlockIdFlag indicates which BlcokID the signature is for
           * @default BLOCK_ID_FLAG_UNKNOWN
           * @enum {string}
           */
          block_id_flag:
            | "BLOCK_ID_FLAG_UNKNOWN"
            | "BLOCK_ID_FLAG_ABSENT"
            | "BLOCK_ID_FLAG_COMMIT"
            | "BLOCK_ID_FLAG_NIL";
          /** Format: byte */
          validator_address?: string;
          /** Format: date-time */
          timestamp?: string;
          /** Format: byte */
          signature?: string;
        }[];
      };
    };
    /** BlockID */
    "tendermint.types.BlockID": {
      /** Format: byte */
      hash?: string;
      /** PartsetHeader */
      part_set_header?: {
        /** Format: int64 */
        total?: number;
        /** Format: byte */
        hash?: string;
      };
    };
    /**
     * BlockIdFlag indicates which BlcokID the signature is for
     * @default BLOCK_ID_FLAG_UNKNOWN
     * @enum {string}
     */
    "tendermint.types.BlockIDFlag":
      | "BLOCK_ID_FLAG_UNKNOWN"
      | "BLOCK_ID_FLAG_ABSENT"
      | "BLOCK_ID_FLAG_COMMIT"
      | "BLOCK_ID_FLAG_NIL";
    /** @description Commit contains the evidence that a block was committed by a set of validators. */
    "tendermint.types.Commit": {
      /** Format: int64 */
      height?: string;
      /** Format: int32 */
      round?: number;
      /** BlockID */
      block_id?: {
        /** Format: byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** Format: int64 */
          total?: number;
          /** Format: byte */
          hash?: string;
        };
      };
      signatures?: {
        /**
         * BlockIdFlag indicates which BlcokID the signature is for
         * @default BLOCK_ID_FLAG_UNKNOWN
         * @enum {string}
         */
        block_id_flag:
          | "BLOCK_ID_FLAG_UNKNOWN"
          | "BLOCK_ID_FLAG_ABSENT"
          | "BLOCK_ID_FLAG_COMMIT"
          | "BLOCK_ID_FLAG_NIL";
        /** Format: byte */
        validator_address?: string;
        /** Format: date-time */
        timestamp?: string;
        /** Format: byte */
        signature?: string;
      }[];
    };
    /** @description CommitSig is a part of the Vote included in a Commit. */
    "tendermint.types.CommitSig": {
      /**
       * BlockIdFlag indicates which BlcokID the signature is for
       * @default BLOCK_ID_FLAG_UNKNOWN
       * @enum {string}
       */
      block_id_flag:
        | "BLOCK_ID_FLAG_UNKNOWN"
        | "BLOCK_ID_FLAG_ABSENT"
        | "BLOCK_ID_FLAG_COMMIT"
        | "BLOCK_ID_FLAG_NIL";
      /** Format: byte */
      validator_address?: string;
      /** Format: date-time */
      timestamp?: string;
      /** Format: byte */
      signature?: string;
    };
    /** Data contains the set of transactions included in the block */
    "tendermint.types.Data": {
      /** @description Txs that will be applied by state @ block.Height+1.
       *     NOTE: not all txs here are valid.  We're just agreeing on the order first.
       *     This means that block.AppHash does not include these txs. */
      txs?: string[];
    };
    /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
    "tendermint.types.DuplicateVoteEvidence": {
      /** @description Vote represents a prevote, precommit, or commit vote from validators for
       *     consensus. */
      vote_a?: {
        /**
         * @description SignedMsgType is a type of signed message in the consensus.
         *
         *      - SIGNED_MSG_TYPE_PREVOTE: Votes
         *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
         * @default SIGNED_MSG_TYPE_UNKNOWN
         * @enum {string}
         */
        type:
          | "SIGNED_MSG_TYPE_UNKNOWN"
          | "SIGNED_MSG_TYPE_PREVOTE"
          | "SIGNED_MSG_TYPE_PRECOMMIT"
          | "SIGNED_MSG_TYPE_PROPOSAL";
        /** Format: int64 */
        height?: string;
        /** Format: int32 */
        round?: number;
        /** BlockID */
        block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        /** Format: date-time */
        timestamp?: string;
        /** Format: byte */
        validator_address?: string;
        /** Format: int32 */
        validator_index?: number;
        /** Format: byte */
        signature?: string;
      };
      /** @description Vote represents a prevote, precommit, or commit vote from validators for
       *     consensus. */
      vote_b?: {
        /**
         * @description SignedMsgType is a type of signed message in the consensus.
         *
         *      - SIGNED_MSG_TYPE_PREVOTE: Votes
         *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
         * @default SIGNED_MSG_TYPE_UNKNOWN
         * @enum {string}
         */
        type:
          | "SIGNED_MSG_TYPE_UNKNOWN"
          | "SIGNED_MSG_TYPE_PREVOTE"
          | "SIGNED_MSG_TYPE_PRECOMMIT"
          | "SIGNED_MSG_TYPE_PROPOSAL";
        /** Format: int64 */
        height?: string;
        /** Format: int32 */
        round?: number;
        /** BlockID */
        block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        /** Format: date-time */
        timestamp?: string;
        /** Format: byte */
        validator_address?: string;
        /** Format: int32 */
        validator_index?: number;
        /** Format: byte */
        signature?: string;
      };
      /** Format: int64 */
      total_voting_power?: string;
      /** Format: int64 */
      validator_power?: string;
      /** Format: date-time */
      timestamp?: string;
    };
    "tendermint.types.Evidence": {
      /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
      duplicate_vote_evidence?: {
        /** @description Vote represents a prevote, precommit, or commit vote from validators for
         *     consensus. */
        vote_a?: {
          /**
           * @description SignedMsgType is a type of signed message in the consensus.
           *
           *      - SIGNED_MSG_TYPE_PREVOTE: Votes
           *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
           * @default SIGNED_MSG_TYPE_UNKNOWN
           * @enum {string}
           */
          type:
            | "SIGNED_MSG_TYPE_UNKNOWN"
            | "SIGNED_MSG_TYPE_PREVOTE"
            | "SIGNED_MSG_TYPE_PRECOMMIT"
            | "SIGNED_MSG_TYPE_PROPOSAL";
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /** Format: date-time */
          timestamp?: string;
          /** Format: byte */
          validator_address?: string;
          /** Format: int32 */
          validator_index?: number;
          /** Format: byte */
          signature?: string;
        };
        /** @description Vote represents a prevote, precommit, or commit vote from validators for
         *     consensus. */
        vote_b?: {
          /**
           * @description SignedMsgType is a type of signed message in the consensus.
           *
           *      - SIGNED_MSG_TYPE_PREVOTE: Votes
           *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
           * @default SIGNED_MSG_TYPE_UNKNOWN
           * @enum {string}
           */
          type:
            | "SIGNED_MSG_TYPE_UNKNOWN"
            | "SIGNED_MSG_TYPE_PREVOTE"
            | "SIGNED_MSG_TYPE_PRECOMMIT"
            | "SIGNED_MSG_TYPE_PROPOSAL";
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /** Format: date-time */
          timestamp?: string;
          /** Format: byte */
          validator_address?: string;
          /** Format: int32 */
          validator_index?: number;
          /** Format: byte */
          signature?: string;
        };
        /** Format: int64 */
        total_voting_power?: string;
        /** Format: int64 */
        validator_power?: string;
        /** Format: date-time */
        timestamp?: string;
      };
      /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
      light_client_attack_evidence?: {
        conflicting_block?: {
          signed_header?: {
            /** @description Header defines the structure of a block header. */
            header?: {
              /**
               * basic block info
               * @description Consensus captures the consensus rules for processing a block in the blockchain,
               *     including all blockchain data structures and the rules of the application's
               *     state transition machine.
               */
              version?: {
                /** Format: uint64 */
                block?: string;
                /** Format: uint64 */
                app?: string;
              };
              chain_id?: string;
              /** Format: int64 */
              height?: string;
              /** Format: date-time */
              time?: string;
              /** BlockID */
              last_block_id?: {
                /** Format: byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** Format: int64 */
                  total?: number;
                  /** Format: byte */
                  hash?: string;
                };
              };
              /**
               * hashes of block data
               * Format: byte
               */
              last_commit_hash?: string;
              /** Format: byte */
              data_hash?: string;
              /**
               * hashes from the app output from the prev block
               * Format: byte
               */
              validators_hash?: string;
              /** Format: byte */
              next_validators_hash?: string;
              /** Format: byte */
              consensus_hash?: string;
              /** Format: byte */
              app_hash?: string;
              /** Format: byte */
              last_results_hash?: string;
              /**
               * consensus info
               * Format: byte
               */
              evidence_hash?: string;
              /** Format: byte */
              proposer_address?: string;
            };
            /** @description Commit contains the evidence that a block was committed by a set of validators. */
            commit?: {
              /** Format: int64 */
              height?: string;
              /** Format: int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** Format: byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** Format: int64 */
                  total?: number;
                  /** Format: byte */
                  hash?: string;
                };
              };
              signatures?: {
                /**
                 * BlockIdFlag indicates which BlcokID the signature is for
                 * @default BLOCK_ID_FLAG_UNKNOWN
                 * @enum {string}
                 */
                block_id_flag:
                  | "BLOCK_ID_FLAG_UNKNOWN"
                  | "BLOCK_ID_FLAG_ABSENT"
                  | "BLOCK_ID_FLAG_COMMIT"
                  | "BLOCK_ID_FLAG_NIL";
                /** Format: byte */
                validator_address?: string;
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                signature?: string;
              }[];
            };
          };
          validator_set?: {
            validators?: {
              /** Format: byte */
              address?: string;
              /** PublicKey defines the keys available for use with Validators */
              pub_key?: {
                /** Format: byte */
                ed25519?: string;
                /** Format: byte */
                secp256k1?: string;
              };
              /** Format: int64 */
              voting_power?: string;
              /** Format: int64 */
              proposer_priority?: string;
            }[];
            proposer?: {
              /** Format: byte */
              address?: string;
              /** PublicKey defines the keys available for use with Validators */
              pub_key?: {
                /** Format: byte */
                ed25519?: string;
                /** Format: byte */
                secp256k1?: string;
              };
              /** Format: int64 */
              voting_power?: string;
              /** Format: int64 */
              proposer_priority?: string;
            };
            /** Format: int64 */
            total_voting_power?: string;
          };
        };
        /** Format: int64 */
        common_height?: string;
        byzantine_validators?: {
          /** Format: byte */
          address?: string;
          /** PublicKey defines the keys available for use with Validators */
          pub_key?: {
            /** Format: byte */
            ed25519?: string;
            /** Format: byte */
            secp256k1?: string;
          };
          /** Format: int64 */
          voting_power?: string;
          /** Format: int64 */
          proposer_priority?: string;
        }[];
        /** Format: int64 */
        total_voting_power?: string;
        /** Format: date-time */
        timestamp?: string;
      };
    };
    "tendermint.types.EvidenceList": {
      evidence?: {
        /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
        duplicate_vote_evidence?: {
          /** @description Vote represents a prevote, precommit, or commit vote from validators for
           *     consensus. */
          vote_a?: {
            /**
             * @description SignedMsgType is a type of signed message in the consensus.
             *
             *      - SIGNED_MSG_TYPE_PREVOTE: Votes
             *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default SIGNED_MSG_TYPE_UNKNOWN
             * @enum {string}
             */
            type:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** Format: int64 */
            height?: string;
            /** Format: int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** Format: byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** Format: int64 */
                total?: number;
                /** Format: byte */
                hash?: string;
              };
            };
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            validator_address?: string;
            /** Format: int32 */
            validator_index?: number;
            /** Format: byte */
            signature?: string;
          };
          /** @description Vote represents a prevote, precommit, or commit vote from validators for
           *     consensus. */
          vote_b?: {
            /**
             * @description SignedMsgType is a type of signed message in the consensus.
             *
             *      - SIGNED_MSG_TYPE_PREVOTE: Votes
             *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default SIGNED_MSG_TYPE_UNKNOWN
             * @enum {string}
             */
            type:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** Format: int64 */
            height?: string;
            /** Format: int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** Format: byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** Format: int64 */
                total?: number;
                /** Format: byte */
                hash?: string;
              };
            };
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            validator_address?: string;
            /** Format: int32 */
            validator_index?: number;
            /** Format: byte */
            signature?: string;
          };
          /** Format: int64 */
          total_voting_power?: string;
          /** Format: int64 */
          validator_power?: string;
          /** Format: date-time */
          timestamp?: string;
        };
        /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
        light_client_attack_evidence?: {
          conflicting_block?: {
            signed_header?: {
              /** @description Header defines the structure of a block header. */
              header?: {
                /**
                 * basic block info
                 * @description Consensus captures the consensus rules for processing a block in the blockchain,
                 *     including all blockchain data structures and the rules of the application's
                 *     state transition machine.
                 */
                version?: {
                  /** Format: uint64 */
                  block?: string;
                  /** Format: uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** Format: int64 */
                height?: string;
                /** Format: date-time */
                time?: string;
                /** BlockID */
                last_block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * Format: byte
                 */
                last_commit_hash?: string;
                /** Format: byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * Format: byte
                 */
                validators_hash?: string;
                /** Format: byte */
                next_validators_hash?: string;
                /** Format: byte */
                consensus_hash?: string;
                /** Format: byte */
                app_hash?: string;
                /** Format: byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * Format: byte
                 */
                evidence_hash?: string;
                /** Format: byte */
                proposer_address?: string;
              };
              /** @description Commit contains the evidence that a block was committed by a set of validators. */
              commit?: {
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                signatures?: {
                  /**
                   * BlockIdFlag indicates which BlcokID the signature is for
                   * @default BLOCK_ID_FLAG_UNKNOWN
                   * @enum {string}
                   */
                  block_id_flag:
                    | "BLOCK_ID_FLAG_UNKNOWN"
                    | "BLOCK_ID_FLAG_ABSENT"
                    | "BLOCK_ID_FLAG_COMMIT"
                    | "BLOCK_ID_FLAG_NIL";
                  /** Format: byte */
                  validator_address?: string;
                  /** Format: date-time */
                  timestamp?: string;
                  /** Format: byte */
                  signature?: string;
                }[];
              };
            };
            validator_set?: {
              validators?: {
                /** Format: byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** Format: byte */
                  ed25519?: string;
                  /** Format: byte */
                  secp256k1?: string;
                };
                /** Format: int64 */
                voting_power?: string;
                /** Format: int64 */
                proposer_priority?: string;
              }[];
              proposer?: {
                /** Format: byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** Format: byte */
                  ed25519?: string;
                  /** Format: byte */
                  secp256k1?: string;
                };
                /** Format: int64 */
                voting_power?: string;
                /** Format: int64 */
                proposer_priority?: string;
              };
              /** Format: int64 */
              total_voting_power?: string;
            };
          };
          /** Format: int64 */
          common_height?: string;
          byzantine_validators?: {
            /** Format: byte */
            address?: string;
            /** PublicKey defines the keys available for use with Validators */
            pub_key?: {
              /** Format: byte */
              ed25519?: string;
              /** Format: byte */
              secp256k1?: string;
            };
            /** Format: int64 */
            voting_power?: string;
            /** Format: int64 */
            proposer_priority?: string;
          }[];
          /** Format: int64 */
          total_voting_power?: string;
          /** Format: date-time */
          timestamp?: string;
        };
      }[];
    };
    /** @description Header defines the structure of a block header. */
    "tendermint.types.Header": {
      /**
       * basic block info
       * @description Consensus captures the consensus rules for processing a block in the blockchain,
       *     including all blockchain data structures and the rules of the application's
       *     state transition machine.
       */
      version?: {
        /** Format: uint64 */
        block?: string;
        /** Format: uint64 */
        app?: string;
      };
      chain_id?: string;
      /** Format: int64 */
      height?: string;
      /** Format: date-time */
      time?: string;
      /** BlockID */
      last_block_id?: {
        /** Format: byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** Format: int64 */
          total?: number;
          /** Format: byte */
          hash?: string;
        };
      };
      /**
       * hashes of block data
       * Format: byte
       */
      last_commit_hash?: string;
      /** Format: byte */
      data_hash?: string;
      /**
       * hashes from the app output from the prev block
       * Format: byte
       */
      validators_hash?: string;
      /** Format: byte */
      next_validators_hash?: string;
      /** Format: byte */
      consensus_hash?: string;
      /** Format: byte */
      app_hash?: string;
      /** Format: byte */
      last_results_hash?: string;
      /**
       * consensus info
       * Format: byte
       */
      evidence_hash?: string;
      /** Format: byte */
      proposer_address?: string;
    };
    "tendermint.types.LightBlock": {
      signed_header?: {
        /** @description Header defines the structure of a block header. */
        header?: {
          /**
           * basic block info
           * @description Consensus captures the consensus rules for processing a block in the blockchain,
           *     including all blockchain data structures and the rules of the application's
           *     state transition machine.
           */
          version?: {
            /** Format: uint64 */
            block?: string;
            /** Format: uint64 */
            app?: string;
          };
          chain_id?: string;
          /** Format: int64 */
          height?: string;
          /** Format: date-time */
          time?: string;
          /** BlockID */
          last_block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /**
           * hashes of block data
           * Format: byte
           */
          last_commit_hash?: string;
          /** Format: byte */
          data_hash?: string;
          /**
           * hashes from the app output from the prev block
           * Format: byte
           */
          validators_hash?: string;
          /** Format: byte */
          next_validators_hash?: string;
          /** Format: byte */
          consensus_hash?: string;
          /** Format: byte */
          app_hash?: string;
          /** Format: byte */
          last_results_hash?: string;
          /**
           * consensus info
           * Format: byte
           */
          evidence_hash?: string;
          /** Format: byte */
          proposer_address?: string;
        };
        /** @description Commit contains the evidence that a block was committed by a set of validators. */
        commit?: {
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          signatures?: {
            /**
             * BlockIdFlag indicates which BlcokID the signature is for
             * @default BLOCK_ID_FLAG_UNKNOWN
             * @enum {string}
             */
            block_id_flag:
              | "BLOCK_ID_FLAG_UNKNOWN"
              | "BLOCK_ID_FLAG_ABSENT"
              | "BLOCK_ID_FLAG_COMMIT"
              | "BLOCK_ID_FLAG_NIL";
            /** Format: byte */
            validator_address?: string;
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            signature?: string;
          }[];
        };
      };
      validator_set?: {
        validators?: {
          /** Format: byte */
          address?: string;
          /** PublicKey defines the keys available for use with Validators */
          pub_key?: {
            /** Format: byte */
            ed25519?: string;
            /** Format: byte */
            secp256k1?: string;
          };
          /** Format: int64 */
          voting_power?: string;
          /** Format: int64 */
          proposer_priority?: string;
        }[];
        proposer?: {
          /** Format: byte */
          address?: string;
          /** PublicKey defines the keys available for use with Validators */
          pub_key?: {
            /** Format: byte */
            ed25519?: string;
            /** Format: byte */
            secp256k1?: string;
          };
          /** Format: int64 */
          voting_power?: string;
          /** Format: int64 */
          proposer_priority?: string;
        };
        /** Format: int64 */
        total_voting_power?: string;
      };
    };
    /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
    "tendermint.types.LightClientAttackEvidence": {
      conflicting_block?: {
        signed_header?: {
          /** @description Header defines the structure of a block header. */
          header?: {
            /**
             * basic block info
             * @description Consensus captures the consensus rules for processing a block in the blockchain,
             *     including all blockchain data structures and the rules of the application's
             *     state transition machine.
             */
            version?: {
              /** Format: uint64 */
              block?: string;
              /** Format: uint64 */
              app?: string;
            };
            chain_id?: string;
            /** Format: int64 */
            height?: string;
            /** Format: date-time */
            time?: string;
            /** BlockID */
            last_block_id?: {
              /** Format: byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** Format: int64 */
                total?: number;
                /** Format: byte */
                hash?: string;
              };
            };
            /**
             * hashes of block data
             * Format: byte
             */
            last_commit_hash?: string;
            /** Format: byte */
            data_hash?: string;
            /**
             * hashes from the app output from the prev block
             * Format: byte
             */
            validators_hash?: string;
            /** Format: byte */
            next_validators_hash?: string;
            /** Format: byte */
            consensus_hash?: string;
            /** Format: byte */
            app_hash?: string;
            /** Format: byte */
            last_results_hash?: string;
            /**
             * consensus info
             * Format: byte
             */
            evidence_hash?: string;
            /** Format: byte */
            proposer_address?: string;
          };
          /** @description Commit contains the evidence that a block was committed by a set of validators. */
          commit?: {
            /** Format: int64 */
            height?: string;
            /** Format: int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** Format: byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** Format: int64 */
                total?: number;
                /** Format: byte */
                hash?: string;
              };
            };
            signatures?: {
              /**
               * BlockIdFlag indicates which BlcokID the signature is for
               * @default BLOCK_ID_FLAG_UNKNOWN
               * @enum {string}
               */
              block_id_flag:
                | "BLOCK_ID_FLAG_UNKNOWN"
                | "BLOCK_ID_FLAG_ABSENT"
                | "BLOCK_ID_FLAG_COMMIT"
                | "BLOCK_ID_FLAG_NIL";
              /** Format: byte */
              validator_address?: string;
              /** Format: date-time */
              timestamp?: string;
              /** Format: byte */
              signature?: string;
            }[];
          };
        };
        validator_set?: {
          validators?: {
            /** Format: byte */
            address?: string;
            /** PublicKey defines the keys available for use with Validators */
            pub_key?: {
              /** Format: byte */
              ed25519?: string;
              /** Format: byte */
              secp256k1?: string;
            };
            /** Format: int64 */
            voting_power?: string;
            /** Format: int64 */
            proposer_priority?: string;
          }[];
          proposer?: {
            /** Format: byte */
            address?: string;
            /** PublicKey defines the keys available for use with Validators */
            pub_key?: {
              /** Format: byte */
              ed25519?: string;
              /** Format: byte */
              secp256k1?: string;
            };
            /** Format: int64 */
            voting_power?: string;
            /** Format: int64 */
            proposer_priority?: string;
          };
          /** Format: int64 */
          total_voting_power?: string;
        };
      };
      /** Format: int64 */
      common_height?: string;
      byzantine_validators?: {
        /** Format: byte */
        address?: string;
        /** PublicKey defines the keys available for use with Validators */
        pub_key?: {
          /** Format: byte */
          ed25519?: string;
          /** Format: byte */
          secp256k1?: string;
        };
        /** Format: int64 */
        voting_power?: string;
        /** Format: int64 */
        proposer_priority?: string;
      }[];
      /** Format: int64 */
      total_voting_power?: string;
      /** Format: date-time */
      timestamp?: string;
    };
    /** PartsetHeader */
    "tendermint.types.PartSetHeader": {
      /** Format: int64 */
      total?: number;
      /** Format: byte */
      hash?: string;
    };
    "tendermint.types.SignedHeader": {
      /** @description Header defines the structure of a block header. */
      header?: {
        /**
         * basic block info
         * @description Consensus captures the consensus rules for processing a block in the blockchain,
         *     including all blockchain data structures and the rules of the application's
         *     state transition machine.
         */
        version?: {
          /** Format: uint64 */
          block?: string;
          /** Format: uint64 */
          app?: string;
        };
        chain_id?: string;
        /** Format: int64 */
        height?: string;
        /** Format: date-time */
        time?: string;
        /** BlockID */
        last_block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        /**
         * hashes of block data
         * Format: byte
         */
        last_commit_hash?: string;
        /** Format: byte */
        data_hash?: string;
        /**
         * hashes from the app output from the prev block
         * Format: byte
         */
        validators_hash?: string;
        /** Format: byte */
        next_validators_hash?: string;
        /** Format: byte */
        consensus_hash?: string;
        /** Format: byte */
        app_hash?: string;
        /** Format: byte */
        last_results_hash?: string;
        /**
         * consensus info
         * Format: byte
         */
        evidence_hash?: string;
        /** Format: byte */
        proposer_address?: string;
      };
      /** @description Commit contains the evidence that a block was committed by a set of validators. */
      commit?: {
        /** Format: int64 */
        height?: string;
        /** Format: int32 */
        round?: number;
        /** BlockID */
        block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        signatures?: {
          /**
           * BlockIdFlag indicates which BlcokID the signature is for
           * @default BLOCK_ID_FLAG_UNKNOWN
           * @enum {string}
           */
          block_id_flag:
            | "BLOCK_ID_FLAG_UNKNOWN"
            | "BLOCK_ID_FLAG_ABSENT"
            | "BLOCK_ID_FLAG_COMMIT"
            | "BLOCK_ID_FLAG_NIL";
          /** Format: byte */
          validator_address?: string;
          /** Format: date-time */
          timestamp?: string;
          /** Format: byte */
          signature?: string;
        }[];
      };
    };
    /**
     * @description SignedMsgType is a type of signed message in the consensus.
     *
     *      - SIGNED_MSG_TYPE_PREVOTE: Votes
     *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
     * @default SIGNED_MSG_TYPE_UNKNOWN
     * @enum {string}
     */
    "tendermint.types.SignedMsgType":
      | "SIGNED_MSG_TYPE_UNKNOWN"
      | "SIGNED_MSG_TYPE_PREVOTE"
      | "SIGNED_MSG_TYPE_PRECOMMIT"
      | "SIGNED_MSG_TYPE_PROPOSAL";
    "tendermint.types.Validator": {
      /** Format: byte */
      address?: string;
      /** PublicKey defines the keys available for use with Validators */
      pub_key?: {
        /** Format: byte */
        ed25519?: string;
        /** Format: byte */
        secp256k1?: string;
      };
      /** Format: int64 */
      voting_power?: string;
      /** Format: int64 */
      proposer_priority?: string;
    };
    "tendermint.types.ValidatorSet": {
      validators?: {
        /** Format: byte */
        address?: string;
        /** PublicKey defines the keys available for use with Validators */
        pub_key?: {
          /** Format: byte */
          ed25519?: string;
          /** Format: byte */
          secp256k1?: string;
        };
        /** Format: int64 */
        voting_power?: string;
        /** Format: int64 */
        proposer_priority?: string;
      }[];
      proposer?: {
        /** Format: byte */
        address?: string;
        /** PublicKey defines the keys available for use with Validators */
        pub_key?: {
          /** Format: byte */
          ed25519?: string;
          /** Format: byte */
          secp256k1?: string;
        };
        /** Format: int64 */
        voting_power?: string;
        /** Format: int64 */
        proposer_priority?: string;
      };
      /** Format: int64 */
      total_voting_power?: string;
    };
    /** @description Vote represents a prevote, precommit, or commit vote from validators for
     *     consensus. */
    "tendermint.types.Vote": {
      /**
       * @description SignedMsgType is a type of signed message in the consensus.
       *
       *      - SIGNED_MSG_TYPE_PREVOTE: Votes
       *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
       * @default SIGNED_MSG_TYPE_UNKNOWN
       * @enum {string}
       */
      type:
        | "SIGNED_MSG_TYPE_UNKNOWN"
        | "SIGNED_MSG_TYPE_PREVOTE"
        | "SIGNED_MSG_TYPE_PRECOMMIT"
        | "SIGNED_MSG_TYPE_PROPOSAL";
      /** Format: int64 */
      height?: string;
      /** Format: int32 */
      round?: number;
      /** BlockID */
      block_id?: {
        /** Format: byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** Format: int64 */
          total?: number;
          /** Format: byte */
          hash?: string;
        };
      };
      /** Format: date-time */
      timestamp?: string;
      /** Format: byte */
      validator_address?: string;
      /** Format: int32 */
      validator_index?: number;
      /** Format: byte */
      signature?: string;
    };
    /** @description Consensus captures the consensus rules for processing a block in the blockchain,
     *     including all blockchain data structures and the rules of the application's
     *     state transition machine. */
    "tendermint.version.Consensus": {
      /** Format: uint64 */
      block?: string;
      /** Format: uint64 */
      app?: string;
    };
    /** @description DecCoin defines a token with a denomination and a decimal amount.
     *
     *     NOTE: The amount field is an Dec which implements the custom method
     *     signatures required by gogoproto. */
    "cosmos.base.v1beta1.DecCoin": {
      denom?: string;
      amount?: string;
    };
    /** @description DelegationDelegatorReward represents the properties
     *     of a delegator's delegation reward. */
    "cosmos.distribution.v1beta1.DelegationDelegatorReward": {
      validator_address?: string;
      reward?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /** @description Params defines the set of params for the distribution module. */
    "cosmos.distribution.v1beta1.Params": {
      community_tax?: string;
      base_proposer_reward?: string;
      bonus_proposer_reward?: string;
      /** Format: boolean */
      withdraw_addr_enabled?: boolean;
    };
    /** @description QueryCommunityPoolResponse is the response type for the Query/CommunityPool
     *     RPC method. */
    "cosmos.distribution.v1beta1.QueryCommunityPoolResponse": {
      /** @description pool defines community pool's coins. */
      pool?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /** @description QueryDelegationRewardsResponse is the response type for the
     *     Query/DelegationRewards RPC method. */
    "cosmos.distribution.v1beta1.QueryDelegationRewardsResponse": {
      /** @description rewards defines the rewards accrued by a delegation. */
      rewards?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /** @description QueryDelegationTotalRewardsResponse is the response type for the
     *     Query/DelegationTotalRewards RPC method. */
    "cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse": {
      /** @description rewards defines all the rewards accrued by a delegator. */
      rewards?: {
        validator_address?: string;
        reward?: {
          denom?: string;
          amount?: string;
        }[];
      }[];
      /** @description total defines the sum of all the rewards. */
      total?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /** @description QueryDelegatorValidatorsResponse is the response type for the
     *     Query/DelegatorValidators RPC method. */
    "cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse": {
      /** @description validators defines the validators a delegator is delegating for. */
      validators?: string[];
    };
    /** @description QueryDelegatorWithdrawAddressResponse is the response type for the
     *     Query/DelegatorWithdrawAddress RPC method. */
    "cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse": {
      /** @description withdraw_address defines the delegator address to query for. */
      withdraw_address?: string;
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "cosmos.distribution.v1beta1.QueryParamsResponse": {
      /** @description params defines the parameters of the module. */
      params?: {
        community_tax?: string;
        base_proposer_reward?: string;
        bonus_proposer_reward?: string;
        /** Format: boolean */
        withdraw_addr_enabled?: boolean;
      };
    };
    /** QueryValidatorCommissionResponse is the response type for the
     *     Query/ValidatorCommission RPC method */
    "cosmos.distribution.v1beta1.QueryValidatorCommissionResponse": {
      /** @description commission defines the commision the validator received. */
      commission?: {
        commission?: {
          denom?: string;
          amount?: string;
        }[];
      };
    };
    /** @description QueryValidatorOutstandingRewardsResponse is the response type for the
     *     Query/ValidatorOutstandingRewards RPC method. */
    "cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse": {
      /** @description ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
       *     for a validator inexpensive to track, allows simple sanity checks. */
      rewards?: {
        rewards?: {
          denom?: string;
          amount?: string;
        }[];
      };
    };
    /** @description QueryValidatorSlashesResponse is the response type for the
     *     Query/ValidatorSlashes RPC method. */
    "cosmos.distribution.v1beta1.QueryValidatorSlashesResponse": {
      /** @description slashes defines the slashes the validator received. */
      slashes?: {
        /** Format: uint64 */
        validator_period?: string;
        fraction?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description ValidatorAccumulatedCommission represents accumulated commission
     *     for a validator kept as a running counter, can be withdrawn at any time. */
    "cosmos.distribution.v1beta1.ValidatorAccumulatedCommission": {
      commission?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /** @description ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
     *     for a validator inexpensive to track, allows simple sanity checks. */
    "cosmos.distribution.v1beta1.ValidatorOutstandingRewards": {
      rewards?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /** @description ValidatorSlashEvent represents a validator slash event.
     *     Height is implicit within the store key.
     *     This is needed to calculate appropriate amount of staking tokens
     *     for delegations which are withdrawn after a slash has occurred. */
    "cosmos.distribution.v1beta1.ValidatorSlashEvent": {
      /** Format: uint64 */
      validator_period?: string;
      fraction?: string;
    };
    /** Grant is stored in the KVStore to record a grant with full context */
    "cosmos.feegrant.v1beta1.Grant": {
      /** @description granter is the address of the user granting an allowance of their funds. */
      granter?: string;
      /** @description grantee is the address of the user being granted an allowance of another user's funds. */
      grantee?: string;
      /** @description allowance can be any of basic and filtered fee allowance. */
      allowance?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /** @description QueryAllowanceResponse is the response type for the Query/Allowance RPC method. */
    "cosmos.feegrant.v1beta1.QueryAllowanceResponse": {
      /**
       * Grant is stored in the KVStore to record a grant with full context
       * @description allowance is a allowance granted for grantee by granter.
       */
      allowance?: {
        /** @description granter is the address of the user granting an allowance of their funds. */
        granter?: string;
        /** @description grantee is the address of the user being granted an allowance of another user's funds. */
        grantee?: string;
        /** @description allowance can be any of basic and filtered fee allowance. */
        allowance?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      };
    };
    /** @description QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method. */
    "cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse": {
      /** @description allowances that have been issued by the granter. */
      allowances?: {
        /** @description granter is the address of the user granting an allowance of their funds. */
        granter?: string;
        /** @description grantee is the address of the user being granted an allowance of another user's funds. */
        grantee?: string;
        /** @description allowance can be any of basic and filtered fee allowance. */
        allowance?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      }[];
      /** @description pagination defines an pagination for the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryAllowancesResponse is the response type for the Query/Allowances RPC method. */
    "cosmos.feegrant.v1beta1.QueryAllowancesResponse": {
      /** @description allowances are allowance's granted for grantee by granter. */
      allowances?: {
        /** @description granter is the address of the user granting an allowance of their funds. */
        granter?: string;
        /** @description grantee is the address of the user being granted an allowance of another user's funds. */
        grantee?: string;
        /** @description allowance can be any of basic and filtered fee allowance. */
        allowance?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      }[];
      /** @description pagination defines an pagination for the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC
     *     method. */
    "cosmos.evidence.v1beta1.QueryAllEvidenceResponse": {
      /** @description evidence returns all evidences. */
      evidence?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryEvidenceResponse is the response type for the Query/Evidence RPC method. */
    "cosmos.evidence.v1beta1.QueryEvidenceResponse": {
      /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         } */
      evidence?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /** @description Deposit defines an amount deposited by an account address to an active
     *     proposal. */
    "cosmos.gov.v1beta1.Deposit": {
      /** Format: uint64 */
      proposal_id?: string;
      depositor?: string;
      amount?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /** @description DepositParams defines the params for deposits on governance proposals. */
    "cosmos.gov.v1beta1.DepositParams": {
      /** @description Minimum deposit for a proposal to enter voting period. */
      min_deposit?: {
        denom?: string;
        amount?: string;
      }[];
      /** @description Maximum period for Atom holders to deposit on a proposal. Initial value: 2
       *      months. */
      max_deposit_period?: string;
    };
    /** @description Proposal defines the core field members of a governance proposal. */
    "cosmos.gov.v1beta1.Proposal": {
      /** Format: uint64 */
      proposal_id?: string;
      /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         } */
      content?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /**
       * @description ProposalStatus enumerates the valid statuses of a proposal.
       *
       *      - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
       *      - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
       *     period.
       *      - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
       *     period.
       *      - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
       *     passed.
       *      - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
       *     been rejected.
       *      - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
       *     failed.
       * @default PROPOSAL_STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "PROPOSAL_STATUS_UNSPECIFIED"
        | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
        | "PROPOSAL_STATUS_VOTING_PERIOD"
        | "PROPOSAL_STATUS_PASSED"
        | "PROPOSAL_STATUS_REJECTED"
        | "PROPOSAL_STATUS_FAILED";
      /** @description TallyResult defines a standard tally for a governance proposal. */
      final_tally_result?: {
        yes?: string;
        abstain?: string;
        no?: string;
        no_with_veto?: string;
      };
      /** Format: date-time */
      submit_time?: string;
      /** Format: date-time */
      deposit_end_time?: string;
      total_deposit?: {
        denom?: string;
        amount?: string;
      }[];
      /** Format: date-time */
      voting_start_time?: string;
      /** Format: date-time */
      voting_end_time?: string;
    };
    /**
     * @description ProposalStatus enumerates the valid statuses of a proposal.
     *
     *      - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
     *      - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
     *     period.
     *      - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
     *     period.
     *      - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
     *     passed.
     *      - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
     *     been rejected.
     *      - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
     *     failed.
     * @default PROPOSAL_STATUS_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.gov.v1beta1.ProposalStatus":
      | "PROPOSAL_STATUS_UNSPECIFIED"
      | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
      | "PROPOSAL_STATUS_VOTING_PERIOD"
      | "PROPOSAL_STATUS_PASSED"
      | "PROPOSAL_STATUS_REJECTED"
      | "PROPOSAL_STATUS_FAILED";
    /** @description QueryDepositResponse is the response type for the Query/Deposit RPC method. */
    "cosmos.gov.v1beta1.QueryDepositResponse": {
      /** @description Deposit defines an amount deposited by an account address to an active
       *     proposal. */
      deposit?: {
        /** Format: uint64 */
        proposal_id?: string;
        depositor?: string;
        amount?: {
          denom?: string;
          amount?: string;
        }[];
      };
    };
    /** @description QueryDepositsResponse is the response type for the Query/Deposits RPC method. */
    "cosmos.gov.v1beta1.QueryDepositsResponse": {
      deposits?: {
        /** Format: uint64 */
        proposal_id?: string;
        depositor?: string;
        amount?: {
          denom?: string;
          amount?: string;
        }[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "cosmos.gov.v1beta1.QueryParamsResponse": {
      /** @description voting_params defines the parameters related to voting. */
      voting_params?: {
        /** @description Length of the voting period. */
        voting_period?: string;
      };
      /** @description deposit_params defines the parameters related to deposit. */
      deposit_params?: {
        /** @description Minimum deposit for a proposal to enter voting period. */
        min_deposit?: {
          denom?: string;
          amount?: string;
        }[];
        /** @description Maximum period for Atom holders to deposit on a proposal. Initial value: 2
         *      months. */
        max_deposit_period?: string;
      };
      /** @description tally_params defines the parameters related to tally. */
      tally_params?: {
        /**
         * Format: byte
         * @description Minimum percentage of total stake needed to vote for a result to be
         *      considered valid.
         */
        quorum?: string;
        /**
         * Format: byte
         * @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
         */
        threshold?: string;
        /**
         * Format: byte
         * @description Minimum value of Veto votes to Total votes ratio for proposal to be
         *      vetoed. Default value: 1/3.
         */
        veto_threshold?: string;
      };
    };
    /** @description QueryProposalResponse is the response type for the Query/Proposal RPC method. */
    "cosmos.gov.v1beta1.QueryProposalResponse": {
      /** @description Proposal defines the core field members of a governance proposal. */
      proposal?: {
        /** Format: uint64 */
        proposal_id?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        content?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /**
         * @description ProposalStatus enumerates the valid statuses of a proposal.
         *
         *      - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
         *      - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
         *     period.
         *      - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
         *     period.
         *      - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
         *     passed.
         *      - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
         *     been rejected.
         *      - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
         *     failed.
         * @default PROPOSAL_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "PROPOSAL_STATUS_UNSPECIFIED"
          | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
          | "PROPOSAL_STATUS_VOTING_PERIOD"
          | "PROPOSAL_STATUS_PASSED"
          | "PROPOSAL_STATUS_REJECTED"
          | "PROPOSAL_STATUS_FAILED";
        /** @description TallyResult defines a standard tally for a governance proposal. */
        final_tally_result?: {
          yes?: string;
          abstain?: string;
          no?: string;
          no_with_veto?: string;
        };
        /** Format: date-time */
        submit_time?: string;
        /** Format: date-time */
        deposit_end_time?: string;
        total_deposit?: {
          denom?: string;
          amount?: string;
        }[];
        /** Format: date-time */
        voting_start_time?: string;
        /** Format: date-time */
        voting_end_time?: string;
      };
    };
    /** @description QueryProposalsResponse is the response type for the Query/Proposals RPC
     *     method. */
    "cosmos.gov.v1beta1.QueryProposalsResponse": {
      proposals?: {
        /** Format: uint64 */
        proposal_id?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        content?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /**
         * @description ProposalStatus enumerates the valid statuses of a proposal.
         *
         *      - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
         *      - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
         *     period.
         *      - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
         *     period.
         *      - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
         *     passed.
         *      - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
         *     been rejected.
         *      - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
         *     failed.
         * @default PROPOSAL_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "PROPOSAL_STATUS_UNSPECIFIED"
          | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
          | "PROPOSAL_STATUS_VOTING_PERIOD"
          | "PROPOSAL_STATUS_PASSED"
          | "PROPOSAL_STATUS_REJECTED"
          | "PROPOSAL_STATUS_FAILED";
        /** @description TallyResult defines a standard tally for a governance proposal. */
        final_tally_result?: {
          yes?: string;
          abstain?: string;
          no?: string;
          no_with_veto?: string;
        };
        /** Format: date-time */
        submit_time?: string;
        /** Format: date-time */
        deposit_end_time?: string;
        total_deposit?: {
          denom?: string;
          amount?: string;
        }[];
        /** Format: date-time */
        voting_start_time?: string;
        /** Format: date-time */
        voting_end_time?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryTallyResultResponse is the response type for the Query/Tally RPC method. */
    "cosmos.gov.v1beta1.QueryTallyResultResponse": {
      /** @description TallyResult defines a standard tally for a governance proposal. */
      tally?: {
        yes?: string;
        abstain?: string;
        no?: string;
        no_with_veto?: string;
      };
    };
    /** @description QueryVoteResponse is the response type for the Query/Vote RPC method. */
    "cosmos.gov.v1beta1.QueryVoteResponse": {
      /** @description Vote defines a vote on a governance proposal.
       *     A Vote consists of a proposal ID, the voter, and the vote option. */
      vote?: {
        /** Format: uint64 */
        proposal_id?: string;
        voter?: string;
        /**
         * @description Deprecated: Prefer to use `options` instead. This field is set in queries
         *     if and only if `len(options) == 1` and that option has weight 1. In all
         *     other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
         * @default VOTE_OPTION_UNSPECIFIED
         * @enum {string}
         */
        option:
          | "VOTE_OPTION_UNSPECIFIED"
          | "VOTE_OPTION_YES"
          | "VOTE_OPTION_ABSTAIN"
          | "VOTE_OPTION_NO"
          | "VOTE_OPTION_NO_WITH_VETO";
        /** Since: cosmos-sdk 0.43 */
        options?: {
          /**
           * @description VoteOption enumerates the valid vote options for a given governance proposal.
           *
           *      - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
           *      - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
           *      - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
           *      - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
           *      - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
           * @default VOTE_OPTION_UNSPECIFIED
           * @enum {string}
           */
          option:
            | "VOTE_OPTION_UNSPECIFIED"
            | "VOTE_OPTION_YES"
            | "VOTE_OPTION_ABSTAIN"
            | "VOTE_OPTION_NO"
            | "VOTE_OPTION_NO_WITH_VETO";
          weight?: string;
        }[];
      };
    };
    /** @description QueryVotesResponse is the response type for the Query/Votes RPC method. */
    "cosmos.gov.v1beta1.QueryVotesResponse": {
      /** @description votes defined the queried votes. */
      votes?: {
        /** Format: uint64 */
        proposal_id?: string;
        voter?: string;
        /**
         * @description Deprecated: Prefer to use `options` instead. This field is set in queries
         *     if and only if `len(options) == 1` and that option has weight 1. In all
         *     other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
         * @default VOTE_OPTION_UNSPECIFIED
         * @enum {string}
         */
        option:
          | "VOTE_OPTION_UNSPECIFIED"
          | "VOTE_OPTION_YES"
          | "VOTE_OPTION_ABSTAIN"
          | "VOTE_OPTION_NO"
          | "VOTE_OPTION_NO_WITH_VETO";
        /** Since: cosmos-sdk 0.43 */
        options?: {
          /**
           * @description VoteOption enumerates the valid vote options for a given governance proposal.
           *
           *      - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
           *      - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
           *      - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
           *      - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
           *      - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
           * @default VOTE_OPTION_UNSPECIFIED
           * @enum {string}
           */
          option:
            | "VOTE_OPTION_UNSPECIFIED"
            | "VOTE_OPTION_YES"
            | "VOTE_OPTION_ABSTAIN"
            | "VOTE_OPTION_NO"
            | "VOTE_OPTION_NO_WITH_VETO";
          weight?: string;
        }[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description TallyParams defines the params for tallying votes on governance proposals. */
    "cosmos.gov.v1beta1.TallyParams": {
      /**
       * Format: byte
       * @description Minimum percentage of total stake needed to vote for a result to be
       *      considered valid.
       */
      quorum?: string;
      /**
       * Format: byte
       * @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
       */
      threshold?: string;
      /**
       * Format: byte
       * @description Minimum value of Veto votes to Total votes ratio for proposal to be
       *      vetoed. Default value: 1/3.
       */
      veto_threshold?: string;
    };
    /** @description TallyResult defines a standard tally for a governance proposal. */
    "cosmos.gov.v1beta1.TallyResult": {
      yes?: string;
      abstain?: string;
      no?: string;
      no_with_veto?: string;
    };
    /** @description Vote defines a vote on a governance proposal.
     *     A Vote consists of a proposal ID, the voter, and the vote option. */
    "cosmos.gov.v1beta1.Vote": {
      /** Format: uint64 */
      proposal_id?: string;
      voter?: string;
      /**
       * @description Deprecated: Prefer to use `options` instead. This field is set in queries
       *     if and only if `len(options) == 1` and that option has weight 1. In all
       *     other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
       * @default VOTE_OPTION_UNSPECIFIED
       * @enum {string}
       */
      option:
        | "VOTE_OPTION_UNSPECIFIED"
        | "VOTE_OPTION_YES"
        | "VOTE_OPTION_ABSTAIN"
        | "VOTE_OPTION_NO"
        | "VOTE_OPTION_NO_WITH_VETO";
      /** Since: cosmos-sdk 0.43 */
      options?: {
        /**
         * @description VoteOption enumerates the valid vote options for a given governance proposal.
         *
         *      - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
         *      - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
         *      - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
         *      - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
         *      - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
         * @default VOTE_OPTION_UNSPECIFIED
         * @enum {string}
         */
        option:
          | "VOTE_OPTION_UNSPECIFIED"
          | "VOTE_OPTION_YES"
          | "VOTE_OPTION_ABSTAIN"
          | "VOTE_OPTION_NO"
          | "VOTE_OPTION_NO_WITH_VETO";
        weight?: string;
      }[];
    };
    /**
     * @description VoteOption enumerates the valid vote options for a given governance proposal.
     *
     *      - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
     *      - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
     *      - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
     *      - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
     *      - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
     * @default VOTE_OPTION_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.gov.v1beta1.VoteOption":
      | "VOTE_OPTION_UNSPECIFIED"
      | "VOTE_OPTION_YES"
      | "VOTE_OPTION_ABSTAIN"
      | "VOTE_OPTION_NO"
      | "VOTE_OPTION_NO_WITH_VETO";
    /** @description VotingParams defines the params for voting on governance proposals. */
    "cosmos.gov.v1beta1.VotingParams": {
      /** @description Length of the voting period. */
      voting_period?: string;
    };
    /** @description WeightedVoteOption defines a unit of vote for vote split.
     *
     *     Since: cosmos-sdk 0.43 */
    "cosmos.gov.v1beta1.WeightedVoteOption": {
      /**
       * @description VoteOption enumerates the valid vote options for a given governance proposal.
       *
       *      - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
       *      - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
       *      - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
       *      - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
       *      - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
       * @default VOTE_OPTION_UNSPECIFIED
       * @enum {string}
       */
      option:
        | "VOTE_OPTION_UNSPECIFIED"
        | "VOTE_OPTION_YES"
        | "VOTE_OPTION_ABSTAIN"
        | "VOTE_OPTION_NO"
        | "VOTE_OPTION_NO_WITH_VETO";
      weight?: string;
    };
    /** @description Params holds parameters for the mint module. */
    "cosmos.mint.v1beta1.Params": {
      /** type of coin to mint */
      mint_denom?: string;
      /** maximum annual change in inflation rate */
      inflation_rate_change?: string;
      /** maximum inflation rate */
      inflation_max?: string;
      /** minimum inflation rate */
      inflation_min?: string;
      /** goal of percent bonded atoms */
      goal_bonded?: string;
      /**
       * expected blocks per year
       * Format: uint64
       */
      blocks_per_year?: string;
    };
    /** @description QueryAnnualProvisionsResponse is the response type for the
     *     Query/AnnualProvisions RPC method. */
    "cosmos.mint.v1beta1.QueryAnnualProvisionsResponse": {
      /**
       * Format: byte
       * @description annual_provisions is the current minting annual provisions value.
       */
      annual_provisions?: string;
    };
    /** @description QueryInflationResponse is the response type for the Query/Inflation RPC
     *     method. */
    "cosmos.mint.v1beta1.QueryInflationResponse": {
      /**
       * Format: byte
       * @description inflation is the current minting inflation value.
       */
      inflation?: string;
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "cosmos.mint.v1beta1.QueryParamsResponse": {
      /** @description params defines the parameters of the module. */
      params?: {
        /** type of coin to mint */
        mint_denom?: string;
        /** maximum annual change in inflation rate */
        inflation_rate_change?: string;
        /** maximum inflation rate */
        inflation_max?: string;
        /** minimum inflation rate */
        inflation_min?: string;
        /** goal of percent bonded atoms */
        goal_bonded?: string;
        /**
         * expected blocks per year
         * Format: uint64
         */
        blocks_per_year?: string;
      };
    };
    /** @description ParamChange defines an individual parameter change, for use in
     *     ParameterChangeProposal. */
    "cosmos.params.v1beta1.ParamChange": {
      subspace?: string;
      key?: string;
      value?: string;
    };
    /** @description QueryParamsResponse is response type for the Query/Params RPC method. */
    "cosmos.params.v1beta1.QueryParamsResponse": {
      /** @description param defines the queried parameter. */
      param?: {
        subspace?: string;
        key?: string;
        value?: string;
      };
    };
    /** @description Params represents the parameters used for by the slashing module. */
    "cosmos.slashing.v1beta1.Params": {
      /** Format: int64 */
      signed_blocks_window?: string;
      /** Format: byte */
      min_signed_per_window?: string;
      downtime_jail_duration?: string;
      /** Format: byte */
      slash_fraction_double_sign?: string;
      /** Format: byte */
      slash_fraction_downtime?: string;
    };
    /** QueryParamsResponse is the response type for the Query/Params RPC method */
    "cosmos.slashing.v1beta1.QueryParamsResponse": {
      /** @description Params represents the parameters used for by the slashing module. */
      params?: {
        /** Format: int64 */
        signed_blocks_window?: string;
        /** Format: byte */
        min_signed_per_window?: string;
        downtime_jail_duration?: string;
        /** Format: byte */
        slash_fraction_double_sign?: string;
        /** Format: byte */
        slash_fraction_downtime?: string;
      };
    };
    /** QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC
     *     method */
    "cosmos.slashing.v1beta1.QuerySigningInfoResponse": {
      /**
       * val_signing_info is the signing info of requested val cons address
       * @description ValidatorSigningInfo defines a validator's signing info for monitoring their
       *     liveness activity.
       */
      val_signing_info?: {
        address?: string;
        /**
         * Height at which validator was first a candidate OR was unjailed
         * Format: int64
         */
        start_height?: string;
        /**
         * Format: int64
         * @description Index which is incremented each time the validator was a bonded
         *     in a block and may have signed a precommit or not. This in conjunction with the
         *     `SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`.
         */
        index_offset?: string;
        /**
         * Format: date-time
         * @description Timestamp until which the validator is jailed due to liveness downtime.
         */
        jailed_until?: string;
        /**
         * Format: boolean
         * @description Whether or not a validator has been tombstoned (killed out of validator set). It is set
         *     once the validator commits an equivocation or for any other configured misbehiavor.
         */
        tombstoned?: boolean;
        /**
         * Format: int64
         * @description A counter kept to avoid unnecessary array reads.
         *     Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`.
         */
        missed_blocks_counter?: string;
      };
    };
    /** QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC
     *     method */
    "cosmos.slashing.v1beta1.QuerySigningInfosResponse": {
      /** info is the signing info of all validators */
      info?: {
        address?: string;
        /**
         * Height at which validator was first a candidate OR was unjailed
         * Format: int64
         */
        start_height?: string;
        /**
         * Format: int64
         * @description Index which is incremented each time the validator was a bonded
         *     in a block and may have signed a precommit or not. This in conjunction with the
         *     `SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`.
         */
        index_offset?: string;
        /**
         * Format: date-time
         * @description Timestamp until which the validator is jailed due to liveness downtime.
         */
        jailed_until?: string;
        /**
         * Format: boolean
         * @description Whether or not a validator has been tombstoned (killed out of validator set). It is set
         *     once the validator commits an equivocation or for any other configured misbehiavor.
         */
        tombstoned?: boolean;
        /**
         * Format: int64
         * @description A counter kept to avoid unnecessary array reads.
         *     Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`.
         */
        missed_blocks_counter?: string;
      }[];
      /** @description PageResponse is to be embedded in gRPC response messages where the
       *     corresponding request message has used PageRequest.
       *
       *      message SomeResponse {
       *              repeated Bar results = 1;
       *              PageResponse page = 2;
       *      } */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description ValidatorSigningInfo defines a validator's signing info for monitoring their
     *     liveness activity. */
    "cosmos.slashing.v1beta1.ValidatorSigningInfo": {
      address?: string;
      /**
       * Height at which validator was first a candidate OR was unjailed
       * Format: int64
       */
      start_height?: string;
      /**
       * Format: int64
       * @description Index which is incremented each time the validator was a bonded
       *     in a block and may have signed a precommit or not. This in conjunction with the
       *     `SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`.
       */
      index_offset?: string;
      /**
       * Format: date-time
       * @description Timestamp until which the validator is jailed due to liveness downtime.
       */
      jailed_until?: string;
      /**
       * Format: boolean
       * @description Whether or not a validator has been tombstoned (killed out of validator set). It is set
       *     once the validator commits an equivocation or for any other configured misbehiavor.
       */
      tombstoned?: boolean;
      /**
       * Format: int64
       * @description A counter kept to avoid unnecessary array reads.
       *     Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`.
       */
      missed_blocks_counter?: string;
    };
    /**
     * @description BondStatus is the status of a validator.
     *
     *      - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.
     *      - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.
     *      - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.
     *      - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.
     * @default BOND_STATUS_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.staking.v1beta1.BondStatus":
      | "BOND_STATUS_UNSPECIFIED"
      | "BOND_STATUS_UNBONDED"
      | "BOND_STATUS_UNBONDING"
      | "BOND_STATUS_BONDED";
    /** @description Commission defines commission parameters for a given validator. */
    "cosmos.staking.v1beta1.Commission": {
      /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
      commission_rates?: {
        /** @description rate is the commission rate charged to delegators, as a fraction. */
        rate?: string;
        /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
        max_rate?: string;
        /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
        max_change_rate?: string;
      };
      /**
       * Format: date-time
       * @description update_time is the last time the commission rate was changed.
       */
      update_time?: string;
    };
    /** @description CommissionRates defines the initial commission rates to be used for creating
     *     a validator. */
    "cosmos.staking.v1beta1.CommissionRates": {
      /** @description rate is the commission rate charged to delegators, as a fraction. */
      rate?: string;
      /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
      max_rate?: string;
      /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
      max_change_rate?: string;
    };
    /** @description Delegation represents the bond with tokens held by an account. It is
     *     owned by one delegator, and is associated with the voting power of one
     *     validator. */
    "cosmos.staking.v1beta1.Delegation": {
      /** @description delegator_address is the bech32-encoded address of the delegator. */
      delegator_address?: string;
      /** @description validator_address is the bech32-encoded address of the validator. */
      validator_address?: string;
      /** @description shares define the delegation shares received. */
      shares?: string;
    };
    /** @description DelegationResponse is equivalent to Delegation except that it contains a
     *     balance in addition to shares which is more suitable for client responses. */
    "cosmos.staking.v1beta1.DelegationResponse": {
      /** @description Delegation represents the bond with tokens held by an account. It is
       *     owned by one delegator, and is associated with the voting power of one
       *     validator. */
      delegation?: {
        /** @description delegator_address is the bech32-encoded address of the delegator. */
        delegator_address?: string;
        /** @description validator_address is the bech32-encoded address of the validator. */
        validator_address?: string;
        /** @description shares define the delegation shares received. */
        shares?: string;
      };
      /** @description Coin defines a token with a denomination and an amount.
       *
       *     NOTE: The amount field is an Int which implements the custom method
       *     signatures required by gogoproto. */
      balance?: {
        denom?: string;
        amount?: string;
      };
    };
    /** @description Description defines a validator description. */
    "cosmos.staking.v1beta1.Description": {
      /** @description moniker defines a human-readable name for the validator. */
      moniker?: string;
      /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
      identity?: string;
      /** @description website defines an optional website link. */
      website?: string;
      /** @description security_contact defines an optional email for security contact. */
      security_contact?: string;
      /** @description details define other optional details. */
      details?: string;
    };
    /** @description HistoricalInfo contains header and validator information for a given block.
     *     It is stored as part of staking module's state, which persists the `n` most
     *     recent HistoricalInfo
     *     (`n` is set by the staking module's `historical_entries` parameter). */
    "cosmos.staking.v1beta1.HistoricalInfo": {
      /** @description Header defines the structure of a block header. */
      header?: {
        /**
         * basic block info
         * @description Consensus captures the consensus rules for processing a block in the blockchain,
         *     including all blockchain data structures and the rules of the application's
         *     state transition machine.
         */
        version?: {
          /** Format: uint64 */
          block?: string;
          /** Format: uint64 */
          app?: string;
        };
        chain_id?: string;
        /** Format: int64 */
        height?: string;
        /** Format: date-time */
        time?: string;
        /** prev block info */
        last_block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        /**
         * hashes of block data
         * Format: byte
         */
        last_commit_hash?: string;
        /** Format: byte */
        data_hash?: string;
        /**
         * hashes from the app output from the prev block
         * Format: byte
         */
        validators_hash?: string;
        /** Format: byte */
        next_validators_hash?: string;
        /** Format: byte */
        consensus_hash?: string;
        /** Format: byte */
        app_hash?: string;
        /** Format: byte */
        last_results_hash?: string;
        /**
         * consensus info
         * Format: byte
         */
        evidence_hash?: string;
        /** Format: byte */
        proposer_address?: string;
      };
      valset?: {
        /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
        operator_address?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        consensus_pubkey?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /**
         * Format: boolean
         * @description jailed defined whether the validator has been jailed from bonded status or not.
         */
        jailed?: boolean;
        /**
         * @description status is the validator status (bonded/unbonding/unbonded).
         * @default BOND_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "BOND_STATUS_UNSPECIFIED"
          | "BOND_STATUS_UNBONDED"
          | "BOND_STATUS_UNBONDING"
          | "BOND_STATUS_BONDED";
        /** @description tokens define the delegated tokens (incl. self-delegation). */
        tokens?: string;
        /** @description delegator_shares defines total shares issued to a validator's delegators. */
        delegator_shares?: string;
        /** @description description defines the description terms for the validator. */
        description?: {
          /** @description moniker defines a human-readable name for the validator. */
          moniker?: string;
          /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
          identity?: string;
          /** @description website defines an optional website link. */
          website?: string;
          /** @description security_contact defines an optional email for security contact. */
          security_contact?: string;
          /** @description details define other optional details. */
          details?: string;
        };
        /**
         * Format: int64
         * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
         */
        unbonding_height?: string;
        /**
         * Format: date-time
         * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
         */
        unbonding_time?: string;
        /** @description commission defines the commission parameters. */
        commission?: {
          /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
          commission_rates?: {
            /** @description rate is the commission rate charged to delegators, as a fraction. */
            rate?: string;
            /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
            max_rate?: string;
            /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
            max_change_rate?: string;
          };
          /**
           * Format: date-time
           * @description update_time is the last time the commission rate was changed.
           */
          update_time?: string;
        };
        /** @description min_self_delegation is the validator's self declared minimum self delegation. */
        min_self_delegation?: string;
      }[];
    };
    /** @description Params defines the parameters for the staking module. */
    "cosmos.staking.v1beta1.Params": {
      /** @description unbonding_time is the time duration of unbonding. */
      unbonding_time?: string;
      /**
       * Format: int64
       * @description max_validators is the maximum number of validators.
       */
      max_validators?: number;
      /**
       * Format: int64
       * @description max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
       */
      max_entries?: number;
      /**
       * Format: int64
       * @description historical_entries is the number of historical entries to persist.
       */
      historical_entries?: number;
      /** @description bond_denom defines the bondable coin denomination. */
      bond_denom?: string;
    };
    /** @description Pool is used for tracking bonded and not-bonded token supply of the bond
     *     denomination. */
    "cosmos.staking.v1beta1.Pool": {
      not_bonded_tokens?: string;
      bonded_tokens?: string;
    };
    /** @description QueryDelegationResponse is response type for the Query/Delegation RPC method. */
    "cosmos.staking.v1beta1.QueryDelegationResponse": {
      /** @description DelegationResponse is equivalent to Delegation except that it contains a
       *     balance in addition to shares which is more suitable for client responses. */
      delegation_response?: {
        /** @description Delegation represents the bond with tokens held by an account. It is
         *     owned by one delegator, and is associated with the voting power of one
         *     validator. */
        delegation?: {
          /** @description delegator_address is the bech32-encoded address of the delegator. */
          delegator_address?: string;
          /** @description validator_address is the bech32-encoded address of the validator. */
          validator_address?: string;
          /** @description shares define the delegation shares received. */
          shares?: string;
        };
        /** @description Coin defines a token with a denomination and an amount.
         *
         *     NOTE: The amount field is an Int which implements the custom method
         *     signatures required by gogoproto. */
        balance?: {
          denom?: string;
          amount?: string;
        };
      };
    };
    /** @description QueryDelegatorDelegationsResponse is response type for the
     *     Query/DelegatorDelegations RPC method. */
    "cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse": {
      /** @description delegation_responses defines all the delegations' info of a delegator. */
      delegation_responses?: {
        /** @description Delegation represents the bond with tokens held by an account. It is
         *     owned by one delegator, and is associated with the voting power of one
         *     validator. */
        delegation?: {
          /** @description delegator_address is the bech32-encoded address of the delegator. */
          delegator_address?: string;
          /** @description validator_address is the bech32-encoded address of the validator. */
          validator_address?: string;
          /** @description shares define the delegation shares received. */
          shares?: string;
        };
        /** @description Coin defines a token with a denomination and an amount.
         *
         *     NOTE: The amount field is an Int which implements the custom method
         *     signatures required by gogoproto. */
        balance?: {
          denom?: string;
          amount?: string;
        };
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryUnbondingDelegatorDelegationsResponse is response type for the
     *     Query/UnbondingDelegatorDelegations RPC method. */
    "cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse": {
      unbonding_responses?: {
        /** @description delegator_address is the bech32-encoded address of the delegator. */
        delegator_address?: string;
        /** @description validator_address is the bech32-encoded address of the validator. */
        validator_address?: string;
        /** @description entries are the unbonding delegation entries. */
        entries?: {
          /**
           * Format: int64
           * @description creation_height is the height which the unbonding took place.
           */
          creation_height?: string;
          /**
           * Format: date-time
           * @description completion_time is the unix time for unbonding completion.
           */
          completion_time?: string;
          /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
          initial_balance?: string;
          /** @description balance defines the tokens to receive at completion. */
          balance?: string;
        }[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryDelegatorValidatorResponse response type for the
     *     Query/DelegatorValidator RPC method. */
    "cosmos.staking.v1beta1.QueryDelegatorValidatorResponse": {
      /** @description Validator defines a validator, together with the total amount of the
       *     Validator's bond shares and their exchange rate to coins. Slashing results in
       *     a decrease in the exchange rate, allowing correct calculation of future
       *     undelegations without iterating over delegators. When coins are delegated to
       *     this validator, the validator is credited with a delegation whose number of
       *     bond shares is based on the amount of coins delegated divided by the current
       *     exchange rate. Voting power can be calculated as total bonded shares
       *     multiplied by exchange rate. */
      validator?: {
        /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
        operator_address?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        consensus_pubkey?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /**
         * Format: boolean
         * @description jailed defined whether the validator has been jailed from bonded status or not.
         */
        jailed?: boolean;
        /**
         * @description status is the validator status (bonded/unbonding/unbonded).
         * @default BOND_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "BOND_STATUS_UNSPECIFIED"
          | "BOND_STATUS_UNBONDED"
          | "BOND_STATUS_UNBONDING"
          | "BOND_STATUS_BONDED";
        /** @description tokens define the delegated tokens (incl. self-delegation). */
        tokens?: string;
        /** @description delegator_shares defines total shares issued to a validator's delegators. */
        delegator_shares?: string;
        /** @description description defines the description terms for the validator. */
        description?: {
          /** @description moniker defines a human-readable name for the validator. */
          moniker?: string;
          /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
          identity?: string;
          /** @description website defines an optional website link. */
          website?: string;
          /** @description security_contact defines an optional email for security contact. */
          security_contact?: string;
          /** @description details define other optional details. */
          details?: string;
        };
        /**
         * Format: int64
         * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
         */
        unbonding_height?: string;
        /**
         * Format: date-time
         * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
         */
        unbonding_time?: string;
        /** @description commission defines the commission parameters. */
        commission?: {
          /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
          commission_rates?: {
            /** @description rate is the commission rate charged to delegators, as a fraction. */
            rate?: string;
            /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
            max_rate?: string;
            /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
            max_change_rate?: string;
          };
          /**
           * Format: date-time
           * @description update_time is the last time the commission rate was changed.
           */
          update_time?: string;
        };
        /** @description min_self_delegation is the validator's self declared minimum self delegation. */
        min_self_delegation?: string;
      };
    };
    /** @description QueryDelegatorValidatorsResponse is response type for the
     *     Query/DelegatorValidators RPC method. */
    "cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse": {
      /** @description validators defines the the validators' info of a delegator. */
      validators?: {
        /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
        operator_address?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        consensus_pubkey?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /**
         * Format: boolean
         * @description jailed defined whether the validator has been jailed from bonded status or not.
         */
        jailed?: boolean;
        /**
         * @description status is the validator status (bonded/unbonding/unbonded).
         * @default BOND_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "BOND_STATUS_UNSPECIFIED"
          | "BOND_STATUS_UNBONDED"
          | "BOND_STATUS_UNBONDING"
          | "BOND_STATUS_BONDED";
        /** @description tokens define the delegated tokens (incl. self-delegation). */
        tokens?: string;
        /** @description delegator_shares defines total shares issued to a validator's delegators. */
        delegator_shares?: string;
        /** @description description defines the description terms for the validator. */
        description?: {
          /** @description moniker defines a human-readable name for the validator. */
          moniker?: string;
          /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
          identity?: string;
          /** @description website defines an optional website link. */
          website?: string;
          /** @description security_contact defines an optional email for security contact. */
          security_contact?: string;
          /** @description details define other optional details. */
          details?: string;
        };
        /**
         * Format: int64
         * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
         */
        unbonding_height?: string;
        /**
         * Format: date-time
         * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
         */
        unbonding_time?: string;
        /** @description commission defines the commission parameters. */
        commission?: {
          /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
          commission_rates?: {
            /** @description rate is the commission rate charged to delegators, as a fraction. */
            rate?: string;
            /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
            max_rate?: string;
            /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
            max_change_rate?: string;
          };
          /**
           * Format: date-time
           * @description update_time is the last time the commission rate was changed.
           */
          update_time?: string;
        };
        /** @description min_self_delegation is the validator's self declared minimum self delegation. */
        min_self_delegation?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC
     *     method. */
    "cosmos.staking.v1beta1.QueryHistoricalInfoResponse": {
      /** @description hist defines the historical info at the given height. */
      hist?: {
        /** @description Header defines the structure of a block header. */
        header?: {
          /**
           * basic block info
           * @description Consensus captures the consensus rules for processing a block in the blockchain,
           *     including all blockchain data structures and the rules of the application's
           *     state transition machine.
           */
          version?: {
            /** Format: uint64 */
            block?: string;
            /** Format: uint64 */
            app?: string;
          };
          chain_id?: string;
          /** Format: int64 */
          height?: string;
          /** Format: date-time */
          time?: string;
          /** prev block info */
          last_block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /**
           * hashes of block data
           * Format: byte
           */
          last_commit_hash?: string;
          /** Format: byte */
          data_hash?: string;
          /**
           * hashes from the app output from the prev block
           * Format: byte
           */
          validators_hash?: string;
          /** Format: byte */
          next_validators_hash?: string;
          /** Format: byte */
          consensus_hash?: string;
          /** Format: byte */
          app_hash?: string;
          /** Format: byte */
          last_results_hash?: string;
          /**
           * consensus info
           * Format: byte
           */
          evidence_hash?: string;
          /** Format: byte */
          proposer_address?: string;
        };
        valset?: {
          /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
          operator_address?: string;
          /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
           *     URL that describes the type of the serialized message.
           *
           *     Protobuf library provides support to pack/unpack Any values in the form
           *     of utility functions or additional generated methods of the Any type.
           *
           *     Example 1: Pack and unpack a message in C++.
           *
           *         Foo foo = ...;
           *         Any any;
           *         any.PackFrom(foo);
           *         ...
           *         if (any.UnpackTo(&foo)) {
           *           ...
           *         }
           *
           *     Example 2: Pack and unpack a message in Java.
           *
           *         Foo foo = ...;
           *         Any any = Any.pack(foo);
           *         ...
           *         if (any.is(Foo.class)) {
           *           foo = any.unpack(Foo.class);
           *         }
           *
           *      Example 3: Pack and unpack a message in Python.
           *
           *         foo = Foo(...)
           *         any = Any()
           *         any.Pack(foo)
           *         ...
           *         if any.Is(Foo.DESCRIPTOR):
           *           any.Unpack(foo)
           *           ...
           *
           *      Example 4: Pack and unpack a message in Go
           *
           *          foo := &pb.Foo{...}
           *          any, err := anypb.New(foo)
           *          if err != nil {
           *            ...
           *          }
           *          ...
           *          foo := &pb.Foo{}
           *          if err := any.UnmarshalTo(foo); err != nil {
           *            ...
           *          }
           *
           *     The pack methods provided by protobuf library will by default use
           *     'type.googleapis.com/full.type.name' as the type URL and the unpack
           *     methods only use the fully qualified type name after the last '/'
           *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
           *     name "y.z".
           *
           *
           *     JSON
           *     ====
           *     The JSON representation of an `Any` value uses the regular
           *     representation of the deserialized, embedded message, with an
           *     additional field `@type` which contains the type URL. Example:
           *
           *         package google.profile;
           *         message Person {
           *           string first_name = 1;
           *           string last_name = 2;
           *         }
           *
           *         {
           *           "@type": "type.googleapis.com/google.profile.Person",
           *           "firstName": <string>,
           *           "lastName": <string>
           *         }
           *
           *     If the embedded message type is well-known and has a custom JSON
           *     representation, that representation will be embedded adding a field
           *     `value` which holds the custom JSON in addition to the `@type`
           *     field. Example (for message [google.protobuf.Duration][]):
           *
           *         {
           *           "@type": "type.googleapis.com/google.protobuf.Duration",
           *           "value": "1.212s"
           *         } */
          consensus_pubkey?: {
            /** @description A URL/resource name that uniquely identifies the type of the serialized
             *     protocol buffer message. This string must contain at least
             *     one "/" character. The last segment of the URL's path must represent
             *     the fully qualified name of the type (as in
             *     `path/google.protobuf.Duration`). The name should be in a canonical form
             *     (e.g., leading "." is not accepted).
             *
             *     In practice, teams usually precompile into the binary all types that they
             *     expect it to use in the context of Any. However, for URLs which use the
             *     scheme `http`, `https`, or no scheme, one can optionally set up a type
             *     server that maps type URLs to message definitions as follows:
             *
             *     * If no scheme is provided, `https` is assumed.
             *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *       value in binary format, or produce an error.
             *     * Applications are allowed to cache lookup results based on the
             *       URL, or have them precompiled into a binary to avoid any
             *       lookup. Therefore, binary compatibility needs to be preserved
             *       on changes to types. (Use versioned type names to manage
             *       breaking changes.)
             *
             *     Note: this functionality is not currently available in the official
             *     protobuf release, and it is not used for type URLs beginning with
             *     type.googleapis.com.
             *
             *     Schemes other than `http`, `https` (or the empty scheme) might be
             *     used with implementation specific semantics. */
            type_url?: string;
            /**
             * Format: byte
             * @description Must be a valid serialized protocol buffer of the above specified type.
             */
            value?: string;
          };
          /**
           * Format: boolean
           * @description jailed defined whether the validator has been jailed from bonded status or not.
           */
          jailed?: boolean;
          /**
           * @description status is the validator status (bonded/unbonding/unbonded).
           * @default BOND_STATUS_UNSPECIFIED
           * @enum {string}
           */
          status:
            | "BOND_STATUS_UNSPECIFIED"
            | "BOND_STATUS_UNBONDED"
            | "BOND_STATUS_UNBONDING"
            | "BOND_STATUS_BONDED";
          /** @description tokens define the delegated tokens (incl. self-delegation). */
          tokens?: string;
          /** @description delegator_shares defines total shares issued to a validator's delegators. */
          delegator_shares?: string;
          /** @description description defines the description terms for the validator. */
          description?: {
            /** @description moniker defines a human-readable name for the validator. */
            moniker?: string;
            /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
            identity?: string;
            /** @description website defines an optional website link. */
            website?: string;
            /** @description security_contact defines an optional email for security contact. */
            security_contact?: string;
            /** @description details define other optional details. */
            details?: string;
          };
          /**
           * Format: int64
           * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
           */
          unbonding_height?: string;
          /**
           * Format: date-time
           * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
           */
          unbonding_time?: string;
          /** @description commission defines the commission parameters. */
          commission?: {
            /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
            commission_rates?: {
              /** @description rate is the commission rate charged to delegators, as a fraction. */
              rate?: string;
              /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
              max_rate?: string;
              /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
              max_change_rate?: string;
            };
            /**
             * Format: date-time
             * @description update_time is the last time the commission rate was changed.
             */
            update_time?: string;
          };
          /** @description min_self_delegation is the validator's self declared minimum self delegation. */
          min_self_delegation?: string;
        }[];
      };
    };
    /** @description QueryParamsResponse is response type for the Query/Params RPC method. */
    "cosmos.staking.v1beta1.QueryParamsResponse": {
      /** @description params holds all the parameters of this module. */
      params?: {
        /** @description unbonding_time is the time duration of unbonding. */
        unbonding_time?: string;
        /**
         * Format: int64
         * @description max_validators is the maximum number of validators.
         */
        max_validators?: number;
        /**
         * Format: int64
         * @description max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
         */
        max_entries?: number;
        /**
         * Format: int64
         * @description historical_entries is the number of historical entries to persist.
         */
        historical_entries?: number;
        /** @description bond_denom defines the bondable coin denomination. */
        bond_denom?: string;
      };
    };
    /** @description QueryPoolResponse is response type for the Query/Pool RPC method. */
    "cosmos.staking.v1beta1.QueryPoolResponse": {
      /** @description pool defines the pool info. */
      pool?: {
        not_bonded_tokens?: string;
        bonded_tokens?: string;
      };
    };
    /** @description QueryRedelegationsResponse is response type for the Query/Redelegations RPC
     *     method. */
    "cosmos.staking.v1beta1.QueryRedelegationsResponse": {
      redelegation_responses?: {
        /** @description Redelegation contains the list of a particular delegator's redelegating bonds
         *     from a particular source validator to a particular destination validator. */
        redelegation?: {
          /** @description delegator_address is the bech32-encoded address of the delegator. */
          delegator_address?: string;
          /** @description validator_src_address is the validator redelegation source operator address. */
          validator_src_address?: string;
          /** @description validator_dst_address is the validator redelegation destination operator address. */
          validator_dst_address?: string;
          /** @description entries are the redelegation entries. */
          entries?: {
            /**
             * Format: int64
             * @description creation_height  defines the height which the redelegation took place.
             */
            creation_height?: string;
            /**
             * Format: date-time
             * @description completion_time defines the unix time for redelegation completion.
             */
            completion_time?: string;
            /** @description initial_balance defines the initial balance when redelegation started. */
            initial_balance?: string;
            /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
            shares_dst?: string;
          }[];
        };
        entries?: {
          /** @description RedelegationEntry defines a redelegation object with relevant metadata. */
          redelegation_entry?: {
            /**
             * Format: int64
             * @description creation_height  defines the height which the redelegation took place.
             */
            creation_height?: string;
            /**
             * Format: date-time
             * @description completion_time defines the unix time for redelegation completion.
             */
            completion_time?: string;
            /** @description initial_balance defines the initial balance when redelegation started. */
            initial_balance?: string;
            /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
            shares_dst?: string;
          };
          balance?: string;
        }[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryDelegationResponse is response type for the Query/UnbondingDelegation
     *     RPC method. */
    "cosmos.staking.v1beta1.QueryUnbondingDelegationResponse": {
      /** @description UnbondingDelegation stores all of a single delegator's unbonding bonds
       *     for a single validator in an time-ordered list. */
      unbond?: {
        /** @description delegator_address is the bech32-encoded address of the delegator. */
        delegator_address?: string;
        /** @description validator_address is the bech32-encoded address of the validator. */
        validator_address?: string;
        /** @description entries are the unbonding delegation entries. */
        entries?: {
          /**
           * Format: int64
           * @description creation_height is the height which the unbonding took place.
           */
          creation_height?: string;
          /**
           * Format: date-time
           * @description completion_time is the unix time for unbonding completion.
           */
          completion_time?: string;
          /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
          initial_balance?: string;
          /** @description balance defines the tokens to receive at completion. */
          balance?: string;
        }[];
      };
    };
    /** QueryValidatorDelegationsResponse is response type for the
     *     Query/ValidatorDelegations RPC method */
    "cosmos.staking.v1beta1.QueryValidatorDelegationsResponse": {
      delegation_responses?: {
        /** @description Delegation represents the bond with tokens held by an account. It is
         *     owned by one delegator, and is associated with the voting power of one
         *     validator. */
        delegation?: {
          /** @description delegator_address is the bech32-encoded address of the delegator. */
          delegator_address?: string;
          /** @description validator_address is the bech32-encoded address of the validator. */
          validator_address?: string;
          /** @description shares define the delegation shares received. */
          shares?: string;
        };
        /** @description Coin defines a token with a denomination and an amount.
         *
         *     NOTE: The amount field is an Int which implements the custom method
         *     signatures required by gogoproto. */
        balance?: {
          denom?: string;
          amount?: string;
        };
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** QueryValidatorResponse is response type for the Query/Validator RPC method */
    "cosmos.staking.v1beta1.QueryValidatorResponse": {
      /** @description Validator defines a validator, together with the total amount of the
       *     Validator's bond shares and their exchange rate to coins. Slashing results in
       *     a decrease in the exchange rate, allowing correct calculation of future
       *     undelegations without iterating over delegators. When coins are delegated to
       *     this validator, the validator is credited with a delegation whose number of
       *     bond shares is based on the amount of coins delegated divided by the current
       *     exchange rate. Voting power can be calculated as total bonded shares
       *     multiplied by exchange rate. */
      validator?: {
        /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
        operator_address?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        consensus_pubkey?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /**
         * Format: boolean
         * @description jailed defined whether the validator has been jailed from bonded status or not.
         */
        jailed?: boolean;
        /**
         * @description status is the validator status (bonded/unbonding/unbonded).
         * @default BOND_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "BOND_STATUS_UNSPECIFIED"
          | "BOND_STATUS_UNBONDED"
          | "BOND_STATUS_UNBONDING"
          | "BOND_STATUS_BONDED";
        /** @description tokens define the delegated tokens (incl. self-delegation). */
        tokens?: string;
        /** @description delegator_shares defines total shares issued to a validator's delegators. */
        delegator_shares?: string;
        /** @description description defines the description terms for the validator. */
        description?: {
          /** @description moniker defines a human-readable name for the validator. */
          moniker?: string;
          /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
          identity?: string;
          /** @description website defines an optional website link. */
          website?: string;
          /** @description security_contact defines an optional email for security contact. */
          security_contact?: string;
          /** @description details define other optional details. */
          details?: string;
        };
        /**
         * Format: int64
         * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
         */
        unbonding_height?: string;
        /**
         * Format: date-time
         * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
         */
        unbonding_time?: string;
        /** @description commission defines the commission parameters. */
        commission?: {
          /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
          commission_rates?: {
            /** @description rate is the commission rate charged to delegators, as a fraction. */
            rate?: string;
            /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
            max_rate?: string;
            /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
            max_change_rate?: string;
          };
          /**
           * Format: date-time
           * @description update_time is the last time the commission rate was changed.
           */
          update_time?: string;
        };
        /** @description min_self_delegation is the validator's self declared minimum self delegation. */
        min_self_delegation?: string;
      };
    };
    /** @description QueryValidatorUnbondingDelegationsResponse is response type for the
     *     Query/ValidatorUnbondingDelegations RPC method. */
    "cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse": {
      unbonding_responses?: {
        /** @description delegator_address is the bech32-encoded address of the delegator. */
        delegator_address?: string;
        /** @description validator_address is the bech32-encoded address of the validator. */
        validator_address?: string;
        /** @description entries are the unbonding delegation entries. */
        entries?: {
          /**
           * Format: int64
           * @description creation_height is the height which the unbonding took place.
           */
          creation_height?: string;
          /**
           * Format: date-time
           * @description completion_time is the unix time for unbonding completion.
           */
          completion_time?: string;
          /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
          initial_balance?: string;
          /** @description balance defines the tokens to receive at completion. */
          balance?: string;
        }[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** QueryValidatorsResponse is response type for the Query/Validators RPC method */
    "cosmos.staking.v1beta1.QueryValidatorsResponse": {
      /** @description validators contains all the queried validators. */
      validators?: {
        /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
        operator_address?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        consensus_pubkey?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /**
         * Format: boolean
         * @description jailed defined whether the validator has been jailed from bonded status or not.
         */
        jailed?: boolean;
        /**
         * @description status is the validator status (bonded/unbonding/unbonded).
         * @default BOND_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status:
          | "BOND_STATUS_UNSPECIFIED"
          | "BOND_STATUS_UNBONDED"
          | "BOND_STATUS_UNBONDING"
          | "BOND_STATUS_BONDED";
        /** @description tokens define the delegated tokens (incl. self-delegation). */
        tokens?: string;
        /** @description delegator_shares defines total shares issued to a validator's delegators. */
        delegator_shares?: string;
        /** @description description defines the description terms for the validator. */
        description?: {
          /** @description moniker defines a human-readable name for the validator. */
          moniker?: string;
          /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
          identity?: string;
          /** @description website defines an optional website link. */
          website?: string;
          /** @description security_contact defines an optional email for security contact. */
          security_contact?: string;
          /** @description details define other optional details. */
          details?: string;
        };
        /**
         * Format: int64
         * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
         */
        unbonding_height?: string;
        /**
         * Format: date-time
         * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
         */
        unbonding_time?: string;
        /** @description commission defines the commission parameters. */
        commission?: {
          /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
          commission_rates?: {
            /** @description rate is the commission rate charged to delegators, as a fraction. */
            rate?: string;
            /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
            max_rate?: string;
            /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
            max_change_rate?: string;
          };
          /**
           * Format: date-time
           * @description update_time is the last time the commission rate was changed.
           */
          update_time?: string;
        };
        /** @description min_self_delegation is the validator's self declared minimum self delegation. */
        min_self_delegation?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description Redelegation contains the list of a particular delegator's redelegating bonds
     *     from a particular source validator to a particular destination validator. */
    "cosmos.staking.v1beta1.Redelegation": {
      /** @description delegator_address is the bech32-encoded address of the delegator. */
      delegator_address?: string;
      /** @description validator_src_address is the validator redelegation source operator address. */
      validator_src_address?: string;
      /** @description validator_dst_address is the validator redelegation destination operator address. */
      validator_dst_address?: string;
      /** @description entries are the redelegation entries. */
      entries?: {
        /**
         * Format: int64
         * @description creation_height  defines the height which the redelegation took place.
         */
        creation_height?: string;
        /**
         * Format: date-time
         * @description completion_time defines the unix time for redelegation completion.
         */
        completion_time?: string;
        /** @description initial_balance defines the initial balance when redelegation started. */
        initial_balance?: string;
        /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
        shares_dst?: string;
      }[];
    };
    /** @description RedelegationEntry defines a redelegation object with relevant metadata. */
    "cosmos.staking.v1beta1.RedelegationEntry": {
      /**
       * Format: int64
       * @description creation_height  defines the height which the redelegation took place.
       */
      creation_height?: string;
      /**
       * Format: date-time
       * @description completion_time defines the unix time for redelegation completion.
       */
      completion_time?: string;
      /** @description initial_balance defines the initial balance when redelegation started. */
      initial_balance?: string;
      /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
      shares_dst?: string;
    };
    /** @description RedelegationEntryResponse is equivalent to a RedelegationEntry except that it
     *     contains a balance in addition to shares which is more suitable for client
     *     responses. */
    "cosmos.staking.v1beta1.RedelegationEntryResponse": {
      /** @description RedelegationEntry defines a redelegation object with relevant metadata. */
      redelegation_entry?: {
        /**
         * Format: int64
         * @description creation_height  defines the height which the redelegation took place.
         */
        creation_height?: string;
        /**
         * Format: date-time
         * @description completion_time defines the unix time for redelegation completion.
         */
        completion_time?: string;
        /** @description initial_balance defines the initial balance when redelegation started. */
        initial_balance?: string;
        /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
        shares_dst?: string;
      };
      balance?: string;
    };
    /** @description RedelegationResponse is equivalent to a Redelegation except that its entries
     *     contain a balance in addition to shares which is more suitable for client
     *     responses. */
    "cosmos.staking.v1beta1.RedelegationResponse": {
      /** @description Redelegation contains the list of a particular delegator's redelegating bonds
       *     from a particular source validator to a particular destination validator. */
      redelegation?: {
        /** @description delegator_address is the bech32-encoded address of the delegator. */
        delegator_address?: string;
        /** @description validator_src_address is the validator redelegation source operator address. */
        validator_src_address?: string;
        /** @description validator_dst_address is the validator redelegation destination operator address. */
        validator_dst_address?: string;
        /** @description entries are the redelegation entries. */
        entries?: {
          /**
           * Format: int64
           * @description creation_height  defines the height which the redelegation took place.
           */
          creation_height?: string;
          /**
           * Format: date-time
           * @description completion_time defines the unix time for redelegation completion.
           */
          completion_time?: string;
          /** @description initial_balance defines the initial balance when redelegation started. */
          initial_balance?: string;
          /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
          shares_dst?: string;
        }[];
      };
      entries?: {
        /** @description RedelegationEntry defines a redelegation object with relevant metadata. */
        redelegation_entry?: {
          /**
           * Format: int64
           * @description creation_height  defines the height which the redelegation took place.
           */
          creation_height?: string;
          /**
           * Format: date-time
           * @description completion_time defines the unix time for redelegation completion.
           */
          completion_time?: string;
          /** @description initial_balance defines the initial balance when redelegation started. */
          initial_balance?: string;
          /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
          shares_dst?: string;
        };
        balance?: string;
      }[];
    };
    /** @description UnbondingDelegation stores all of a single delegator's unbonding bonds
     *     for a single validator in an time-ordered list. */
    "cosmos.staking.v1beta1.UnbondingDelegation": {
      /** @description delegator_address is the bech32-encoded address of the delegator. */
      delegator_address?: string;
      /** @description validator_address is the bech32-encoded address of the validator. */
      validator_address?: string;
      /** @description entries are the unbonding delegation entries. */
      entries?: {
        /**
         * Format: int64
         * @description creation_height is the height which the unbonding took place.
         */
        creation_height?: string;
        /**
         * Format: date-time
         * @description completion_time is the unix time for unbonding completion.
         */
        completion_time?: string;
        /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
        initial_balance?: string;
        /** @description balance defines the tokens to receive at completion. */
        balance?: string;
      }[];
    };
    /** @description UnbondingDelegationEntry defines an unbonding object with relevant metadata. */
    "cosmos.staking.v1beta1.UnbondingDelegationEntry": {
      /**
       * Format: int64
       * @description creation_height is the height which the unbonding took place.
       */
      creation_height?: string;
      /**
       * Format: date-time
       * @description completion_time is the unix time for unbonding completion.
       */
      completion_time?: string;
      /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
      initial_balance?: string;
      /** @description balance defines the tokens to receive at completion. */
      balance?: string;
    };
    /** @description Validator defines a validator, together with the total amount of the
     *     Validator's bond shares and their exchange rate to coins. Slashing results in
     *     a decrease in the exchange rate, allowing correct calculation of future
     *     undelegations without iterating over delegators. When coins are delegated to
     *     this validator, the validator is credited with a delegation whose number of
     *     bond shares is based on the amount of coins delegated divided by the current
     *     exchange rate. Voting power can be calculated as total bonded shares
     *     multiplied by exchange rate. */
    "cosmos.staking.v1beta1.Validator": {
      /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
      operator_address?: string;
      /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         } */
      consensus_pubkey?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /**
       * Format: boolean
       * @description jailed defined whether the validator has been jailed from bonded status or not.
       */
      jailed?: boolean;
      /**
       * @description status is the validator status (bonded/unbonding/unbonded).
       * @default BOND_STATUS_UNSPECIFIED
       * @enum {string}
       */
      status:
        | "BOND_STATUS_UNSPECIFIED"
        | "BOND_STATUS_UNBONDED"
        | "BOND_STATUS_UNBONDING"
        | "BOND_STATUS_BONDED";
      /** @description tokens define the delegated tokens (incl. self-delegation). */
      tokens?: string;
      /** @description delegator_shares defines total shares issued to a validator's delegators. */
      delegator_shares?: string;
      /** @description description defines the description terms for the validator. */
      description?: {
        /** @description moniker defines a human-readable name for the validator. */
        moniker?: string;
        /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
        identity?: string;
        /** @description website defines an optional website link. */
        website?: string;
        /** @description security_contact defines an optional email for security contact. */
        security_contact?: string;
        /** @description details define other optional details. */
        details?: string;
      };
      /**
       * Format: int64
       * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
       */
      unbonding_height?: string;
      /**
       * Format: date-time
       * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
       */
      unbonding_time?: string;
      /** @description commission defines the commission parameters. */
      commission?: {
        /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
        commission_rates?: {
          /** @description rate is the commission rate charged to delegators, as a fraction. */
          rate?: string;
          /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
          max_rate?: string;
          /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
          max_change_rate?: string;
        };
        /**
         * Format: date-time
         * @description update_time is the last time the commission rate was changed.
         */
        update_time?: string;
      };
      /** @description min_self_delegation is the validator's self declared minimum self delegation. */
      min_self_delegation?: string;
    };
    /** @description ABCIMessageLog defines a structure containing an indexed tx ABCI message log. */
    "cosmos.base.abci.v1beta1.ABCIMessageLog": {
      /** Format: int64 */
      msg_index?: number;
      log?: string;
      /** @description Events contains a slice of Event objects that were emitted during some
       *     execution. */
      events?: {
        type?: string;
        attributes?: {
          key?: string;
          value?: string;
        }[];
      }[];
    };
    /** @description Attribute defines an attribute wrapper where the key and value are
     *     strings instead of raw bytes. */
    "cosmos.base.abci.v1beta1.Attribute": {
      key?: string;
      value?: string;
    };
    /** @description GasInfo defines tx execution gas context. */
    "cosmos.base.abci.v1beta1.GasInfo": {
      /**
       * Format: uint64
       * @description GasWanted is the maximum units of work we allow this tx to perform.
       */
      gas_wanted?: string;
      /**
       * Format: uint64
       * @description GasUsed is the amount of gas actually consumed.
       */
      gas_used?: string;
    };
    /** @description Result is the union of ResponseFormat and ResponseCheckTx. */
    "cosmos.base.abci.v1beta1.Result": {
      /**
       * Format: byte
       * @description Data is any data returned from message or handler execution. It MUST be
       *     length prefixed in order to separate data from multiple message executions.
       */
      data?: string;
      /** @description Log contains the log information from message or handler execution. */
      log?: string;
      /** @description Events contains a slice of Event objects that were emitted during message
       *     or handler execution. */
      events?: {
        type?: string;
        attributes?: {
          /** Format: byte */
          key?: string;
          /** Format: byte */
          value?: string;
          /** Format: boolean */
          index?: boolean;
        }[];
      }[];
    };
    /** @description StringEvent defines en Event object wrapper where all the attributes
     *     contain key/value pairs that are strings instead of raw bytes. */
    "cosmos.base.abci.v1beta1.StringEvent": {
      type?: string;
      attributes?: {
        key?: string;
        value?: string;
      }[];
    };
    /** @description TxResponse defines a structure containing relevant tx data and metadata. The
     *     tags are stringified and the log is JSON decoded. */
    "cosmos.base.abci.v1beta1.TxResponse": {
      /**
       * The block height
       * Format: int64
       */
      height?: string;
      /** @description The transaction hash. */
      txhash?: string;
      /** Namespace for the Code */
      codespace?: string;
      /**
       * Format: int64
       * @description Response code.
       */
      code?: number;
      /** @description Result bytes, if any. */
      data?: string;
      /** @description The output of the application's logger (raw string). May be
       *     non-deterministic. */
      raw_log?: string;
      /** @description The output of the application's logger (typed). May be non-deterministic. */
      logs?: {
        /** Format: int64 */
        msg_index?: number;
        log?: string;
        /** @description Events contains a slice of Event objects that were emitted during some
         *     execution. */
        events?: {
          type?: string;
          attributes?: {
            key?: string;
            value?: string;
          }[];
        }[];
      }[];
      /** @description Additional information. May be non-deterministic. */
      info?: string;
      /**
       * Format: int64
       * @description Amount of gas requested for transaction.
       */
      gas_wanted?: string;
      /**
       * Format: int64
       * @description Amount of gas consumed by transaction.
       */
      gas_used?: string;
      /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         } */
      tx?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /** @description Time of the previous block. For heights > 1, it's the weighted median of
       *     the timestamps of the valid votes in the block.LastCommit. For height == 1,
       *     it's genesis time. */
      timestamp?: string;
      /** @description Events defines all the events emitted by processing a transaction. Note,
       *     these events include those emitted by processing all the messages and those
       *     emitted from the ante handler. Whereas Logs contains the events, with
       *     additional metadata, emitted only by processing the messages.
       *
       *     Since: cosmos-sdk 0.42.11, 0.44.5, 0.45 */
      events?: {
        type?: string;
        attributes?: {
          /** Format: byte */
          key?: string;
          /** Format: byte */
          value?: string;
          /** Format: boolean */
          index?: boolean;
        }[];
      }[];
    };
    /** @description CompactBitArray is an implementation of a space efficient bit array.
     *     This is used to ensure that the encoded data takes up a minimal amount of
     *     space after proto encoding.
     *     This is not thread safe, and is not intended for concurrent usage. */
    "cosmos.crypto.multisig.v1beta1.CompactBitArray": {
      /** Format: int64 */
      extra_bits_stored?: number;
      /** Format: byte */
      elems?: string;
    };
    /**
     * @description SignMode represents a signing mode with its own security guarantees.
     *
     *      - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
     *     rejected
     *      - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
     *     verified with raw bytes from Tx
     *      - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some
     *     human-readable textual representation on top of the binary representation
     *     from SIGN_MODE_DIRECT
     *      - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
     *     Amino JSON and will be removed in the future
     *      - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos
     *     SDK. Ref: https://eips.ethereum.org/EIPS/eip-191
     *
     *     Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,
     *     but is not implemented on the SDK by default. To enable EIP-191, you need
     *     to pass a custom `TxConfig` that has an implementation of
     *     `SignModeHandler` for EIP-191. The SDK may decide to fully support
     *     EIP-191 in the future.
     *
     *     Since: cosmos-sdk 0.45.2
     * @default SIGN_MODE_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.tx.signing.v1beta1.SignMode":
      | "SIGN_MODE_UNSPECIFIED"
      | "SIGN_MODE_DIRECT"
      | "SIGN_MODE_TEXTUAL"
      | "SIGN_MODE_LEGACY_AMINO_JSON"
      | "SIGN_MODE_EIP_191";
    /** @description AuthInfo describes the fee and signer modes that are used to sign a
     *     transaction. */
    "cosmos.tx.v1beta1.AuthInfo": {
      /** @description signer_infos defines the signing modes for the required signers. The number
       *     and order of elements must match the required signers from TxBody's
       *     messages. The first element is the primary signer and the one which pays
       *     the fee. */
      signer_infos?: components["schemas"]["cosmos.tx.v1beta1.SignerInfo"][];
      /** @description Fee is the fee and gas limit for the transaction. The first signer is the
       *     primary signer and the one which pays the fee. The fee can be calculated
       *     based on the cost of evaluating the body and doing signature verification
       *     of the signers. This can be estimated via simulation. */
      fee?: {
        /** amount is the amount of coins to be paid as a fee */
        amount?: {
          denom?: string;
          amount?: string;
        }[];
        /**
         * gas_limit is the maximum gas that can be used in transaction processing
         *     before an out of gas error occurs
         * Format: uint64
         */
        gas_limit?: string;
        /** @description if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
         *     the payer must be a tx signer (and thus have signed this field in AuthInfo).
         *     setting this field does *not* change the ordering of required signers for the transaction. */
        payer?: string;
        /** if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
         *     to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
         *     not support fee grants, this will fail */
        granter?: string;
      };
    };
    /**
     * @description BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.
     *
     *      - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering
     *      - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for
     *     the tx to be committed in a block.
     *      - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for
     *     a CheckTx execution response only.
     *      - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns
     *     immediately.
     * @default BROADCAST_MODE_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.tx.v1beta1.BroadcastMode":
      | "BROADCAST_MODE_UNSPECIFIED"
      | "BROADCAST_MODE_BLOCK"
      | "BROADCAST_MODE_SYNC"
      | "BROADCAST_MODE_ASYNC";
    /** @description BroadcastTxRequest is the request type for the Service.BroadcastTxRequest
     *     RPC method. */
    "cosmos.tx.v1beta1.BroadcastTxRequest": {
      /**
       * Format: byte
       * @description tx_bytes is the raw transaction.
       */
      tx_bytes?: string;
      /**
       * @description BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.
       *
       *      - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering
       *      - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for
       *     the tx to be committed in a block.
       *      - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for
       *     a CheckTx execution response only.
       *      - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns
       *     immediately.
       * @default BROADCAST_MODE_UNSPECIFIED
       * @enum {string}
       */
      mode:
        | "BROADCAST_MODE_UNSPECIFIED"
        | "BROADCAST_MODE_BLOCK"
        | "BROADCAST_MODE_SYNC"
        | "BROADCAST_MODE_ASYNC";
    };
    /** @description BroadcastTxResponse is the response type for the
     *     Service.BroadcastTx method. */
    "cosmos.tx.v1beta1.BroadcastTxResponse": {
      /** @description TxResponse defines a structure containing relevant tx data and metadata. The
       *     tags are stringified and the log is JSON decoded. */
      tx_response?: {
        /**
         * The block height
         * Format: int64
         */
        height?: string;
        /** @description The transaction hash. */
        txhash?: string;
        /** Namespace for the Code */
        codespace?: string;
        /**
         * Format: int64
         * @description Response code.
         */
        code?: number;
        /** @description Result bytes, if any. */
        data?: string;
        /** @description The output of the application's logger (raw string). May be
         *     non-deterministic. */
        raw_log?: string;
        /** @description The output of the application's logger (typed). May be non-deterministic. */
        logs?: {
          /** Format: int64 */
          msg_index?: number;
          log?: string;
          /** @description Events contains a slice of Event objects that were emitted during some
           *     execution. */
          events?: {
            type?: string;
            attributes?: {
              key?: string;
              value?: string;
            }[];
          }[];
        }[];
        /** @description Additional information. May be non-deterministic. */
        info?: string;
        /**
         * Format: int64
         * @description Amount of gas requested for transaction.
         */
        gas_wanted?: string;
        /**
         * Format: int64
         * @description Amount of gas consumed by transaction.
         */
        gas_used?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        tx?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** @description Time of the previous block. For heights > 1, it's the weighted median of
         *     the timestamps of the valid votes in the block.LastCommit. For height == 1,
         *     it's genesis time. */
        timestamp?: string;
        /** @description Events defines all the events emitted by processing a transaction. Note,
         *     these events include those emitted by processing all the messages and those
         *     emitted from the ante handler. Whereas Logs contains the events, with
         *     additional metadata, emitted only by processing the messages.
         *
         *     Since: cosmos-sdk 0.42.11, 0.44.5, 0.45 */
        events?: {
          type?: string;
          attributes?: {
            /** Format: byte */
            key?: string;
            /** Format: byte */
            value?: string;
            /** Format: boolean */
            index?: boolean;
          }[];
        }[];
      };
    };
    /** @description Fee includes the amount of coins paid in fees and the maximum
     *     gas to be used by the transaction. The ratio yields an effective "gasprice",
     *     which must be above some miminum to be accepted into the mempool. */
    "cosmos.tx.v1beta1.Fee": {
      /** amount is the amount of coins to be paid as a fee */
      amount?: {
        denom?: string;
        amount?: string;
      }[];
      /**
       * gas_limit is the maximum gas that can be used in transaction processing
       *     before an out of gas error occurs
       * Format: uint64
       */
      gas_limit?: string;
      /** @description if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
       *     the payer must be a tx signer (and thus have signed this field in AuthInfo).
       *     setting this field does *not* change the ordering of required signers for the transaction. */
      payer?: string;
      /** if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
       *     to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
       *     not support fee grants, this will fail */
      granter?: string;
    };
    /** @description GetBlockWithTxsResponse is the response type for the Service.GetBlockWithTxs method.
     *
     *     Since: cosmos-sdk 0.45.2 */
    "cosmos.tx.v1beta1.GetBlockWithTxsResponse": {
      /** @description txs are the transactions in the block. */
      txs?: components["schemas"]["cosmos.tx.v1beta1.Tx"][];
      /** BlockID */
      block_id?: {
        /** Format: byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** Format: int64 */
          total?: number;
          /** Format: byte */
          hash?: string;
        };
      };
      block?: {
        /** @description Header defines the structure of a block header. */
        header?: {
          /**
           * basic block info
           * @description Consensus captures the consensus rules for processing a block in the blockchain,
           *     including all blockchain data structures and the rules of the application's
           *     state transition machine.
           */
          version?: {
            /** Format: uint64 */
            block?: string;
            /** Format: uint64 */
            app?: string;
          };
          chain_id?: string;
          /** Format: int64 */
          height?: string;
          /** Format: date-time */
          time?: string;
          /** BlockID */
          last_block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /**
           * hashes of block data
           * Format: byte
           */
          last_commit_hash?: string;
          /** Format: byte */
          data_hash?: string;
          /**
           * hashes from the app output from the prev block
           * Format: byte
           */
          validators_hash?: string;
          /** Format: byte */
          next_validators_hash?: string;
          /** Format: byte */
          consensus_hash?: string;
          /** Format: byte */
          app_hash?: string;
          /** Format: byte */
          last_results_hash?: string;
          /**
           * consensus info
           * Format: byte
           */
          evidence_hash?: string;
          /** Format: byte */
          proposer_address?: string;
        };
        /** Data contains the set of transactions included in the block */
        data?: {
          /** @description Txs that will be applied by state @ block.Height+1.
           *     NOTE: not all txs here are valid.  We're just agreeing on the order first.
           *     This means that block.AppHash does not include these txs. */
          txs?: string[];
        };
        evidence?: {
          evidence?: {
            /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
            duplicate_vote_evidence?: {
              /** @description Vote represents a prevote, precommit, or commit vote from validators for
               *     consensus. */
              vote_a?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *      - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /** Format: byte */
                signature?: string;
              };
              /** @description Vote represents a prevote, precommit, or commit vote from validators for
               *     consensus. */
              vote_b?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *      - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /** Format: byte */
                signature?: string;
              };
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: int64 */
              validator_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
            /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
            light_client_attack_evidence?: {
              conflicting_block?: {
                signed_header?: {
                  /** @description Header defines the structure of a block header. */
                  header?: {
                    /**
                     * basic block info
                     * @description Consensus captures the consensus rules for processing a block in the blockchain,
                     *     including all blockchain data structures and the rules of the application's
                     *     state transition machine.
                     */
                    version?: {
                      /** Format: uint64 */
                      block?: string;
                      /** Format: uint64 */
                      app?: string;
                    };
                    chain_id?: string;
                    /** Format: int64 */
                    height?: string;
                    /** Format: date-time */
                    time?: string;
                    /** BlockID */
                    last_block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    /**
                     * hashes of block data
                     * Format: byte
                     */
                    last_commit_hash?: string;
                    /** Format: byte */
                    data_hash?: string;
                    /**
                     * hashes from the app output from the prev block
                     * Format: byte
                     */
                    validators_hash?: string;
                    /** Format: byte */
                    next_validators_hash?: string;
                    /** Format: byte */
                    consensus_hash?: string;
                    /** Format: byte */
                    app_hash?: string;
                    /** Format: byte */
                    last_results_hash?: string;
                    /**
                     * consensus info
                     * Format: byte
                     */
                    evidence_hash?: string;
                    /** Format: byte */
                    proposer_address?: string;
                  };
                  /** @description Commit contains the evidence that a block was committed by a set of validators. */
                  commit?: {
                    /** Format: int64 */
                    height?: string;
                    /** Format: int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    signatures?: {
                      /**
                       * BlockIdFlag indicates which BlcokID the signature is for
                       * @default BLOCK_ID_FLAG_UNKNOWN
                       * @enum {string}
                       */
                      block_id_flag:
                        | "BLOCK_ID_FLAG_UNKNOWN"
                        | "BLOCK_ID_FLAG_ABSENT"
                        | "BLOCK_ID_FLAG_COMMIT"
                        | "BLOCK_ID_FLAG_NIL";
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      signature?: string;
                    }[];
                  };
                };
                validator_set?: {
                  validators?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  }[];
                  proposer?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  };
                  /** Format: int64 */
                  total_voting_power?: string;
                };
              };
              /** Format: int64 */
              common_height?: string;
              byzantine_validators?: {
                /** Format: byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** Format: byte */
                  ed25519?: string;
                  /** Format: byte */
                  secp256k1?: string;
                };
                /** Format: int64 */
                voting_power?: string;
                /** Format: int64 */
                proposer_priority?: string;
              }[];
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
          }[];
        };
        /** @description Commit contains the evidence that a block was committed by a set of validators. */
        last_commit?: {
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          signatures?: {
            /**
             * BlockIdFlag indicates which BlcokID the signature is for
             * @default BLOCK_ID_FLAG_UNKNOWN
             * @enum {string}
             */
            block_id_flag:
              | "BLOCK_ID_FLAG_UNKNOWN"
              | "BLOCK_ID_FLAG_ABSENT"
              | "BLOCK_ID_FLAG_COMMIT"
              | "BLOCK_ID_FLAG_NIL";
            /** Format: byte */
            validator_address?: string;
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            signature?: string;
          }[];
        };
      };
      /** @description pagination defines a pagination for the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description GetTxResponse is the response type for the Service.GetTx method. */
    "cosmos.tx.v1beta1.GetTxResponse": {
      tx?: components["schemas"]["cosmos.tx.v1beta1.Tx"];
      /** @description TxResponse defines a structure containing relevant tx data and metadata. The
       *     tags are stringified and the log is JSON decoded. */
      tx_response?: {
        /**
         * The block height
         * Format: int64
         */
        height?: string;
        /** @description The transaction hash. */
        txhash?: string;
        /** Namespace for the Code */
        codespace?: string;
        /**
         * Format: int64
         * @description Response code.
         */
        code?: number;
        /** @description Result bytes, if any. */
        data?: string;
        /** @description The output of the application's logger (raw string). May be
         *     non-deterministic. */
        raw_log?: string;
        /** @description The output of the application's logger (typed). May be non-deterministic. */
        logs?: {
          /** Format: int64 */
          msg_index?: number;
          log?: string;
          /** @description Events contains a slice of Event objects that were emitted during some
           *     execution. */
          events?: {
            type?: string;
            attributes?: {
              key?: string;
              value?: string;
            }[];
          }[];
        }[];
        /** @description Additional information. May be non-deterministic. */
        info?: string;
        /**
         * Format: int64
         * @description Amount of gas requested for transaction.
         */
        gas_wanted?: string;
        /**
         * Format: int64
         * @description Amount of gas consumed by transaction.
         */
        gas_used?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        tx?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** @description Time of the previous block. For heights > 1, it's the weighted median of
         *     the timestamps of the valid votes in the block.LastCommit. For height == 1,
         *     it's genesis time. */
        timestamp?: string;
        /** @description Events defines all the events emitted by processing a transaction. Note,
         *     these events include those emitted by processing all the messages and those
         *     emitted from the ante handler. Whereas Logs contains the events, with
         *     additional metadata, emitted only by processing the messages.
         *
         *     Since: cosmos-sdk 0.42.11, 0.44.5, 0.45 */
        events?: {
          type?: string;
          attributes?: {
            /** Format: byte */
            key?: string;
            /** Format: byte */
            value?: string;
            /** Format: boolean */
            index?: boolean;
          }[];
        }[];
      };
    };
    /** @description GetTxsEventResponse is the response type for the Service.TxsByEvents
     *     RPC method. */
    "cosmos.tx.v1beta1.GetTxsEventResponse": {
      /** @description txs is the list of queried transactions. */
      txs?: components["schemas"]["cosmos.tx.v1beta1.Tx"][];
      /** @description tx_responses is the list of queried TxResponses. */
      tx_responses?: {
        /**
         * The block height
         * Format: int64
         */
        height?: string;
        /** @description The transaction hash. */
        txhash?: string;
        /** Namespace for the Code */
        codespace?: string;
        /**
         * Format: int64
         * @description Response code.
         */
        code?: number;
        /** @description Result bytes, if any. */
        data?: string;
        /** @description The output of the application's logger (raw string). May be
         *     non-deterministic. */
        raw_log?: string;
        /** @description The output of the application's logger (typed). May be non-deterministic. */
        logs?: {
          /** Format: int64 */
          msg_index?: number;
          log?: string;
          /** @description Events contains a slice of Event objects that were emitted during some
           *     execution. */
          events?: {
            type?: string;
            attributes?: {
              key?: string;
              value?: string;
            }[];
          }[];
        }[];
        /** @description Additional information. May be non-deterministic. */
        info?: string;
        /**
         * Format: int64
         * @description Amount of gas requested for transaction.
         */
        gas_wanted?: string;
        /**
         * Format: int64
         * @description Amount of gas consumed by transaction.
         */
        gas_used?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        tx?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** @description Time of the previous block. For heights > 1, it's the weighted median of
         *     the timestamps of the valid votes in the block.LastCommit. For height == 1,
         *     it's genesis time. */
        timestamp?: string;
        /** @description Events defines all the events emitted by processing a transaction. Note,
         *     these events include those emitted by processing all the messages and those
         *     emitted from the ante handler. Whereas Logs contains the events, with
         *     additional metadata, emitted only by processing the messages.
         *
         *     Since: cosmos-sdk 0.42.11, 0.44.5, 0.45 */
        events?: {
          type?: string;
          attributes?: {
            /** Format: byte */
            key?: string;
            /** Format: byte */
            value?: string;
            /** Format: boolean */
            index?: boolean;
          }[];
        }[];
      }[];
      /** @description pagination defines a pagination for the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description ModeInfo describes the signing mode of a single or nested multisig signer. */
    "cosmos.tx.v1beta1.ModeInfo": {
      /** single represents a single signer */
      single?: {
        /**
         * mode is the signing mode of the single signer
         * @description SignMode represents a signing mode with its own security guarantees.
         *
         *      - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
         *     rejected
         *      - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
         *     verified with raw bytes from Tx
         *      - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some
         *     human-readable textual representation on top of the binary representation
         *     from SIGN_MODE_DIRECT
         *      - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
         *     Amino JSON and will be removed in the future
         *      - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos
         *     SDK. Ref: https://eips.ethereum.org/EIPS/eip-191
         *
         *     Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,
         *     but is not implemented on the SDK by default. To enable EIP-191, you need
         *     to pass a custom `TxConfig` that has an implementation of
         *     `SignModeHandler` for EIP-191. The SDK may decide to fully support
         *     EIP-191 in the future.
         *
         *     Since: cosmos-sdk 0.45.2
         * @default SIGN_MODE_UNSPECIFIED
         * @enum {string}
         */
        mode:
          | "SIGN_MODE_UNSPECIFIED"
          | "SIGN_MODE_DIRECT"
          | "SIGN_MODE_TEXTUAL"
          | "SIGN_MODE_LEGACY_AMINO_JSON"
          | "SIGN_MODE_EIP_191";
      };
      multi?: components["schemas"]["cosmos.tx.v1beta1.ModeInfo.Multi"];
    };
    /** Multi is the mode info for a multisig public key */
    "cosmos.tx.v1beta1.ModeInfo.Multi": {
      /**
       * bitarray specifies which keys within the multisig are signing
       * @description CompactBitArray is an implementation of a space efficient bit array.
       *     This is used to ensure that the encoded data takes up a minimal amount of
       *     space after proto encoding.
       *     This is not thread safe, and is not intended for concurrent usage.
       */
      bitarray?: {
        /** Format: int64 */
        extra_bits_stored?: number;
        /** Format: byte */
        elems?: string;
      };
      /** mode_infos is the corresponding modes of the signers of the multisig
       *     which could include nested multisig public keys */
      mode_infos?: components["schemas"]["cosmos.tx.v1beta1.ModeInfo"][];
    };
    /** Single is the mode info for a single signer. It is structured as a message
     *     to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
     *     future */
    "cosmos.tx.v1beta1.ModeInfo.Single": {
      /**
       * mode is the signing mode of the single signer
       * @description SignMode represents a signing mode with its own security guarantees.
       *
       *      - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
       *     rejected
       *      - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
       *     verified with raw bytes from Tx
       *      - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some
       *     human-readable textual representation on top of the binary representation
       *     from SIGN_MODE_DIRECT
       *      - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
       *     Amino JSON and will be removed in the future
       *      - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos
       *     SDK. Ref: https://eips.ethereum.org/EIPS/eip-191
       *
       *     Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,
       *     but is not implemented on the SDK by default. To enable EIP-191, you need
       *     to pass a custom `TxConfig` that has an implementation of
       *     `SignModeHandler` for EIP-191. The SDK may decide to fully support
       *     EIP-191 in the future.
       *
       *     Since: cosmos-sdk 0.45.2
       * @default SIGN_MODE_UNSPECIFIED
       * @enum {string}
       */
      mode:
        | "SIGN_MODE_UNSPECIFIED"
        | "SIGN_MODE_DIRECT"
        | "SIGN_MODE_TEXTUAL"
        | "SIGN_MODE_LEGACY_AMINO_JSON"
        | "SIGN_MODE_EIP_191";
    };
    /**
     * OrderBy defines the sorting order
     * @description - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.
     *      - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order
     *      - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
     * @default ORDER_BY_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.tx.v1beta1.OrderBy":
      | "ORDER_BY_UNSPECIFIED"
      | "ORDER_BY_ASC"
      | "ORDER_BY_DESC";
    /** @description SignerInfo describes the public key and signing mode of a single top-level
     *     signer. */
    "cosmos.tx.v1beta1.SignerInfo": {
      /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         } */
      public_key?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      mode_info?: components["schemas"]["cosmos.tx.v1beta1.ModeInfo"];
      /**
       * Format: uint64
       * @description sequence is the sequence of the account, which describes the
       *     number of committed transactions signed by a given address. It is used to
       *     prevent replay attacks.
       */
      sequence?: string;
    };
    /** @description SimulateRequest is the request type for the Service.Simulate
     *     RPC method. */
    "cosmos.tx.v1beta1.SimulateRequest": {
      tx?: components["schemas"]["cosmos.tx.v1beta1.Tx"];
      /**
       * Format: byte
       * @description tx_bytes is the raw transaction.
       *
       *     Since: cosmos-sdk 0.43
       */
      tx_bytes?: string;
    };
    /** @description SimulateResponse is the response type for the
     *     Service.SimulateRPC method. */
    "cosmos.tx.v1beta1.SimulateResponse": {
      /** @description gas_info is the information about gas used in the simulation. */
      gas_info?: {
        /**
         * Format: uint64
         * @description GasWanted is the maximum units of work we allow this tx to perform.
         */
        gas_wanted?: string;
        /**
         * Format: uint64
         * @description GasUsed is the amount of gas actually consumed.
         */
        gas_used?: string;
      };
      /** @description result is the result of the simulation. */
      result?: {
        /**
         * Format: byte
         * @description Data is any data returned from message or handler execution. It MUST be
         *     length prefixed in order to separate data from multiple message executions.
         */
        data?: string;
        /** @description Log contains the log information from message or handler execution. */
        log?: string;
        /** @description Events contains a slice of Event objects that were emitted during message
         *     or handler execution. */
        events?: {
          type?: string;
          attributes?: {
            /** Format: byte */
            key?: string;
            /** Format: byte */
            value?: string;
            /** Format: boolean */
            index?: boolean;
          }[];
        }[];
      };
    };
    /** @description Tx is the standard type used for broadcasting transactions. */
    "cosmos.tx.v1beta1.Tx": {
      /**
       * body is the processable content of the transaction
       * @description TxBody is the body of a transaction that all signers sign over.
       */
      body?: {
        /** @description messages is a list of messages to be executed. The required signers of
         *     those messages define the number and order of elements in AuthInfo's
         *     signer_infos and Tx's signatures. Each required signer address is added to
         *     the list only the first time it occurs.
         *     By convention, the first required signer (usually from the first message)
         *     is referred to as the primary signer and pays the fee for the whole
         *     transaction. */
        messages?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        }[];
        /** @description memo is any arbitrary note/comment to be added to the transaction.
         *     WARNING: in clients, any publicly exposed text should not be called memo,
         *     but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122). */
        memo?: string;
        /**
         * timeout is the block height after which this transaction will not
         *     be processed by the chain
         * Format: uint64
         */
        timeout_height?: string;
        /** extension_options are arbitrary options that can be added by chains
         *     when the default options are not sufficient. If any of these are present
         *     and can't be handled, the transaction will be rejected */
        extension_options?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        }[];
        /** extension_options are arbitrary options that can be added by chains
         *     when the default options are not sufficient. If any of these are present
         *     and can't be handled, they will be ignored */
        non_critical_extension_options?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        }[];
      };
      auth_info?: components["schemas"]["cosmos.tx.v1beta1.AuthInfo"];
      /** @description signatures is a list of signatures that matches the length and order of
       *     AuthInfo's signer_infos to allow connecting signature meta information like
       *     public key and signing mode by position. */
      signatures?: string[];
    };
    /** @description TxBody is the body of a transaction that all signers sign over. */
    "cosmos.tx.v1beta1.TxBody": {
      /** @description messages is a list of messages to be executed. The required signers of
       *     those messages define the number and order of elements in AuthInfo's
       *     signer_infos and Tx's signatures. Each required signer address is added to
       *     the list only the first time it occurs.
       *     By convention, the first required signer (usually from the first message)
       *     is referred to as the primary signer and pays the fee for the whole
       *     transaction. */
      messages?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
      /** @description memo is any arbitrary note/comment to be added to the transaction.
       *     WARNING: in clients, any publicly exposed text should not be called memo,
       *     but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122). */
      memo?: string;
      /**
       * timeout is the block height after which this transaction will not
       *     be processed by the chain
       * Format: uint64
       */
      timeout_height?: string;
      /** extension_options are arbitrary options that can be added by chains
       *     when the default options are not sufficient. If any of these are present
       *     and can't be handled, the transaction will be rejected */
      extension_options?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
      /** extension_options are arbitrary options that can be added by chains
       *     when the default options are not sufficient. If any of these are present
       *     and can't be handled, they will be ignored */
      non_critical_extension_options?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
    };
    /** @description Event allows application developers to attach additional information to
     *     ResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.
     *     Later, transactions may be queried using these events. */
    "tendermint.abci.Event": {
      type?: string;
      attributes?: {
        /** Format: byte */
        key?: string;
        /** Format: byte */
        value?: string;
        /** Format: boolean */
        index?: boolean;
      }[];
    };
    /** @description EventAttribute is a single key-value pair, associated with an event. */
    "tendermint.abci.EventAttribute": {
      /** Format: byte */
      key?: string;
      /** Format: byte */
      value?: string;
      /** Format: boolean */
      index?: boolean;
    };
    /** @description ModuleVersion specifies a module and its consensus version.
     *
     *     Since: cosmos-sdk 0.43 */
    "cosmos.upgrade.v1beta1.ModuleVersion": {
      /** name of the app module */
      name?: string;
      /**
       * consensus version of the app module
       * Format: uint64
       */
      version?: string;
    };
    /** @description Plan specifies information about a planned upgrade and when it should occur. */
    "cosmos.upgrade.v1beta1.Plan": {
      /** @description Sets the name for the upgrade. This name will be used by the upgraded
       *     version of the software to apply any special "on-upgrade" commands during
       *     the first BeginBlock method after the upgrade is applied. It is also used
       *     to detect whether a software version can handle a given upgrade. If no
       *     upgrade handler with this name has been set in the software, it will be
       *     assumed that the software is out-of-date when the upgrade Time or Height is
       *     reached and the software will exit. */
      name?: string;
      /**
       * Format: date-time
       * @description Deprecated: Time based upgrades have been deprecated. Time based upgrade logic
       *     has been removed from the SDK.
       *     If this field is not empty, an error will be thrown.
       */
      time?: string;
      /**
       * Format: int64
       * @description The height at which the upgrade must be performed.
       *     Only used if Time is not set.
       */
      height?: string;
      /** Any application specific upgrade info to be included on-chain
       *     such as a git commit that validators could automatically upgrade to */
      info?: string;
      /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         } */
      upgraded_client_state?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /** @description QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC
     *     method. */
    "cosmos.upgrade.v1beta1.QueryAppliedPlanResponse": {
      /**
       * Format: int64
       * @description height is the block height at which the plan was applied.
       */
      height?: string;
    };
    /** @description QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC
     *     method. */
    "cosmos.upgrade.v1beta1.QueryCurrentPlanResponse": {
      /** @description plan is the current upgrade plan. */
      plan?: {
        /** @description Sets the name for the upgrade. This name will be used by the upgraded
         *     version of the software to apply any special "on-upgrade" commands during
         *     the first BeginBlock method after the upgrade is applied. It is also used
         *     to detect whether a software version can handle a given upgrade. If no
         *     upgrade handler with this name has been set in the software, it will be
         *     assumed that the software is out-of-date when the upgrade Time or Height is
         *     reached and the software will exit. */
        name?: string;
        /**
         * Format: date-time
         * @description Deprecated: Time based upgrades have been deprecated. Time based upgrade logic
         *     has been removed from the SDK.
         *     If this field is not empty, an error will be thrown.
         */
        time?: string;
        /**
         * Format: int64
         * @description The height at which the upgrade must be performed.
         *     Only used if Time is not set.
         */
        height?: string;
        /** Any application specific upgrade info to be included on-chain
         *     such as a git commit that validators could automatically upgrade to */
        info?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        upgraded_client_state?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      };
    };
    /** @description QueryModuleVersionsResponse is the response type for the Query/ModuleVersions
     *     RPC method.
     *
     *     Since: cosmos-sdk 0.43 */
    "cosmos.upgrade.v1beta1.QueryModuleVersionsResponse": {
      /** @description module_versions is a list of module names with their consensus versions. */
      module_versions?: {
        /** name of the app module */
        name?: string;
        /**
         * consensus version of the app module
         * Format: uint64
         */
        version?: string;
      }[];
    };
    /** @description QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState
     *     RPC method. */
    "cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateResponse": {
      /**
       * Since: cosmos-sdk 0.43
       * Format: byte
       */
      upgraded_consensus_state?: string;
    };
    /** @description Channel defines pipeline for exactly-once packet delivery between specific
     *     modules on separate blockchains, which has at least one end capable of
     *     sending packets and one end capable of receiving packets. */
    "ibc.core.channel.v1.Channel": {
      /**
       * current state of the channel end
       * @description State defines if a channel is in one of the following states:
       *     CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
       *
       *      - STATE_UNINITIALIZED_UNSPECIFIED: Default State
       *      - STATE_INIT: A channel has just started the opening handshake.
       *      - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
       *      - STATE_OPEN: A channel has completed the handshake. Open channels are
       *     ready to send and receive packets.
       *      - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
       *     packets.
       * @default STATE_UNINITIALIZED_UNSPECIFIED
       * @enum {string}
       */
      state:
        | "STATE_UNINITIALIZED_UNSPECIFIED"
        | "STATE_INIT"
        | "STATE_TRYOPEN"
        | "STATE_OPEN"
        | "STATE_CLOSED";
      /**
       * whether the channel is ordered or unordered
       * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
       *      - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
       *     which they were sent.
       *      - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
       * @default ORDER_NONE_UNSPECIFIED
       * @enum {string}
       */
      ordering: "ORDER_NONE_UNSPECIFIED" | "ORDER_UNORDERED" | "ORDER_ORDERED";
      /** counterparty channel end */
      counterparty?: {
        /** @description port on the counterparty chain which owns the other end of the channel. */
        port_id?: string;
        /** channel end on the counterparty chain */
        channel_id?: string;
      };
      /** list of connection identifiers, in order, along which packets sent on
       *     this channel will travel */
      connection_hops?: string[];
      /** opaque channel version, which is agreed upon during the handshake */
      version?: string;
    };
    /** Counterparty defines a channel end counterparty */
    "ibc.core.channel.v1.Counterparty": {
      /** @description port on the counterparty chain which owns the other end of the channel. */
      port_id?: string;
      /** channel end on the counterparty chain */
      channel_id?: string;
    };
    /** @description IdentifiedChannel defines a channel with additional port and channel
     *     identifier fields. */
    "ibc.core.channel.v1.IdentifiedChannel": {
      /**
       * current state of the channel end
       * @description State defines if a channel is in one of the following states:
       *     CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
       *
       *      - STATE_UNINITIALIZED_UNSPECIFIED: Default State
       *      - STATE_INIT: A channel has just started the opening handshake.
       *      - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
       *      - STATE_OPEN: A channel has completed the handshake. Open channels are
       *     ready to send and receive packets.
       *      - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
       *     packets.
       * @default STATE_UNINITIALIZED_UNSPECIFIED
       * @enum {string}
       */
      state:
        | "STATE_UNINITIALIZED_UNSPECIFIED"
        | "STATE_INIT"
        | "STATE_TRYOPEN"
        | "STATE_OPEN"
        | "STATE_CLOSED";
      /**
       * whether the channel is ordered or unordered
       * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
       *      - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
       *     which they were sent.
       *      - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
       * @default ORDER_NONE_UNSPECIFIED
       * @enum {string}
       */
      ordering: "ORDER_NONE_UNSPECIFIED" | "ORDER_UNORDERED" | "ORDER_ORDERED";
      /** counterparty channel end */
      counterparty?: {
        /** @description port on the counterparty chain which owns the other end of the channel. */
        port_id?: string;
        /** channel end on the counterparty chain */
        channel_id?: string;
      };
      /** list of connection identifiers, in order, along which packets sent on
       *     this channel will travel */
      connection_hops?: string[];
      /** opaque channel version, which is agreed upon during the handshake */
      version?: string;
      /** port identifier */
      port_id?: string;
      /** channel identifier */
      channel_id?: string;
    };
    /**
     * Order defines if a channel is ORDERED or UNORDERED
     * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
     *      - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
     *     which they were sent.
     *      - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @default ORDER_NONE_UNSPECIFIED
     * @enum {string}
     */
    "ibc.core.channel.v1.Order":
      | "ORDER_NONE_UNSPECIFIED"
      | "ORDER_UNORDERED"
      | "ORDER_ORDERED";
    /** @description PacketState defines the generic type necessary to retrieve and store
     *     packet commitments, acknowledgements, and receipts.
     *     Caller is responsible for knowing the context necessary to interpret this
     *     state as a commitment, acknowledgement, or a receipt. */
    "ibc.core.channel.v1.PacketState": {
      /** @description channel port identifier. */
      port_id?: string;
      /** @description channel unique identifier. */
      channel_id?: string;
      /**
       * Format: uint64
       * @description packet sequence.
       */
      sequence?: string;
      /**
       * Format: byte
       * @description embedded data that represents packet state.
       */
      data?: string;
    };
    /** QueryChannelClientStateResponse is the Response type for the
     *     Query/QueryChannelClientState RPC method */
    "ibc.core.channel.v1.QueryChannelClientStateResponse": {
      /**
       * client state associated with the channel
       * @description IdentifiedClientState defines a client state with an additional client
       *     identifier field.
       */
      identified_client_state?: {
        /** client identifier */
        client_id?: string;
        /**
         * client state
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         }
         */
        client_state?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      };
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** QueryChannelClientStateResponse is the Response type for the
     *     Query/QueryChannelClientState RPC method */
    "ibc.core.channel.v1.QueryChannelConsensusStateResponse": {
      /**
       * consensus state associated with the channel
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         }
       */
      consensus_state?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /** client ID associated with the consensus state */
      client_id?: string;
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** @description QueryChannelResponse is the response type for the Query/Channel RPC method.
     *     Besides the Channel end, it includes a proof and the height from which the
     *     proof was retrieved. */
    "ibc.core.channel.v1.QueryChannelResponse": {
      /**
       * channel associated with the request identifiers
       * @description Channel defines pipeline for exactly-once packet delivery between specific
       *     modules on separate blockchains, which has at least one end capable of
       *     sending packets and one end capable of receiving packets.
       */
      channel?: {
        /**
         * current state of the channel end
         * @description State defines if a channel is in one of the following states:
         *     CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
         *
         *      - STATE_UNINITIALIZED_UNSPECIFIED: Default State
         *      - STATE_INIT: A channel has just started the opening handshake.
         *      - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
         *      - STATE_OPEN: A channel has completed the handshake. Open channels are
         *     ready to send and receive packets.
         *      - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
         *     packets.
         * @default STATE_UNINITIALIZED_UNSPECIFIED
         * @enum {string}
         */
        state:
          | "STATE_UNINITIALIZED_UNSPECIFIED"
          | "STATE_INIT"
          | "STATE_TRYOPEN"
          | "STATE_OPEN"
          | "STATE_CLOSED";
        /**
         * whether the channel is ordered or unordered
         * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
         *      - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
         *     which they were sent.
         *      - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
         * @default ORDER_NONE_UNSPECIFIED
         * @enum {string}
         */
        ordering:
          | "ORDER_NONE_UNSPECIFIED"
          | "ORDER_UNORDERED"
          | "ORDER_ORDERED";
        /** counterparty channel end */
        counterparty?: {
          /** @description port on the counterparty chain which owns the other end of the channel. */
          port_id?: string;
          /** channel end on the counterparty chain */
          channel_id?: string;
        };
        /** list of connection identifiers, in order, along which packets sent on
         *     this channel will travel */
        connection_hops?: string[];
        /** opaque channel version, which is agreed upon during the handshake */
        version?: string;
      };
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** @description QueryChannelsResponse is the response type for the Query/Channels RPC method. */
    "ibc.core.channel.v1.QueryChannelsResponse": {
      /** @description list of stored channels of the chain. */
      channels?: {
        /**
         * current state of the channel end
         * @description State defines if a channel is in one of the following states:
         *     CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
         *
         *      - STATE_UNINITIALIZED_UNSPECIFIED: Default State
         *      - STATE_INIT: A channel has just started the opening handshake.
         *      - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
         *      - STATE_OPEN: A channel has completed the handshake. Open channels are
         *     ready to send and receive packets.
         *      - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
         *     packets.
         * @default STATE_UNINITIALIZED_UNSPECIFIED
         * @enum {string}
         */
        state:
          | "STATE_UNINITIALIZED_UNSPECIFIED"
          | "STATE_INIT"
          | "STATE_TRYOPEN"
          | "STATE_OPEN"
          | "STATE_CLOSED";
        /**
         * whether the channel is ordered or unordered
         * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
         *      - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
         *     which they were sent.
         *      - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
         * @default ORDER_NONE_UNSPECIFIED
         * @enum {string}
         */
        ordering:
          | "ORDER_NONE_UNSPECIFIED"
          | "ORDER_UNORDERED"
          | "ORDER_ORDERED";
        /** counterparty channel end */
        counterparty?: {
          /** @description port on the counterparty chain which owns the other end of the channel. */
          port_id?: string;
          /** channel end on the counterparty chain */
          channel_id?: string;
        };
        /** list of connection identifiers, in order, along which packets sent on
         *     this channel will travel */
        connection_hops?: string[];
        /** opaque channel version, which is agreed upon during the handshake */
        version?: string;
        /** port identifier */
        port_id?: string;
        /** channel identifier */
        channel_id?: string;
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       *     corresponding request message has used PageRequest.
       *
       *      message SomeResponse {
       *              repeated Bar results = 1;
       *              PageResponse page = 2;
       *      }
       */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** QueryConnectionChannelsResponse is the Response type for the
     *     Query/QueryConnectionChannels RPC method */
    "ibc.core.channel.v1.QueryConnectionChannelsResponse": {
      /** @description list of channels associated with a connection. */
      channels?: {
        /**
         * current state of the channel end
         * @description State defines if a channel is in one of the following states:
         *     CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
         *
         *      - STATE_UNINITIALIZED_UNSPECIFIED: Default State
         *      - STATE_INIT: A channel has just started the opening handshake.
         *      - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
         *      - STATE_OPEN: A channel has completed the handshake. Open channels are
         *     ready to send and receive packets.
         *      - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
         *     packets.
         * @default STATE_UNINITIALIZED_UNSPECIFIED
         * @enum {string}
         */
        state:
          | "STATE_UNINITIALIZED_UNSPECIFIED"
          | "STATE_INIT"
          | "STATE_TRYOPEN"
          | "STATE_OPEN"
          | "STATE_CLOSED";
        /**
         * whether the channel is ordered or unordered
         * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
         *      - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
         *     which they were sent.
         *      - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
         * @default ORDER_NONE_UNSPECIFIED
         * @enum {string}
         */
        ordering:
          | "ORDER_NONE_UNSPECIFIED"
          | "ORDER_UNORDERED"
          | "ORDER_ORDERED";
        /** counterparty channel end */
        counterparty?: {
          /** @description port on the counterparty chain which owns the other end of the channel. */
          port_id?: string;
          /** channel end on the counterparty chain */
          channel_id?: string;
        };
        /** list of connection identifiers, in order, along which packets sent on
         *     this channel will travel */
        connection_hops?: string[];
        /** opaque channel version, which is agreed upon during the handshake */
        version?: string;
        /** port identifier */
        port_id?: string;
        /** channel identifier */
        channel_id?: string;
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       *     corresponding request message has used PageRequest.
       *
       *      message SomeResponse {
       *              repeated Bar results = 1;
       *              PageResponse page = 2;
       *      }
       */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** QuerySequenceResponse is the request type for the
     *     Query/QueryNextSequenceReceiveResponse RPC method */
    "ibc.core.channel.v1.QueryNextSequenceReceiveResponse": {
      /**
       * next sequence receive number
       * Format: uint64
       */
      next_sequence_receive?: string;
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** QueryPacketAcknowledgementResponse defines the client query response for a
     *     packet which also includes a proof and the height from which the
     *     proof was retrieved */
    "ibc.core.channel.v1.QueryPacketAcknowledgementResponse": {
      /**
       * packet associated with the request fields
       * Format: byte
       */
      acknowledgement?: string;
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** QueryPacketAcknowledgemetsResponse is the request type for the
     *     Query/QueryPacketAcknowledgements RPC method */
    "ibc.core.channel.v1.QueryPacketAcknowledgementsResponse": {
      acknowledgements?: {
        /** @description channel port identifier. */
        port_id?: string;
        /** @description channel unique identifier. */
        channel_id?: string;
        /**
         * Format: uint64
         * @description packet sequence.
         */
        sequence?: string;
        /**
         * Format: byte
         * @description embedded data that represents packet state.
         */
        data?: string;
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       *     corresponding request message has used PageRequest.
       *
       *      message SomeResponse {
       *              repeated Bar results = 1;
       *              PageResponse page = 2;
       *      }
       */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** QueryPacketCommitmentResponse defines the client query response for a packet
     *     which also includes a proof and the height from which the proof was
     *     retrieved */
    "ibc.core.channel.v1.QueryPacketCommitmentResponse": {
      /**
       * packet associated with the request fields
       * Format: byte
       */
      commitment?: string;
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** QueryPacketCommitmentsResponse is the request type for the
     *     Query/QueryPacketCommitments RPC method */
    "ibc.core.channel.v1.QueryPacketCommitmentsResponse": {
      commitments?: {
        /** @description channel port identifier. */
        port_id?: string;
        /** @description channel unique identifier. */
        channel_id?: string;
        /**
         * Format: uint64
         * @description packet sequence.
         */
        sequence?: string;
        /**
         * Format: byte
         * @description embedded data that represents packet state.
         */
        data?: string;
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       *     corresponding request message has used PageRequest.
       *
       *      message SomeResponse {
       *              repeated Bar results = 1;
       *              PageResponse page = 2;
       *      }
       */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** QueryPacketReceiptResponse defines the client query response for a packet
     *     receipt which also includes a proof, and the height from which the proof was
     *     retrieved */
    "ibc.core.channel.v1.QueryPacketReceiptResponse": {
      /**
       * success flag for if receipt exists
       * Format: boolean
       */
      received?: boolean;
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** QueryUnreceivedAcksResponse is the response type for the
     *     Query/UnreceivedAcks RPC method */
    "ibc.core.channel.v1.QueryUnreceivedAcksResponse": {
      /** list of unreceived acknowledgement sequences */
      sequences?: string[];
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** QueryUnreceivedPacketsResponse is the response type for the
     *     Query/UnreceivedPacketCommitments RPC method */
    "ibc.core.channel.v1.QueryUnreceivedPacketsResponse": {
      /** list of unreceived packet sequences */
      sequences?: string[];
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * @description State defines if a channel is in one of the following states:
     *     CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
     *
     *      - STATE_UNINITIALIZED_UNSPECIFIED: Default State
     *      - STATE_INIT: A channel has just started the opening handshake.
     *      - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
     *      - STATE_OPEN: A channel has completed the handshake. Open channels are
     *     ready to send and receive packets.
     *      - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
     *     packets.
     * @default STATE_UNINITIALIZED_UNSPECIFIED
     * @enum {string}
     */
    "ibc.core.channel.v1.State":
      | "STATE_UNINITIALIZED_UNSPECIFIED"
      | "STATE_INIT"
      | "STATE_TRYOPEN"
      | "STATE_OPEN"
      | "STATE_CLOSED";
    /**
     * Height is a monotonically increasing data type
     *     that can be compared against another Height for the purposes of updating and
     *     freezing clients
     * @description Normally the RevisionHeight is incremented at each height while keeping
     *     RevisionNumber the same. However some consensus algorithms may choose to
     *     reset the height in certain conditions e.g. hard forks, state-machine
     *     breaking changes In these cases, the RevisionNumber is incremented so that
     *     height continues to be monitonically increasing even as the RevisionHeight
     *     gets reset
     */
    "ibc.core.client.v1.Height": {
      /**
       * the revision that the client is currently on
       * Format: uint64
       */
      revision_number?: string;
      /**
       * the height within the given revision
       * Format: uint64
       */
      revision_height?: string;
    };
    /** @description IdentifiedClientState defines a client state with an additional client
     *     identifier field. */
    "ibc.core.client.v1.IdentifiedClientState": {
      /** client identifier */
      client_id?: string;
      /**
       * client state
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         }
       */
      client_state?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /** @description ConsensusStateWithHeight defines a consensus state with an additional height
     *     field. */
    "ibc.core.client.v1.ConsensusStateWithHeight": {
      /**
       * consensus state height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
      /**
       * consensus state
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         }
       */
      consensus_state?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /** @description Params defines the set of IBC light client parameters. */
    "ibc.core.client.v1.Params": {
      /** @description allowed_clients defines the list of allowed client state types. */
      allowed_clients?: string[];
    };
    /** @description QueryClientParamsResponse is the response type for the Query/ClientParams RPC
     *     method. */
    "ibc.core.client.v1.QueryClientParamsResponse": {
      /** @description params defines the parameters of the module. */
      params?: {
        /** @description allowed_clients defines the list of allowed client state types. */
        allowed_clients?: string[];
      };
    };
    /** @description QueryClientStateResponse is the response type for the Query/ClientState RPC
     *     method. Besides the client state, it includes a proof and the height from
     *     which the proof was retrieved. */
    "ibc.core.client.v1.QueryClientStateResponse": {
      /**
       * client state associated with the request identifier
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         }
       */
      client_state?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** @description QueryClientStatesResponse is the response type for the Query/ClientStates RPC
     *     method. */
    "ibc.core.client.v1.QueryClientStatesResponse": {
      /** @description list of stored ClientStates of the chain. */
      client_states?: {
        /** client identifier */
        client_id?: string;
        /**
         * client state
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         }
         */
        client_state?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       *     corresponding request message has used PageRequest.
       *
       *      message SomeResponse {
       *              repeated Bar results = 1;
       *              PageResponse page = 2;
       *      }
       */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryClientStatusResponse is the response type for the Query/ClientStatus RPC
     *     method. It returns the current status of the IBC client. */
    "ibc.core.client.v1.QueryClientStatusResponse": {
      status?: string;
    };
    /** QueryConsensusStateHeightsResponse is the response type for the
     *     Query/ConsensusStateHeights RPC method */
    "ibc.core.client.v1.QueryConsensusStateHeightsResponse": {
      /** consensus state heights */
      consensus_state_heights?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       *     corresponding request message has used PageRequest.
       *
       *      message SomeResponse {
       *              repeated Bar results = 1;
       *              PageResponse page = 2;
       *      }
       */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** QueryConsensusStateResponse is the response type for the Query/ConsensusState
     *     RPC method */
    "ibc.core.client.v1.QueryConsensusStateResponse": {
      /**
       * consensus state associated with the client identifier at the given height
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         }
       */
      consensus_state?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * Height is a monotonically increasing data type
       *     that can be compared against another Height for the purposes of updating and
       *     freezing clients
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** QueryConsensusStatesResponse is the response type for the
     *     Query/ConsensusStates RPC method */
    "ibc.core.client.v1.QueryConsensusStatesResponse": {
      /** consensus states associated with the identifier */
      consensus_states?: {
        /**
         * consensus state height
         * @description Normally the RevisionHeight is incremented at each height while keeping
         *     RevisionNumber the same. However some consensus algorithms may choose to
         *     reset the height in certain conditions e.g. hard forks, state-machine
         *     breaking changes In these cases, the RevisionNumber is incremented so that
         *     height continues to be monitonically increasing even as the RevisionHeight
         *     gets reset
         */
        height?: {
          /**
           * the revision that the client is currently on
           * Format: uint64
           */
          revision_number?: string;
          /**
           * the height within the given revision
           * Format: uint64
           */
          revision_height?: string;
        };
        /**
         * consensus state
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         }
         */
        consensus_state?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       *     corresponding request message has used PageRequest.
       *
       *      message SomeResponse {
       *              repeated Bar results = 1;
       *              PageResponse page = 2;
       *      }
       */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryUpgradedClientStateResponse is the response type for the
     *     Query/UpgradedClientState RPC method. */
    "ibc.core.client.v1.QueryUpgradedClientStateResponse": {
      /**
       * client state associated with the request identifier
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         }
       */
      upgraded_client_state?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /** @description QueryUpgradedConsensusStateResponse is the response type for the
     *     Query/UpgradedConsensusState RPC method. */
    "ibc.core.client.v1.QueryUpgradedConsensusStateResponse": {
      /**
       * Consensus state associated with the request identifier
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         }
       */
      upgraded_consensus_state?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /** MerklePrefix is merkle path prefixed to the key.
     *     The constructed key from the Path and the key will be append(Path.KeyPath,
     *     append(Path.KeyPrefix, key...)) */
    "ibc.core.commitment.v1.MerklePrefix": {
      /** Format: byte */
      key_prefix?: string;
    };
    /** @description ConnectionEnd defines a stateful object on a chain connected to another
     *     separate one.
     *     NOTE: there must only be 2 defined ConnectionEnds to establish
     *     a connection between two chains. */
    "ibc.core.connection.v1.ConnectionEnd": {
      /** @description client associated with this connection. */
      client_id?: string;
      /** @description IBC version which can be utilised to determine encodings or protocols for
       *     channels or packets utilising this connection. */
      versions?: {
        /** unique version identifier */
        identifier?: string;
        /** list of features compatible with the specified identifier */
        features?: string[];
      }[];
      /**
       * @description current state of the connection end.
       * @default STATE_UNINITIALIZED_UNSPECIFIED
       * @enum {string}
       */
      state:
        | "STATE_UNINITIALIZED_UNSPECIFIED"
        | "STATE_INIT"
        | "STATE_TRYOPEN"
        | "STATE_OPEN";
      /** @description counterparty chain associated with this connection. */
      counterparty?: {
        /** @description identifies the client on the counterparty chain associated with a given
         *     connection. */
        client_id?: string;
        /** @description identifies the connection end on the counterparty chain associated with a
         *     given connection. */
        connection_id?: string;
        /**
         * MerklePrefix is merkle path prefixed to the key.
         *     The constructed key from the Path and the key will be append(Path.KeyPath,
         *     append(Path.KeyPrefix, key...))
         * @description commitment merkle prefix of the counterparty chain.
         */
        prefix?: {
          /** Format: byte */
          key_prefix?: string;
        };
      };
      /**
       * Format: uint64
       * @description delay period that must pass before a consensus state can be used for
       *     packet-verification NOTE: delay period logic is only implemented by some
       *     clients.
       */
      delay_period?: string;
    };
    /** @description Counterparty defines the counterparty chain associated with a connection end. */
    "ibc.core.connection.v1.Counterparty": {
      /** @description identifies the client on the counterparty chain associated with a given
       *     connection. */
      client_id?: string;
      /** @description identifies the connection end on the counterparty chain associated with a
       *     given connection. */
      connection_id?: string;
      /**
       * MerklePrefix is merkle path prefixed to the key.
       *     The constructed key from the Path and the key will be append(Path.KeyPath,
       *     append(Path.KeyPrefix, key...))
       * @description commitment merkle prefix of the counterparty chain.
       */
      prefix?: {
        /** Format: byte */
        key_prefix?: string;
      };
    };
    /** @description IdentifiedConnection defines a connection with additional connection
     *     identifier field. */
    "ibc.core.connection.v1.IdentifiedConnection": {
      /** @description connection identifier. */
      id?: string;
      /** @description client associated with this connection. */
      client_id?: string;
      /** IBC version which can be utilised to determine encodings or protocols for
       *     channels or packets utilising this connection */
      versions?: {
        /** unique version identifier */
        identifier?: string;
        /** list of features compatible with the specified identifier */
        features?: string[];
      }[];
      /**
       * @description current state of the connection end.
       * @default STATE_UNINITIALIZED_UNSPECIFIED
       * @enum {string}
       */
      state:
        | "STATE_UNINITIALIZED_UNSPECIFIED"
        | "STATE_INIT"
        | "STATE_TRYOPEN"
        | "STATE_OPEN";
      /** @description counterparty chain associated with this connection. */
      counterparty?: {
        /** @description identifies the client on the counterparty chain associated with a given
         *     connection. */
        client_id?: string;
        /** @description identifies the connection end on the counterparty chain associated with a
         *     given connection. */
        connection_id?: string;
        /**
         * MerklePrefix is merkle path prefixed to the key.
         *     The constructed key from the Path and the key will be append(Path.KeyPath,
         *     append(Path.KeyPrefix, key...))
         * @description commitment merkle prefix of the counterparty chain.
         */
        prefix?: {
          /** Format: byte */
          key_prefix?: string;
        };
      };
      /**
       * Format: uint64
       * @description delay period associated with this connection.
       */
      delay_period?: string;
    };
    /** QueryClientConnectionsResponse is the response type for the
     *     Query/ClientConnections RPC method */
    "ibc.core.connection.v1.QueryClientConnectionsResponse": {
      /** @description slice of all the connection paths associated with a client. */
      connection_paths?: string[];
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was generated
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** QueryConnectionClientStateResponse is the response type for the
     *     Query/ConnectionClientState RPC method */
    "ibc.core.connection.v1.QueryConnectionClientStateResponse": {
      /**
       * client state associated with the channel
       * @description IdentifiedClientState defines a client state with an additional client
       *     identifier field.
       */
      identified_client_state?: {
        /** client identifier */
        client_id?: string;
        /**
         * client state
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         }
         */
        client_state?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      };
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** QueryConnectionConsensusStateResponse is the response type for the
     *     Query/ConnectionConsensusState RPC method */
    "ibc.core.connection.v1.QueryConnectionConsensusStateResponse": {
      /**
       * consensus state associated with the channel
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         }
       */
      consensus_state?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /** client ID associated with the consensus state */
      client_id?: string;
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** @description QueryConnectionResponse is the response type for the Query/Connection RPC
     *     method. Besides the connection end, it includes a proof and the height from
     *     which the proof was retrieved. */
    "ibc.core.connection.v1.QueryConnectionResponse": {
      /**
       * connection associated with the request identifier
       * @description ConnectionEnd defines a stateful object on a chain connected to another
       *     separate one.
       *     NOTE: there must only be 2 defined ConnectionEnds to establish
       *     a connection between two chains.
       */
      connection?: {
        /** @description client associated with this connection. */
        client_id?: string;
        /** @description IBC version which can be utilised to determine encodings or protocols for
         *     channels or packets utilising this connection. */
        versions?: {
          /** unique version identifier */
          identifier?: string;
          /** list of features compatible with the specified identifier */
          features?: string[];
        }[];
        /**
         * @description current state of the connection end.
         * @default STATE_UNINITIALIZED_UNSPECIFIED
         * @enum {string}
         */
        state:
          | "STATE_UNINITIALIZED_UNSPECIFIED"
          | "STATE_INIT"
          | "STATE_TRYOPEN"
          | "STATE_OPEN";
        /** @description counterparty chain associated with this connection. */
        counterparty?: {
          /** @description identifies the client on the counterparty chain associated with a given
           *     connection. */
          client_id?: string;
          /** @description identifies the connection end on the counterparty chain associated with a
           *     given connection. */
          connection_id?: string;
          /**
           * MerklePrefix is merkle path prefixed to the key.
           *     The constructed key from the Path and the key will be append(Path.KeyPath,
           *     append(Path.KeyPrefix, key...))
           * @description commitment merkle prefix of the counterparty chain.
           */
          prefix?: {
            /** Format: byte */
            key_prefix?: string;
          };
        };
        /**
         * Format: uint64
         * @description delay period that must pass before a consensus state can be used for
         *     packet-verification NOTE: delay period logic is only implemented by some
         *     clients.
         */
        delay_period?: string;
      };
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** @description QueryConnectionsResponse is the response type for the Query/Connections RPC
     *     method. */
    "ibc.core.connection.v1.QueryConnectionsResponse": {
      /** @description list of stored connections of the chain. */
      connections?: {
        /** @description connection identifier. */
        id?: string;
        /** @description client associated with this connection. */
        client_id?: string;
        /** IBC version which can be utilised to determine encodings or protocols for
         *     channels or packets utilising this connection */
        versions?: {
          /** unique version identifier */
          identifier?: string;
          /** list of features compatible with the specified identifier */
          features?: string[];
        }[];
        /**
         * @description current state of the connection end.
         * @default STATE_UNINITIALIZED_UNSPECIFIED
         * @enum {string}
         */
        state:
          | "STATE_UNINITIALIZED_UNSPECIFIED"
          | "STATE_INIT"
          | "STATE_TRYOPEN"
          | "STATE_OPEN";
        /** @description counterparty chain associated with this connection. */
        counterparty?: {
          /** @description identifies the client on the counterparty chain associated with a given
           *     connection. */
          client_id?: string;
          /** @description identifies the connection end on the counterparty chain associated with a
           *     given connection. */
          connection_id?: string;
          /**
           * MerklePrefix is merkle path prefixed to the key.
           *     The constructed key from the Path and the key will be append(Path.KeyPath,
           *     append(Path.KeyPrefix, key...))
           * @description commitment merkle prefix of the counterparty chain.
           */
          prefix?: {
            /** Format: byte */
            key_prefix?: string;
          };
        };
        /**
         * Format: uint64
         * @description delay period associated with this connection.
         */
        delay_period?: string;
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       *     corresponding request message has used PageRequest.
       *
       *      message SomeResponse {
       *              repeated Bar results = 1;
       *              PageResponse page = 2;
       *      }
       */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       *     RevisionNumber the same. However some consensus algorithms may choose to
       *     reset the height in certain conditions e.g. hard forks, state-machine
       *     breaking changes In these cases, the RevisionNumber is incremented so that
       *     height continues to be monitonically increasing even as the RevisionHeight
       *     gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * @description State defines if a connection is in one of the following states:
     *     INIT, TRYOPEN, OPEN or UNINITIALIZED.
     *
     *      - STATE_UNINITIALIZED_UNSPECIFIED: Default State
     *      - STATE_INIT: A connection end has just started the opening handshake.
     *      - STATE_TRYOPEN: A connection end has acknowledged the handshake step on the counterparty
     *     chain.
     *      - STATE_OPEN: A connection end has completed the handshake.
     * @default STATE_UNINITIALIZED_UNSPECIFIED
     * @enum {string}
     */
    "ibc.core.connection.v1.State":
      | "STATE_UNINITIALIZED_UNSPECIFIED"
      | "STATE_INIT"
      | "STATE_TRYOPEN"
      | "STATE_OPEN";
    /** @description Version defines the versioning scheme used to negotiate the IBC verison in
     *     the connection handshake. */
    "ibc.core.connection.v1.Version": {
      /** unique version identifier */
      identifier?: string;
      /** list of features compatible with the specified identifier */
      features?: string[];
    };
    /** @description DenomTrace contains the base denomination for ICS20 fungible tokens and the
     *     source tracing information path. */
    "ibc.applications.transfer.v1.DenomTrace": {
      /** @description path defines the chain of port/channel identifiers used for tracing the
       *     source of the fungible token. */
      path?: string;
      /** @description base denomination of the relayed fungible token. */
      base_denom?: string;
    };
    /** @description Params defines the set of IBC transfer parameters.
     *     NOTE: To prevent a single token from being transferred, set the
     *     TransfersEnabled parameter to true and then set the bank module's SendEnabled
     *     parameter for the denomination to false. */
    "ibc.applications.transfer.v1.Params": {
      /**
       * Format: boolean
       * @description send_enabled enables or disables all cross-chain token transfers from this
       *     chain.
       */
      send_enabled?: boolean;
      /**
       * Format: boolean
       * @description receive_enabled enables or disables all cross-chain token transfers to this
       *     chain.
       */
      receive_enabled?: boolean;
    };
    /** @description QueryDenomHashResponse is the response type for the Query/DenomHash RPC
     *     method. */
    "ibc.applications.transfer.v1.QueryDenomHashResponse": {
      /** @description hash (in hex format) of the denomination trace information. */
      hash?: string;
    };
    /** @description QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC
     *     method. */
    "ibc.applications.transfer.v1.QueryDenomTraceResponse": {
      /** @description DenomTrace contains the base denomination for ICS20 fungible tokens and the
       *     source tracing information path. */
      denom_trace?: {
        /** @description path defines the chain of port/channel identifiers used for tracing the
         *     source of the fungible token. */
        path?: string;
        /** @description base denomination of the relayed fungible token. */
        base_denom?: string;
      };
    };
    /** @description QueryConnectionsResponse is the response type for the Query/DenomTraces RPC
     *     method. */
    "ibc.applications.transfer.v1.QueryDenomTracesResponse": {
      /** @description denom_traces returns all denominations trace information. */
      denom_traces?: {
        /** @description path defines the chain of port/channel identifiers used for tracing the
         *     source of the fungible token. */
        path?: string;
        /** @description base denomination of the relayed fungible token. */
        base_denom?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryEscrowAddressResponse is the response type of the EscrowAddress RPC method. */
    "ibc.applications.transfer.v1.QueryEscrowAddressResponse": {
      /** the escrow account address */
      escrow_address?: string;
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "ibc.applications.transfer.v1.QueryParamsResponse": {
      /** @description params defines the parameters of the module. */
      params?: {
        /**
         * Format: boolean
         * @description send_enabled enables or disables all cross-chain token transfers from this
         *     chain.
         */
        send_enabled?: boolean;
        /**
         * Format: boolean
         * @description receive_enabled enables or disables all cross-chain token transfers to this
         *     chain.
         */
        receive_enabled?: boolean;
      };
    };
    /** @description AbsoluteTxPosition is a unique transaction position that allows for global
     *     ordering of transactions. */
    "cosmwasm.wasm.v1.AbsoluteTxPosition": {
      /**
       * BlockHeight is the block the contract was created at
       * Format: uint64
       */
      block_height?: string;
      /**
       * TxIndex is a monotonic counter within the block (actual transaction index,
       *     or gas consumed)
       * Format: uint64
       */
      tx_index?: string;
    };
    /** @description AccessConfig access control type. */
    "cosmwasm.wasm.v1.AccessConfig": {
      /**
       * AccessType permission types
       * @description - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
       *      - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
       *      - ACCESS_TYPE_ONLY_ADDRESS: AccessTypeOnlyAddress restricted to a single address
       *     Deprecated: use AccessTypeAnyOfAddresses instead
       *      - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
       *      - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
       * @default ACCESS_TYPE_UNSPECIFIED
       * @enum {string}
       */
      permission:
        | "ACCESS_TYPE_UNSPECIFIED"
        | "ACCESS_TYPE_NOBODY"
        | "ACCESS_TYPE_ONLY_ADDRESS"
        | "ACCESS_TYPE_EVERYBODY"
        | "ACCESS_TYPE_ANY_OF_ADDRESSES";
      /** Address
       *     Deprecated: replaced by addresses */
      address?: string;
      addresses?: string[];
    };
    /**
     * AccessType permission types
     * @description - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
     *      - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
     *      - ACCESS_TYPE_ONLY_ADDRESS: AccessTypeOnlyAddress restricted to a single address
     *     Deprecated: use AccessTypeAnyOfAddresses instead
     *      - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
     *      - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
     * @default ACCESS_TYPE_UNSPECIFIED
     * @enum {string}
     */
    "cosmwasm.wasm.v1.AccessType":
      | "ACCESS_TYPE_UNSPECIFIED"
      | "ACCESS_TYPE_NOBODY"
      | "ACCESS_TYPE_ONLY_ADDRESS"
      | "ACCESS_TYPE_EVERYBODY"
      | "ACCESS_TYPE_ANY_OF_ADDRESSES";
    /** CodeInfoResponse contains code meta data from CodeInfo */
    "cosmwasm.wasm.v1.CodeInfoResponse": {
      /** Format: uint64 */
      code_id?: string;
      creator?: string;
      /** Format: byte */
      data_hash?: string;
      /** @description AccessConfig access control type. */
      instantiate_permission?: {
        /**
         * AccessType permission types
         * @description - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
         *      - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
         *      - ACCESS_TYPE_ONLY_ADDRESS: AccessTypeOnlyAddress restricted to a single address
         *     Deprecated: use AccessTypeAnyOfAddresses instead
         *      - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
         *      - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
         * @default ACCESS_TYPE_UNSPECIFIED
         * @enum {string}
         */
        permission:
          | "ACCESS_TYPE_UNSPECIFIED"
          | "ACCESS_TYPE_NOBODY"
          | "ACCESS_TYPE_ONLY_ADDRESS"
          | "ACCESS_TYPE_EVERYBODY"
          | "ACCESS_TYPE_ANY_OF_ADDRESSES";
        /** Address
         *     Deprecated: replaced by addresses */
        address?: string;
        addresses?: string[];
      };
    };
    /** @description ContractCodeHistoryEntry metadata to a contract. */
    "cosmwasm.wasm.v1.ContractCodeHistoryEntry": {
      /**
       * ContractCodeHistoryOperationType actions that caused a code change
       * @description - CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED: ContractCodeHistoryOperationTypeUnspecified placeholder for empty value
       *      - CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT: ContractCodeHistoryOperationTypeInit on chain contract instantiation
       *      - CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE: ContractCodeHistoryOperationTypeMigrate code migration
       *      - CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS: ContractCodeHistoryOperationTypeGenesis based on genesis data
       * @default CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED
       * @enum {string}
       */
      operation:
        | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"
        | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT"
        | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE"
        | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
      /**
       * CodeID is the reference to the stored WASM code
       * Format: uint64
       */
      code_id?: string;
      /** @description Updated Tx position when the operation was executed. */
      updated?: {
        /**
         * BlockHeight is the block the contract was created at
         * Format: uint64
         */
        block_height?: string;
        /**
         * TxIndex is a monotonic counter within the block (actual transaction index,
         *     or gas consumed)
         * Format: uint64
         */
        tx_index?: string;
      };
      /** Format: byte */
      msg?: string;
    };
    /**
     * ContractCodeHistoryOperationType actions that caused a code change
     * @description - CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED: ContractCodeHistoryOperationTypeUnspecified placeholder for empty value
     *      - CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT: ContractCodeHistoryOperationTypeInit on chain contract instantiation
     *      - CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE: ContractCodeHistoryOperationTypeMigrate code migration
     *      - CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS: ContractCodeHistoryOperationTypeGenesis based on genesis data
     * @default CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED
     * @enum {string}
     */
    "cosmwasm.wasm.v1.ContractCodeHistoryOperationType":
      | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"
      | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT"
      | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE"
      | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
    /** ContractInfo stores a WASM contract instance */
    "cosmwasm.wasm.v1.ContractInfo": {
      /**
       * CodeID is the reference to the stored Wasm code
       * Format: uint64
       */
      code_id?: string;
      /** Creator address who initially instantiated the contract */
      creator?: string;
      /** Admin is an optional address that can execute migrations */
      admin?: string;
      /** @description Label is optional metadata to be stored with a contract instance. */
      label?: string;
      /** @description Created Tx position when the contract was instantiated. */
      created?: {
        /**
         * BlockHeight is the block the contract was created at
         * Format: uint64
         */
        block_height?: string;
        /**
         * TxIndex is a monotonic counter within the block (actual transaction index,
         *     or gas consumed)
         * Format: uint64
         */
        tx_index?: string;
      };
      ibc_port_id?: string;
      /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
       *     URL that describes the type of the serialized message.
       *
       *     Protobuf library provides support to pack/unpack Any values in the form
       *     of utility functions or additional generated methods of the Any type.
       *
       *     Example 1: Pack and unpack a message in C++.
       *
       *         Foo foo = ...;
       *         Any any;
       *         any.PackFrom(foo);
       *         ...
       *         if (any.UnpackTo(&foo)) {
       *           ...
       *         }
       *
       *     Example 2: Pack and unpack a message in Java.
       *
       *         Foo foo = ...;
       *         Any any = Any.pack(foo);
       *         ...
       *         if (any.is(Foo.class)) {
       *           foo = any.unpack(Foo.class);
       *         }
       *
       *      Example 3: Pack and unpack a message in Python.
       *
       *         foo = Foo(...)
       *         any = Any()
       *         any.Pack(foo)
       *         ...
       *         if any.Is(Foo.DESCRIPTOR):
       *           any.Unpack(foo)
       *           ...
       *
       *      Example 4: Pack and unpack a message in Go
       *
       *          foo := &pb.Foo{...}
       *          any, err := anypb.New(foo)
       *          if err != nil {
       *            ...
       *          }
       *          ...
       *          foo := &pb.Foo{}
       *          if err := any.UnmarshalTo(foo); err != nil {
       *            ...
       *          }
       *
       *     The pack methods provided by protobuf library will by default use
       *     'type.googleapis.com/full.type.name' as the type URL and the unpack
       *     methods only use the fully qualified type name after the last '/'
       *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
       *     name "y.z".
       *
       *
       *     JSON
       *     ====
       *     The JSON representation of an `Any` value uses the regular
       *     representation of the deserialized, embedded message, with an
       *     additional field `@type` which contains the type URL. Example:
       *
       *         package google.profile;
       *         message Person {
       *           string first_name = 1;
       *           string last_name = 2;
       *         }
       *
       *         {
       *           "@type": "type.googleapis.com/google.profile.Person",
       *           "firstName": <string>,
       *           "lastName": <string>
       *         }
       *
       *     If the embedded message type is well-known and has a custom JSON
       *     representation, that representation will be embedded adding a field
       *     `value` which holds the custom JSON in addition to the `@type`
       *     field. Example (for message [google.protobuf.Duration][]):
       *
       *         {
       *           "@type": "type.googleapis.com/google.protobuf.Duration",
       *           "value": "1.212s"
       *         } */
      extension?: {
        /** @description A URL/resource name that uniquely identifies the type of the serialized
         *     protocol buffer message. This string must contain at least
         *     one "/" character. The last segment of the URL's path must represent
         *     the fully qualified name of the type (as in
         *     `path/google.protobuf.Duration`). The name should be in a canonical form
         *     (e.g., leading "." is not accepted).
         *
         *     In practice, teams usually precompile into the binary all types that they
         *     expect it to use in the context of Any. However, for URLs which use the
         *     scheme `http`, `https`, or no scheme, one can optionally set up a type
         *     server that maps type URLs to message definitions as follows:
         *
         *     * If no scheme is provided, `https` is assumed.
         *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *       value in binary format, or produce an error.
         *     * Applications are allowed to cache lookup results based on the
         *       URL, or have them precompiled into a binary to avoid any
         *       lookup. Therefore, binary compatibility needs to be preserved
         *       on changes to types. (Use versioned type names to manage
         *       breaking changes.)
         *
         *     Note: this functionality is not currently available in the official
         *     protobuf release, and it is not used for type URLs beginning with
         *     type.googleapis.com.
         *
         *     Schemes other than `http`, `https` (or the empty scheme) might be
         *     used with implementation specific semantics. */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /** Model is a struct that holds a KV pair */
    "cosmwasm.wasm.v1.Model": {
      /**
       * hex-encode key to read it better (this is often ascii)
       * Format: byte
       */
      key?: string;
      /**
       * base64-encode raw value
       * Format: byte
       */
      value?: string;
    };
    /** @description Params defines the set of wasm parameters. */
    "cosmwasm.wasm.v1.Params": {
      /** @description AccessConfig access control type. */
      code_upload_access?: {
        /**
         * AccessType permission types
         * @description - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
         *      - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
         *      - ACCESS_TYPE_ONLY_ADDRESS: AccessTypeOnlyAddress restricted to a single address
         *     Deprecated: use AccessTypeAnyOfAddresses instead
         *      - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
         *      - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
         * @default ACCESS_TYPE_UNSPECIFIED
         * @enum {string}
         */
        permission:
          | "ACCESS_TYPE_UNSPECIFIED"
          | "ACCESS_TYPE_NOBODY"
          | "ACCESS_TYPE_ONLY_ADDRESS"
          | "ACCESS_TYPE_EVERYBODY"
          | "ACCESS_TYPE_ANY_OF_ADDRESSES";
        /** Address
         *     Deprecated: replaced by addresses */
        address?: string;
        addresses?: string[];
      };
      /**
       * AccessType permission types
       * @description - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
       *      - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
       *      - ACCESS_TYPE_ONLY_ADDRESS: AccessTypeOnlyAddress restricted to a single address
       *     Deprecated: use AccessTypeAnyOfAddresses instead
       *      - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
       *      - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
       * @default ACCESS_TYPE_UNSPECIFIED
       * @enum {string}
       */
      instantiate_default_permission:
        | "ACCESS_TYPE_UNSPECIFIED"
        | "ACCESS_TYPE_NOBODY"
        | "ACCESS_TYPE_ONLY_ADDRESS"
        | "ACCESS_TYPE_EVERYBODY"
        | "ACCESS_TYPE_ANY_OF_ADDRESSES";
    };
    /** QueryAllContractStateResponse is the response type for the
     *     Query/AllContractState RPC method */
    "cosmwasm.wasm.v1.QueryAllContractStateResponse": {
      models?: {
        /**
         * hex-encode key to read it better (this is often ascii)
         * Format: byte
         */
        key?: string;
        /**
         * base64-encode raw value
         * Format: byte
         */
        value?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** QueryCodeResponse is the response type for the Query/Code RPC method */
    "cosmwasm.wasm.v1.QueryCodeResponse": {
      /** CodeInfoResponse contains code meta data from CodeInfo */
      code_info?: {
        /** Format: uint64 */
        code_id?: string;
        creator?: string;
        /** Format: byte */
        data_hash?: string;
        /** @description AccessConfig access control type. */
        instantiate_permission?: {
          /**
           * AccessType permission types
           * @description - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
           *      - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
           *      - ACCESS_TYPE_ONLY_ADDRESS: AccessTypeOnlyAddress restricted to a single address
           *     Deprecated: use AccessTypeAnyOfAddresses instead
           *      - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
           *      - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
           * @default ACCESS_TYPE_UNSPECIFIED
           * @enum {string}
           */
          permission:
            | "ACCESS_TYPE_UNSPECIFIED"
            | "ACCESS_TYPE_NOBODY"
            | "ACCESS_TYPE_ONLY_ADDRESS"
            | "ACCESS_TYPE_EVERYBODY"
            | "ACCESS_TYPE_ANY_OF_ADDRESSES";
          /** Address
           *     Deprecated: replaced by addresses */
          address?: string;
          addresses?: string[];
        };
      };
      /** Format: byte */
      data?: string;
    };
    /** QueryCodesResponse is the response type for the Query/Codes RPC method */
    "cosmwasm.wasm.v1.QueryCodesResponse": {
      code_infos?: {
        /** Format: uint64 */
        code_id?: string;
        creator?: string;
        /** Format: byte */
        data_hash?: string;
        /** @description AccessConfig access control type. */
        instantiate_permission?: {
          /**
           * AccessType permission types
           * @description - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
           *      - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
           *      - ACCESS_TYPE_ONLY_ADDRESS: AccessTypeOnlyAddress restricted to a single address
           *     Deprecated: use AccessTypeAnyOfAddresses instead
           *      - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
           *      - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
           * @default ACCESS_TYPE_UNSPECIFIED
           * @enum {string}
           */
          permission:
            | "ACCESS_TYPE_UNSPECIFIED"
            | "ACCESS_TYPE_NOBODY"
            | "ACCESS_TYPE_ONLY_ADDRESS"
            | "ACCESS_TYPE_EVERYBODY"
            | "ACCESS_TYPE_ANY_OF_ADDRESSES";
          /** Address
           *     Deprecated: replaced by addresses */
          address?: string;
          addresses?: string[];
        };
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** QueryContractHistoryResponse is the response type for the
     *     Query/ContractHistory RPC method */
    "cosmwasm.wasm.v1.QueryContractHistoryResponse": {
      entries?: {
        /**
         * ContractCodeHistoryOperationType actions that caused a code change
         * @description - CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED: ContractCodeHistoryOperationTypeUnspecified placeholder for empty value
         *      - CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT: ContractCodeHistoryOperationTypeInit on chain contract instantiation
         *      - CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE: ContractCodeHistoryOperationTypeMigrate code migration
         *      - CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS: ContractCodeHistoryOperationTypeGenesis based on genesis data
         * @default CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED
         * @enum {string}
         */
        operation:
          | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"
          | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT"
          | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE"
          | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
        /**
         * CodeID is the reference to the stored WASM code
         * Format: uint64
         */
        code_id?: string;
        /** @description Updated Tx position when the operation was executed. */
        updated?: {
          /**
           * BlockHeight is the block the contract was created at
           * Format: uint64
           */
          block_height?: string;
          /**
           * TxIndex is a monotonic counter within the block (actual transaction index,
           *     or gas consumed)
           * Format: uint64
           */
          tx_index?: string;
        };
        /** Format: byte */
        msg?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** QueryContractInfoResponse is the response type for the Query/ContractInfo RPC
     *     method */
    "cosmwasm.wasm.v1.QueryContractInfoResponse": {
      /** address is the address of the contract */
      address?: string;
      /** ContractInfo stores a WASM contract instance */
      contract_info?: {
        /**
         * CodeID is the reference to the stored Wasm code
         * Format: uint64
         */
        code_id?: string;
        /** Creator address who initially instantiated the contract */
        creator?: string;
        /** Admin is an optional address that can execute migrations */
        admin?: string;
        /** @description Label is optional metadata to be stored with a contract instance. */
        label?: string;
        /** @description Created Tx position when the contract was instantiated. */
        created?: {
          /**
           * BlockHeight is the block the contract was created at
           * Format: uint64
           */
          block_height?: string;
          /**
           * TxIndex is a monotonic counter within the block (actual transaction index,
           *     or gas consumed)
           * Format: uint64
           */
          tx_index?: string;
        };
        ibc_port_id?: string;
        /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
         *     URL that describes the type of the serialized message.
         *
         *     Protobuf library provides support to pack/unpack Any values in the form
         *     of utility functions or additional generated methods of the Any type.
         *
         *     Example 1: Pack and unpack a message in C++.
         *
         *         Foo foo = ...;
         *         Any any;
         *         any.PackFrom(foo);
         *         ...
         *         if (any.UnpackTo(&foo)) {
         *           ...
         *         }
         *
         *     Example 2: Pack and unpack a message in Java.
         *
         *         Foo foo = ...;
         *         Any any = Any.pack(foo);
         *         ...
         *         if (any.is(Foo.class)) {
         *           foo = any.unpack(Foo.class);
         *         }
         *
         *      Example 3: Pack and unpack a message in Python.
         *
         *         foo = Foo(...)
         *         any = Any()
         *         any.Pack(foo)
         *         ...
         *         if any.Is(Foo.DESCRIPTOR):
         *           any.Unpack(foo)
         *           ...
         *
         *      Example 4: Pack and unpack a message in Go
         *
         *          foo := &pb.Foo{...}
         *          any, err := anypb.New(foo)
         *          if err != nil {
         *            ...
         *          }
         *          ...
         *          foo := &pb.Foo{}
         *          if err := any.UnmarshalTo(foo); err != nil {
         *            ...
         *          }
         *
         *     The pack methods provided by protobuf library will by default use
         *     'type.googleapis.com/full.type.name' as the type URL and the unpack
         *     methods only use the fully qualified type name after the last '/'
         *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
         *     name "y.z".
         *
         *
         *     JSON
         *     ====
         *     The JSON representation of an `Any` value uses the regular
         *     representation of the deserialized, embedded message, with an
         *     additional field `@type` which contains the type URL. Example:
         *
         *         package google.profile;
         *         message Person {
         *           string first_name = 1;
         *           string last_name = 2;
         *         }
         *
         *         {
         *           "@type": "type.googleapis.com/google.profile.Person",
         *           "firstName": <string>,
         *           "lastName": <string>
         *         }
         *
         *     If the embedded message type is well-known and has a custom JSON
         *     representation, that representation will be embedded adding a field
         *     `value` which holds the custom JSON in addition to the `@type`
         *     field. Example (for message [google.protobuf.Duration][]):
         *
         *         {
         *           "@type": "type.googleapis.com/google.protobuf.Duration",
         *           "value": "1.212s"
         *         } */
        extension?: {
          /** @description A URL/resource name that uniquely identifies the type of the serialized
           *     protocol buffer message. This string must contain at least
           *     one "/" character. The last segment of the URL's path must represent
           *     the fully qualified name of the type (as in
           *     `path/google.protobuf.Duration`). The name should be in a canonical form
           *     (e.g., leading "." is not accepted).
           *
           *     In practice, teams usually precompile into the binary all types that they
           *     expect it to use in the context of Any. However, for URLs which use the
           *     scheme `http`, `https`, or no scheme, one can optionally set up a type
           *     server that maps type URLs to message definitions as follows:
           *
           *     * If no scheme is provided, `https` is assumed.
           *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *       value in binary format, or produce an error.
           *     * Applications are allowed to cache lookup results based on the
           *       URL, or have them precompiled into a binary to avoid any
           *       lookup. Therefore, binary compatibility needs to be preserved
           *       on changes to types. (Use versioned type names to manage
           *       breaking changes.)
           *
           *     Note: this functionality is not currently available in the official
           *     protobuf release, and it is not used for type URLs beginning with
           *     type.googleapis.com.
           *
           *     Schemes other than `http`, `https` (or the empty scheme) might be
           *     used with implementation specific semantics. */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      };
    };
    /** QueryContractsByCodeResponse is the response type for the
     *     Query/ContractsByCode RPC method */
    "cosmwasm.wasm.v1.QueryContractsByCodeResponse": {
      /** contracts are a set of contract addresses */
      contracts?: string[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryContractsByCreatorResponse is the response type for the
     *     Query/ContractsByCreator RPC method. */
    "cosmwasm.wasm.v1.QueryContractsByCreatorResponse": {
      /** ContractAddresses result set */
      contract_addresses?: string[];
      /** @description Pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "cosmwasm.wasm.v1.QueryParamsResponse": {
      /** @description params defines the parameters of the module. */
      params?: {
        /** @description AccessConfig access control type. */
        code_upload_access?: {
          /**
           * AccessType permission types
           * @description - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
           *      - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
           *      - ACCESS_TYPE_ONLY_ADDRESS: AccessTypeOnlyAddress restricted to a single address
           *     Deprecated: use AccessTypeAnyOfAddresses instead
           *      - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
           *      - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
           * @default ACCESS_TYPE_UNSPECIFIED
           * @enum {string}
           */
          permission:
            | "ACCESS_TYPE_UNSPECIFIED"
            | "ACCESS_TYPE_NOBODY"
            | "ACCESS_TYPE_ONLY_ADDRESS"
            | "ACCESS_TYPE_EVERYBODY"
            | "ACCESS_TYPE_ANY_OF_ADDRESSES";
          /** Address
           *     Deprecated: replaced by addresses */
          address?: string;
          addresses?: string[];
        };
        /**
         * AccessType permission types
         * @description - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
         *      - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
         *      - ACCESS_TYPE_ONLY_ADDRESS: AccessTypeOnlyAddress restricted to a single address
         *     Deprecated: use AccessTypeAnyOfAddresses instead
         *      - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
         *      - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
         * @default ACCESS_TYPE_UNSPECIFIED
         * @enum {string}
         */
        instantiate_default_permission:
          | "ACCESS_TYPE_UNSPECIFIED"
          | "ACCESS_TYPE_NOBODY"
          | "ACCESS_TYPE_ONLY_ADDRESS"
          | "ACCESS_TYPE_EVERYBODY"
          | "ACCESS_TYPE_ANY_OF_ADDRESSES";
      };
    };
    /** QueryPinnedCodesResponse is the response type for the
     *     Query/PinnedCodes RPC method */
    "cosmwasm.wasm.v1.QueryPinnedCodesResponse": {
      code_ids?: string[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * next_key is the key to be passed to PageRequest.key to
         *     query the next page most efficiently
         * Format: byte
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         *     was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** QueryRawContractStateResponse is the response type for the
     *     Query/RawContractState RPC method */
    "cosmwasm.wasm.v1.QueryRawContractStateResponse": {
      /**
       * Data contains the raw store data
       * Format: byte
       */
      data?: string;
    };
    /** QuerySmartContractStateResponse is the response type for the
     *     Query/SmartContractState RPC method */
    "cosmwasm.wasm.v1.QuerySmartContractStateResponse": {
      /**
       * Data contains the json data returned from the smart contract
       * Format: byte
       */
      data?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: {
    KeygenOptInBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
        };
      };
    };
    DeregisterChainMaintainerBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chains?: string[];
        };
      };
    };
    CreateTransferOperatorshipBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          key_id?: string;
        };
      };
    };
    AddCustodianToGroupBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          guid?: string;
          /** Format: byte */
          custodian_pubkey?: string;
          description?: string;
        };
      };
    };
    SignBtcCommandBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
        };
      };
    };
    CreateCustodianGroupBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          uid?: string;
          name?: string;
          /** Format: int64 */
          quorum?: number;
          /**
           * @default STATUS_UNSPECIFIED
           * @enum {string}
           */
          status?:
            | "STATUS_UNSPECIFIED"
            | "STATUS_ACTIVATED"
            | "STATUS_DEACTIVATED"
            | "STATUS_PENDING";
          description?: string;
          custodian?: string[];
        };
      };
    };
  };
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  AddCosmosBasedChain: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          /** Chain represents the properties of a registered blockchain */
          chain?: {
            /** The descriptor of the chain, e.g. "evm|11155111" */
            name?: string;
            /** Format: boolean */
            supports_foreign_assets?: boolean;
            /**
             * @default KEY_TYPE_UNSPECIFIED
             * @enum {string}
             */
            key_type?:
              | "KEY_TYPE_UNSPECIFIED"
              | "KEY_TYPE_NONE"
              | "KEY_TYPE_THRESHOLD"
              | "KEY_TYPE_MULTISIG";
            /** the module has two types: chains and scalarnet */
            module?: string;
          };
          addr_prefix?: string;
          native_assets?: {
            denom?: string;
            /** Format: boolean */
            is_native_asset?: boolean;
          }[];
          /** TODO: Rename this to `chain` after v1beta1 -> v1 version bump */
          cosmos_chain?: string;
          ibc_path?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  CallContract: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          contract_address?: string;
          /** Format: byte */
          payload?: string;
          fee?: {
            /** @description Coin defines a token with a denomination and an amount.
             *
             *     NOTE: The amount field is an Int which implements the custom method
             *     signatures required by gogoproto. */
            amount?: {
              denom?: string;
              amount?: string;
            };
            /** Format: byte */
            recipient?: string;
            /** Format: byte */
            refund_recipient?: string;
          };
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ScalarConfirmDeposit: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          /** Format: byte */
          deposit_address?: string;
          denom?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ExecutePendingTransfers: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ScalarLink: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          recipient_addr?: string;
          recipient_chain?: string;
          asset?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            deposit_addr?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RegisterAsset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          asset?: {
            denom?: string;
            /** Format: boolean */
            is_native_asset?: boolean;
          };
          /** Format: byte */
          limit?: string;
          window?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RegisterFeeCollector: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          /** Format: byte */
          fee_collector?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RetryIBCTransfer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          /** Format: uint64 */
          id?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RouteIBCTransfers: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RouteMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          id?: string;
          /** Format: byte */
          payload?: string;
          /** Format: byte */
          feegranter?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ChainByIBCPath: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        ibc_path: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            chain?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  IBCPath: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            ibc_path?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  PendingIBCTransferCount: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            transfers_by_chain?: {
              [key: string]: number;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ScalarParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Params represent the genesis parameters for the module */
            params?: {
              /**
               * IBC packet route timeout window
               * Format: uint64
               */
              route_timeout_window?: string;
              /** Format: uint64 */
              transfer_limit?: string;
              /** Format: uint64 */
              end_blocker_limit?: string;
              /** Format: int64 */
              version?: number;
              /** Format: byte */
              tag?: string;
              call_contracts_proposal_min_deposits?: {
                chain?: string;
                contract_address?: string;
                min_deposits?: {
                  denom?: string;
                  amount?: string;
                }[];
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ConfirmTransferKey: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          /** Format: byte */
          tx_id?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  AddChain: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          name?: string;
          /** Format: byte */
          params?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  BatchedCommands: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
        /** @description id defines an optional id for the commandsbatch. If not specified the
         *     latest will be returned */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            id?: string;
            data?: string;
            /**
             * @default BATCHED_COMMANDS_STATUS_UNSPECIFIED
             * @enum {string}
             */
            status:
              | "BATCHED_COMMANDS_STATUS_UNSPECIFIED"
              | "BATCHED_COMMANDS_STATUS_SIGNING"
              | "BATCHED_COMMANDS_STATUS_ABORTED"
              | "BATCHED_COMMANDS_STATUS_SIGNED";
            key_id?: string;
            execute_data?: string;
            prev_batched_commands_id?: string;
            command_ids?: string[];
            proof?: {
              addresses?: string[];
              weights?: string[];
              threshold?: string;
              signatures?: string[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  BurnerInfo: {
    parameters: {
      query?: {
        address?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            chain?: string;
            burner_info?: {
              /** Format: byte */
              burner_address?: string;
              /** Format: byte */
              token_address?: string;
              destination_chain?: string;
              symbol?: string;
              asset?: string;
              /** Format: byte */
              salt?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Bytecode: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
        contract: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            bytecode?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ScalarChains: {
    parameters: {
      query?: {
        status?:
          | "CHAIN_STATUS_UNSPECIFIED"
          | "CHAIN_STATUS_ACTIVATED"
          | "CHAIN_STATUS_DEACTIVATED";
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            chains?: string[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Command: {
    parameters: {
      query?: {
        chain?: string;
        id?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            id?: string;
            type?: string;
            params?: {
              [key: string]: string;
            };
            key_id?: string;
            /** Format: int64 */
            max_gas_cost?: number;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ChainsConfirmDeposit: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          /** Format: byte */
          tx_id?: string;
          /** Format: byte */
          amount?: string;
          /** Format: byte */
          burner_address?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ConfirmSourceTxs: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          tx_ids?: string[];
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ConfirmToken: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          /** Format: byte */
          tx_id?: string;
          asset?: {
            chain?: string;
            symbol?: string;
          };
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ConfirmationHeight: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Format: uint64 */
            height?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  CreateBurnTokens: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  CreateDeployToken: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          token_symbol?: string;
          aliased_token_name?: string;
          /** Format: byte */
          address?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  CreatePendingTransfers: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  CreateTransferOperatorship: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components["requestBodies"]["CreateTransferOperatorshipBody"];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ERC20Tokens: {
    parameters: {
      query?: {
        type?:
          | "TOKEN_TYPE_UNSPECIFIED"
          | "TOKEN_TYPE_INTERNAL"
          | "TOKEN_TYPE_EXTERNAL";
      };
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            tokens?: {
              asset?: string;
              symbol?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Event: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
        event_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            event?: {
              chain?: string;
              /** Format: byte */
              tx_id?: string;
              /**
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_CONFIRMED"
                | "STATUS_COMPLETED"
                | "STATUS_FAILED";
              /** Format: uint64 */
              index?: string;
              token_sent?: {
                chain?: string;
                event_id?: string;
                /** Format: uint64 */
                transfer_id?: string;
                command_id?: string;
                sender?: string;
                destination_chain?: string;
                destination_address?: string;
                /** @description Coin defines a token with a denomination and an amount.
                 *
                 *     NOTE: The amount field is an Int which implements the custom method
                 *     signatures required by gogoproto. */
                asset?: {
                  denom?: string;
                  amount?: string;
                };
                /**
                 * Extra fields for form new utxo
                 * Format: byte
                 */
                script_pubkey?: string;
                /** Format: int64 */
                vout?: number;
              };
              contract_call?: {
                /** Format: byte */
                sender?: string;
                destination_chain?: string;
                contract_address?: string;
                /** Format: byte */
                payload_hash?: string;
              };
              contract_call_with_token?: {
                /** Format: byte */
                sender?: string;
                destination_chain?: string;
                contract_address?: string;
                /** Format: byte */
                payload_hash?: string;
                symbol?: string;
                /** Format: byte */
                amount?: string;
                /** Format: byte */
                payload?: string;
              };
              contract_call_with_mint_approved?: {
                chain?: string;
                event_id?: string;
                /** Format: byte */
                command_id?: string;
                sender?: string;
                destination_chain?: string;
                contract_address?: string;
                /** Format: byte */
                payload_hash?: string;
                /** @description Coin defines a token with a denomination and an amount.
                 *
                 *     NOTE: The amount field is an Int which implements the custom method
                 *     signatures required by gogoproto. */
                asset?: {
                  denom?: string;
                  amount?: string;
                };
              };
              transfer?: {
                /** Format: byte */
                to?: string;
                /** Format: byte */
                amount?: string;
              };
              token_deployed?: {
                symbol?: string;
                /** Format: byte */
                token_address?: string;
              };
              multisig_operatorship_transferred?: {
                new_operators?: string[];
                /** Format: byte */
                new_threshold?: string;
                new_weights?: string[];
              };
              /** for general chains */
              source_tx_confirmation_event?: {
                sender?: string;
                destination_chain?: string;
                /** Format: uint64 */
                amount?: string;
                asset?: string;
                /** Format: byte */
                payload_hash?: string;
                /** Format: byte */
                payload?: string;
                destination_contract_address?: string;
                destination_recipient_address?: string;
              };
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  GatewayAddress: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            address?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  KeyAddress: {
    parameters: {
      query?: {
        key_id?: string;
      };
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            key_id?: string;
            addresses?: {
              address?: string;
              weight?: string;
            }[];
            threshold?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ChainsLink: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          recipient_addr?: string;
          asset?: string;
          recipient_chain?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            deposit_addr?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ChainsParams: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            params?: {
              chain?: string;
              /** Format: uint64 */
              confirmation_height?: string;
              /** Format: int64 */
              network_kind?: number;
              /** Format: byte */
              token_code?: string;
              /** Format: byte */
              burnable?: string;
              /** Format: int64 */
              revote_locking_period?: string;
              /** Format: byte */
              chain_id?: string;
              voting_threshold?: {
                /**
                 * split threshold into Numerator and denominator to avoid floating point
                 *     errors down the line
                 * Format: int64
                 */
                numerator?: string;
                /** Format: int64 */
                denominator?: string;
              };
              /** Format: int64 */
              min_voter_count?: string;
              /** Format: int64 */
              commands_gas_limit?: number;
              /** Format: int64 */
              voting_grace_period?: string;
              /** Format: int64 */
              end_blocker_limit?: string;
              /** Format: uint64 */
              transfer_limit?: string;
              metadata?: {
                [key: string]: string;
              };
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  PendingCommands: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            commands?: {
              id?: string;
              type?: string;
              params?: {
                [key: string]: string;
              };
              key_id?: string;
              /** Format: int64 */
              max_gas_cost?: number;
              /** Format: byte */
              payload?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RedeemSession: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            redeem_session?: {
              /** Format: byte */
              custodian_group_uid?: string;
              /** Format: uint64 */
              sequence?: string;
              /**
               * @default PHASE_PREPARING
               * @enum {string}
               */
              current_phase: "PHASE_PREPARING" | "PHASE_EXECUTING";
            }[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RetryFailedEvent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          event_id?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SetGateway: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          /** Format: byte */
          address?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SignBtcCommand: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components["requestBodies"]["SignBtcCommandBody"];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Format: byte */
            batched_commands_id?: string;
            /** Format: int64 */
            command_count?: number;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SignCommands: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components["requestBodies"]["SignBtcCommandBody"];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Format: byte */
            batched_commands_id?: string;
            /** Format: int64 */
            command_count?: number;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  TokenInfo: {
    parameters: {
      query?: {
        asset?: string;
        symbol?: string;
        address?: string;
      };
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            asset?: string;
            details?: {
              token_name?: string;
              symbol?: string;
              /** Format: int64 */
              decimals?: number;
              /** Format: byte */
              capacity?: string;
            };
            address?: string;
            /** Format: boolean */
            confirmed?: boolean;
            /** Format: boolean */
            is_external?: boolean;
            burner_code_hash?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RegisterCustodianGroup: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          /** Format: byte */
          custodian_group_uid?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Protocols: {
    parameters: {
      query?: {
        pubkey?: string;
        address?: string;
        name?: string;
        status?:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            protocols?: {
              /** Format: byte */
              scalar_address?: string;
              /** Format: byte */
              bitcoin_pubkey?: string;
              name?: string;
              /** Format: byte */
              tag?: string;
              attributes?: {
                /**
                 * @default LIQUIDITY_MODEL_UNSPECIFIED
                 * @enum {string}
                 */
                model:
                  | "LIQUIDITY_MODEL_UNSPECIFIED"
                  | "LIQUIDITY_MODEL_POOL"
                  | "LIQUIDITY_MODEL_UPC";
              };
              /**
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              /** Format: byte */
              custodian_group_uid?: string;
              chains?: {
                chain?: string;
                name?: string;
                address?: string;
              }[];
              /** Format: byte */
              avatar?: string;
              /** CustodianGroup represents a group of custodians with their configuration
               *     uid is used as identity of the group, btc_pubkey is change by list of
               *     custodians */
              custodian_group?: {
                /**
                 * the UID is unique, to distinguish between custodian groups
                 * Format: byte
                 */
                uid?: string;
                name?: string;
                /** Format: byte */
                bitcoin_pubkey?: string;
                /**
                 * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
                 * Format: int64
                 */
                quorum?: number;
                /**
                 * @default STATUS_UNSPECIFIED
                 * @enum {string}
                 */
                status:
                  | "STATUS_UNSPECIFIED"
                  | "STATUS_ACTIVATED"
                  | "STATUS_DEACTIVATED"
                  | "STATUS_PENDING";
                description?: string;
                custodians?: {
                  name?: string;
                  val_address?: string;
                  /** Format: byte */
                  bitcoin_pubkey?: string;
                  /**
                   * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
                   * @default STATUS_UNSPECIFIED
                   * @enum {string}
                   */
                  status:
                    | "STATUS_UNSPECIFIED"
                    | "STATUS_ACTIVATED"
                    | "STATUS_DEACTIVATED"
                    | "STATUS_PENDING";
                  description?: string;
                }[];
              };
              asset?: {
                chain?: string;
                symbol?: string;
              };
              token_details?: {
                token_name?: string;
                symbol?: string;
                /** Format: int64 */
                decimals?: number;
                /** Format: byte */
                capacity?: string;
              };
              /** Format: byte */
              token_daily_mint_limit?: string;
            }[];
            /** Format: uint64 */
            total?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  AddSupportedChain: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: {
            chain?: string;
            name?: string;
            address?: string;
          };
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            protocol?: {
              /** Format: byte */
              bitcoin_pubkey?: string;
              /** Format: byte */
              scalar_address?: string;
              name?: string;
              /** Format: byte */
              tag?: string;
              attributes?: {
                /**
                 * @default LIQUIDITY_MODEL_UNSPECIFIED
                 * @enum {string}
                 */
                model:
                  | "LIQUIDITY_MODEL_UNSPECIFIED"
                  | "LIQUIDITY_MODEL_POOL"
                  | "LIQUIDITY_MODEL_UPC";
              };
              /**
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              /** Format: byte */
              custodian_group_uid?: string;
              chains?: {
                chain?: string;
                name?: string;
                address?: string;
              }[];
              /** Format: byte */
              avatar?: string;
              asset?: {
                chain?: string;
                symbol?: string;
              };
              token_details?: {
                token_name?: string;
                symbol?: string;
                /** Format: int64 */
                decimals?: number;
                /** Format: byte */
                capacity?: string;
              };
              /** Format: byte */
              token_daily_mint_limit?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  CreateProtocol: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * // TODO: Consider to add rbac for this message
           *     option (permission.exported.v1beta1.permission_role) =
           *     ROLE_CHAIN_MANAGEMENT;
           * Format: byte
           */
          sender?: string;
          /** Format: byte */
          bitcoin_pubkey?: string;
          name?: string;
          tag?: string;
          attributes?: {
            /**
             * @default LIQUIDITY_MODEL_UNSPECIFIED
             * @enum {string}
             */
            model?:
              | "LIQUIDITY_MODEL_UNSPECIFIED"
              | "LIQUIDITY_MODEL_POOL"
              | "LIQUIDITY_MODEL_UPC";
          };
          /** Format: byte */
          custodian_group_uid?: string;
          /** Format: byte */
          avatar?: string;
          asset?: {
            chain?: string;
            symbol?: string;
          };
          token_name?: string;
          /** Format: int64 */
          token_decimals?: number;
          token_capacity?: string;
          token_daily_mint_limit?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            protocol?: {
              /** Format: byte */
              bitcoin_pubkey?: string;
              /** Format: byte */
              scalar_address?: string;
              name?: string;
              /** Format: byte */
              tag?: string;
              attributes?: {
                /**
                 * @default LIQUIDITY_MODEL_UNSPECIFIED
                 * @enum {string}
                 */
                model:
                  | "LIQUIDITY_MODEL_UNSPECIFIED"
                  | "LIQUIDITY_MODEL_POOL"
                  | "LIQUIDITY_MODEL_UPC";
              };
              /**
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              /** Format: byte */
              custodian_group_uid?: string;
              chains?: {
                chain?: string;
                name?: string;
                address?: string;
              }[];
              /** Format: byte */
              avatar?: string;
              asset?: {
                chain?: string;
                symbol?: string;
              };
              token_details?: {
                token_name?: string;
                symbol?: string;
                /** Format: int64 */
                decimals?: number;
                /** Format: byte */
                capacity?: string;
              };
              /** Format: byte */
              token_daily_mint_limit?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Protocol: {
    parameters: {
      query?: {
        origin_chain?: string;
        minor_chain?: string;
        symbol?: string;
        address?: string;
        sender?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            protocol?: {
              /** Format: byte */
              scalar_address?: string;
              /** Format: byte */
              bitcoin_pubkey?: string;
              name?: string;
              /** Format: byte */
              tag?: string;
              attributes?: {
                /**
                 * @default LIQUIDITY_MODEL_UNSPECIFIED
                 * @enum {string}
                 */
                model:
                  | "LIQUIDITY_MODEL_UNSPECIFIED"
                  | "LIQUIDITY_MODEL_POOL"
                  | "LIQUIDITY_MODEL_UPC";
              };
              /**
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              /** Format: byte */
              custodian_group_uid?: string;
              chains?: {
                chain?: string;
                name?: string;
                address?: string;
              }[];
              /** Format: byte */
              avatar?: string;
              /** CustodianGroup represents a group of custodians with their configuration
               *     uid is used as identity of the group, btc_pubkey is change by list of
               *     custodians */
              custodian_group?: {
                /**
                 * the UID is unique, to distinguish between custodian groups
                 * Format: byte
                 */
                uid?: string;
                name?: string;
                /** Format: byte */
                bitcoin_pubkey?: string;
                /**
                 * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
                 * Format: int64
                 */
                quorum?: number;
                /**
                 * @default STATUS_UNSPECIFIED
                 * @enum {string}
                 */
                status:
                  | "STATUS_UNSPECIFIED"
                  | "STATUS_ACTIVATED"
                  | "STATUS_DEACTIVATED"
                  | "STATUS_PENDING";
                description?: string;
                custodians?: {
                  name?: string;
                  val_address?: string;
                  /** Format: byte */
                  bitcoin_pubkey?: string;
                  /**
                   * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
                   * @default STATUS_UNSPECIFIED
                   * @enum {string}
                   */
                  status:
                    | "STATUS_UNSPECIFIED"
                    | "STATUS_ACTIVATED"
                    | "STATUS_DEACTIVATED"
                    | "STATUS_PENDING";
                  description?: string;
                }[];
              };
              asset?: {
                chain?: string;
                symbol?: string;
              };
              token_details?: {
                token_name?: string;
                symbol?: string;
                /** Format: int64 */
                decimals?: number;
                /** Format: byte */
                capacity?: string;
              };
              /** Format: byte */
              token_daily_mint_limit?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  UpdateProtocol: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          name?: string;
          tag?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            protocol?: {
              /** Format: byte */
              bitcoin_pubkey?: string;
              /** Format: byte */
              scalar_address?: string;
              name?: string;
              /** Format: byte */
              tag?: string;
              attributes?: {
                /**
                 * @default LIQUIDITY_MODEL_UNSPECIFIED
                 * @enum {string}
                 */
                model:
                  | "LIQUIDITY_MODEL_UNSPECIFIED"
                  | "LIQUIDITY_MODEL_POOL"
                  | "LIQUIDITY_MODEL_UPC";
              };
              /**
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              /** Format: byte */
              custodian_group_uid?: string;
              chains?: {
                chain?: string;
                name?: string;
                address?: string;
              }[];
              /** Format: byte */
              avatar?: string;
              asset?: {
                chain?: string;
                symbol?: string;
              };
              token_details?: {
                token_name?: string;
                symbol?: string;
                /** Format: int64 */
                decimals?: number;
                /** Format: byte */
                capacity?: string;
              };
              /** Format: byte */
              token_daily_mint_limit?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  UpdateSupportedChain: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain_family?: string;
          /** Format: uint64 */
          chain_id?: string;
          /**
           * @default STATUS_UNSPECIFIED
           * @enum {string}
           */
          status?:
            | "STATUS_UNSPECIFIED"
            | "STATUS_ACTIVATED"
            | "STATUS_DEACTIVATED"
            | "STATUS_PENDING";
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            protocol?: {
              /** Format: byte */
              bitcoin_pubkey?: string;
              /** Format: byte */
              scalar_address?: string;
              name?: string;
              /** Format: byte */
              tag?: string;
              attributes?: {
                /**
                 * @default LIQUIDITY_MODEL_UNSPECIFIED
                 * @enum {string}
                 */
                model:
                  | "LIQUIDITY_MODEL_UNSPECIFIED"
                  | "LIQUIDITY_MODEL_POOL"
                  | "LIQUIDITY_MODEL_UPC";
              };
              /**
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              /** Format: byte */
              custodian_group_uid?: string;
              chains?: {
                chain?: string;
                name?: string;
                address?: string;
              }[];
              /** Format: byte */
              avatar?: string;
              asset?: {
                chain?: string;
                symbol?: string;
              };
              token_details?: {
                token_name?: string;
                symbol?: string;
                /** Format: int64 */
                decimals?: number;
                /** Format: byte */
                capacity?: string;
              };
              /** Format: byte */
              token_daily_mint_limit?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ReserveRedeemUtxo: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          address?: string;
          source_chain?: string;
          dest_chain?: string;
          symbol?: string;
          /** Format: uint64 */
          amount?: string;
          /** Format: byte */
          locking_script?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Custodians: {
    parameters: {
      query?: {
        name?: string;
        pubkey?: string;
        status?:
          | "STATUS_UNSPECIFIED"
          | "STATUS_ACTIVATED"
          | "STATUS_DEACTIVATED"
          | "STATUS_PENDING";
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            custodians?: {
              name?: string;
              val_address?: string;
              /** Format: byte */
              bitcoin_pubkey?: string;
              /**
               * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              description?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  AddCustodianToGroup: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components["requestBodies"]["AddCustodianToGroupBody"];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** CustodianGroup represents a group of custodians with their configuration
             *     uid is used as identity of the group, btc_pubkey is change by list of
             *     custodians */
            group?: {
              /**
               * the UID is unique, to distinguish between custodian groups
               * Format: byte
               */
              uid?: string;
              name?: string;
              /** Format: byte */
              bitcoin_pubkey?: string;
              /**
               * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
               * Format: int64
               */
              quorum?: number;
              /**
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              description?: string;
              custodians?: {
                name?: string;
                val_address?: string;
                /** Format: byte */
                bitcoin_pubkey?: string;
                /**
                 * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
                 * @default STATUS_UNSPECIFIED
                 * @enum {string}
                 */
                status:
                  | "STATUS_UNSPECIFIED"
                  | "STATUS_ACTIVATED"
                  | "STATUS_DEACTIVATED"
                  | "STATUS_PENDING";
                description?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ConfirmRedeemTxs: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          tx_ids?: string[];
          /** Format: byte */
          custodian_group_uid?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ConfirmSwitchedPhase: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          /** Format: byte */
          custodian_group_uid?: string;
          /** Format: byte */
          tx_id?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  CreateCustodian: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          name?: string;
          /** Format: byte */
          bitcoin_pubkey?: string;
          /**
           * @default STATUS_UNSPECIFIED
           * @enum {string}
           */
          status?:
            | "STATUS_UNSPECIFIED"
            | "STATUS_ACTIVATED"
            | "STATUS_DEACTIVATED"
            | "STATUS_PENDING";
          description?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Custodian represents an individual custodian configuration */
            custodian?: {
              name?: string;
              val_address?: string;
              /** Format: byte */
              bitcoin_pubkey?: string;
              /**
               * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              description?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  CreateCustodianGroup: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components["requestBodies"]["CreateCustodianGroupBody"];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** CustodianGroup represents a group of custodians with their configuration
             *     uid is used as identity of the group, btc_pubkey is change by list of
             *     custodians */
            group?: {
              /**
               * the UID is unique, to distinguish between custodian groups
               * Format: byte
               */
              uid?: string;
              name?: string;
              /** Format: byte */
              bitcoin_pubkey?: string;
              /**
               * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
               * Format: int64
               */
              quorum?: number;
              /**
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              description?: string;
              custodians?: {
                name?: string;
                val_address?: string;
                /** Format: byte */
                bitcoin_pubkey?: string;
                /**
                 * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
                 * @default STATUS_UNSPECIFIED
                 * @enum {string}
                 */
                status:
                  | "STATUS_UNSPECIFIED"
                  | "STATUS_ACTIVATED"
                  | "STATUS_DEACTIVATED"
                  | "STATUS_PENDING";
                description?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Groups: {
    parameters: {
      query?: {
        uid?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            groups?: {
              /**
               * the UID is unique, to distinguish between custodian groups
               * Format: byte
               */
              uid?: string;
              name?: string;
              /** Format: byte */
              bitcoin_pubkey?: string;
              /**
               * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
               * Format: int64
               */
              quorum?: number;
              /**
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              description?: string;
              custodians?: {
                name?: string;
                val_address?: string;
                /** Format: byte */
                bitcoin_pubkey?: string;
                /**
                 * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
                 * @default STATUS_UNSPECIFIED
                 * @enum {string}
                 */
                status:
                  | "STATUS_UNSPECIFIED"
                  | "STATUS_ACTIVATED"
                  | "STATUS_DEACTIVATED"
                  | "STATUS_PENDING";
                description?: string;
              }[];
            }[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  InitializeUtxo: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          /** Format: uint64 */
          block_checkpoint?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  CovenantParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Params represent the genesis parameters for the module */
            params?: {
              signing_threshold?: {
                /**
                 * split threshold into Numerator and denominator to avoid floating point
                 *     errors down the line
                 * Format: int64
                 */
                numerator?: string;
                /** Format: int64 */
                denominator?: string;
              };
              /** Format: int64 */
              signing_timeout?: string;
              /** Format: int64 */
              signing_grace_period?: string;
              /** Format: uint64 */
              active_epoch_count?: string;
              /** Format: uint64 */
              block_limit_per_session?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  CovenantRedeemSession: {
    parameters: {
      query?: {
        uid?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            session?: {
              /** Format: byte */
              custodian_group_uid?: string;
              /** Format: uint64 */
              sequence?: string;
              /**
               * @default PHASE_PREPARING
               * @enum {string}
               */
              current_phase: "PHASE_PREPARING" | "PHASE_EXECUTING";
              /** Format: byte */
              last_redeem_tx?: string;
              /** Format: boolean */
              is_switching?: boolean;
              /** Format: uint64 */
              phase_expired_at?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RemoveCustodianFromGroup: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components["requestBodies"]["AddCustodianToGroupBody"];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** CustodianGroup represents a group of custodians with their configuration
             *     uid is used as identity of the group, btc_pubkey is change by list of
             *     custodians */
            group?: {
              /**
               * the UID is unique, to distinguish between custodian groups
               * Format: byte
               */
              uid?: string;
              name?: string;
              /** Format: byte */
              bitcoin_pubkey?: string;
              /**
               * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
               * Format: int64
               */
              quorum?: number;
              /**
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              description?: string;
              custodians?: {
                name?: string;
                val_address?: string;
                /** Format: byte */
                bitcoin_pubkey?: string;
                /**
                 * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
                 * @default STATUS_UNSPECIFIED
                 * @enum {string}
                 */
                status:
                  | "STATUS_UNSPECIFIED"
                  | "STATUS_ACTIVATED"
                  | "STATUS_DEACTIVATED"
                  | "STATUS_PENDING";
                description?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  CovenantRotateKey: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  StandaloneCommand: {
    parameters: {
      query?: {
        id?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Format: byte */
            id?: string;
            data?: string;
            /**
             * @default STANDALONE_COMMAND_STATUS_UNSPECIFIED
             * @enum {string}
             */
            status:
              | "STANDALONE_COMMAND_STATUS_UNSPECIFIED"
              | "STANDALONE_COMMAND_STATUS_SIGNING"
              | "STANDALONE_COMMAND_STATUS_ABORTED"
              | "STANDALONE_COMMAND_STATUS_SIGNED";
            key_id?: string;
            execute_data?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SubmitTapScriptSigs: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          /** Format: uint64 */
          sig_id?: string;
          list_of_tap_script_sigs_map?: {
            inner?: {
              /** Format: uint64 */
              index?: string;
              sigs?: {
                list?: {
                  /** Format: byte */
                  key_x_only?: string;
                  /** Format: byte */
                  leaf_hash?: string;
                  /** Format: byte */
                  signature?: string;
                }[];
              };
            }[];
          }[];
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  UpdateCustodian: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          /** Format: byte */
          bitcoin_pubkey?: string;
          name?: string;
          /**
           * @default STATUS_UNSPECIFIED
           * @enum {string}
           */
          status?:
            | "STATUS_UNSPECIFIED"
            | "STATUS_ACTIVATED"
            | "STATUS_DEACTIVATED"
            | "STATUS_PENDING";
          description?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Custodian represents an individual custodian configuration */
            custodian?: {
              name?: string;
              val_address?: string;
              /** Format: byte */
              bitcoin_pubkey?: string;
              /**
               * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              description?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  UpdateCustodianGroup: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components["requestBodies"]["CreateCustodianGroupBody"];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** CustodianGroup represents a group of custodians with their configuration
             *     uid is used as identity of the group, btc_pubkey is change by list of
             *     custodians */
            group?: {
              /**
               * the UID is unique, to distinguish between custodian groups
               * Format: byte
               */
              uid?: string;
              name?: string;
              /** Format: byte */
              bitcoin_pubkey?: string;
              /**
               * "tb1p07q440mdl4uyywns325dk8pvjphwety3psp4zvkngtjf3z3hhr2sfar3hv"
               * Format: int64
               */
              quorum?: number;
              /**
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_ACTIVATED"
                | "STATUS_DEACTIVATED"
                | "STATUS_PENDING";
              description?: string;
              custodians?: {
                name?: string;
                val_address?: string;
                /** Format: byte */
                bitcoin_pubkey?: string;
                /**
                 * "0215da913b3e87b4932b1e1b87d9667c28e7250aa0ed60b3a31095f541e1641488"
                 * @default STATUS_UNSPECIFIED
                 * @enum {string}
                 */
                status:
                  | "STATUS_UNSPECIFIED"
                  | "STATUS_ACTIVATED"
                  | "STATUS_DEACTIVATED"
                  | "STATUS_PENDING";
                description?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  UTXOSnapshot: {
    parameters: {
      query?: {
        uid?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            utxo_snapshot?: {
              /** Format: byte */
              custodian_group_uid?: string;
              /** Format: uint64 */
              block_height?: string;
              utxos?: {
                /** Format: byte */
                txid?: string;
                /** Format: int64 */
                vout?: number;
                /** Format: byte */
                script_pubkey?: string;
                /** Format: uint64 */
                amount_in_sats?: string;
                /** Reserved amount for each request id */
                reserved?: {
                  [key: string]: string;
                };
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RotateKey: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components["requestBodies"]["CreateTransferOperatorshipBody"];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  StartKeygen: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          sender?: string;
          key_id?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SubmitPubKey: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          sender?: string;
          key_id?: string;
          /** Format: byte */
          pub_key?: string;
          /** Format: byte */
          signature?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SubmitSignature: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          sender?: string;
          /** Format: uint64 */
          sig_id?: string;
          /** Format: byte */
          signature?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Key: {
    parameters: {
      query?: {
        key_id?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            key_id?: string;
            /**
             * @default KEY_STATE_UNSPECIFIED
             * @enum {string}
             */
            state:
              | "KEY_STATE_UNSPECIFIED"
              | "KEY_STATE_ASSIGNED"
              | "KEY_STATE_ACTIVE";
            /** Format: int64 */
            started_at?: string;
            /** Format: date-time */
            started_at_timestamp?: string;
            /** Format: byte */
            threshold_weight?: string;
            /** Format: byte */
            bonded_weight?: string;
            /** Keygen participants in descending order by weight */
            participants?: {
              address?: string;
              /** Format: byte */
              weight?: string;
              pub_key?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  KeyID: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            key_id?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  KeygenOptIn: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components["requestBodies"]["KeygenOptInBody"];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  KeygenOptOut: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components["requestBodies"]["KeygenOptInBody"];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  KeygenSession: {
    parameters: {
      query?: {
        key_id?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Format: int64 */
            started_at?: string;
            /** Format: date-time */
            started_at_timestamp?: string;
            /** Format: int64 */
            expires_at?: string;
            /** Format: int64 */
            completed_at?: string;
            /** Format: int64 */
            grace_period?: string;
            /**
             * @default MULTISIG_STATE_UNSPECIFIED
             * @enum {string}
             */
            state:
              | "MULTISIG_STATE_UNSPECIFIED"
              | "MULTISIG_STATE_PENDING"
              | "MULTISIG_STATE_COMPLETED";
            /** Format: byte */
            keygen_threshold_weight?: string;
            /** Format: byte */
            signing_threshold_weight?: string;
            /** Format: byte */
            bonded_weight?: string;
            /** Keygen candidates in descending order by weight */
            participants?: {
              address?: string;
              /** Format: byte */
              weight?: string;
              pub_key?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  NextKeyID: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            key_id?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  MultisigParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Params represent the genesis parameters for the module */
            params?: {
              keygen_threshold?: {
                /**
                 * split threshold into Numerator and denominator to avoid floating point
                 *     errors down the line
                 * Format: int64
                 */
                numerator?: string;
                /** Format: int64 */
                denominator?: string;
              };
              signing_threshold?: {
                /**
                 * split threshold into Numerator and denominator to avoid floating point
                 *     errors down the line
                 * Format: int64
                 */
                numerator?: string;
                /** Format: int64 */
                denominator?: string;
              };
              /** Format: int64 */
              keygen_timeout?: string;
              /** Format: int64 */
              keygen_grace_period?: string;
              /** Format: int64 */
              signing_timeout?: string;
              /** Format: int64 */
              signing_grace_period?: string;
              /** Format: uint64 */
              active_epoch_count?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ActivateChain: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chains?: string[];
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DeactivateChain: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chains?: string[];
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DeregisterChainMaintainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components["requestBodies"]["DeregisterChainMaintainerBody"];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RegisterAssetFee: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          fee_info?: {
            chain?: string;
            asset?: string;
            /** Format: byte */
            fee_rate?: string;
            /** Format: byte */
            min_fee?: string;
            /** Format: byte */
            max_fee?: string;
          };
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RegisterChainMaintainer: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components["requestBodies"]["DeregisterChainMaintainerBody"];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SetTransferRateLimit: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          chain?: string;
          /** @description Coin defines a token with a denomination and an amount.
           *
           *     NOTE: The amount field is an Int which implements the custom method
           *     signatures required by gogoproto. */
          limit?: {
            denom?: string;
            amount?: string;
          };
          window?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Assets: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            assets?: string[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ChainMaintainers: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            maintainers?: string[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ChainState: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** ChainState represents the state of a registered blockchain */
            state?: {
              /** Chain represents the properties of a registered blockchain */
              chain?: {
                /** The descriptor of the chain, e.g. "evm|11155111" */
                name?: string;
                /** Format: boolean */
                supports_foreign_assets?: boolean;
                /**
                 * @default KEY_TYPE_UNSPECIFIED
                 * @enum {string}
                 */
                key_type:
                  | "KEY_TYPE_UNSPECIFIED"
                  | "KEY_TYPE_NONE"
                  | "KEY_TYPE_THRESHOLD"
                  | "KEY_TYPE_MULTISIG";
                /** the module has two types: chains and scalarnet */
                module?: string;
              };
              /** Format: boolean */
              activated?: boolean;
              assets?: {
                denom?: string;
                /** Format: boolean */
                is_native_asset?: boolean;
              }[];
              maintainer_states?: {
                /** Format: byte */
                address?: string;
                missing_votes?: {
                  true_count_cache?: {
                    cumulative_value?: string[];
                    /** Format: int32 */
                    index?: number;
                    /** Format: int32 */
                    max_size?: number;
                  };
                };
                incorrect_votes?: {
                  true_count_cache?: {
                    cumulative_value?: string[];
                    /** Format: int32 */
                    index?: number;
                    /** Format: int32 */
                    max_size?: number;
                  };
                };
                chain?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Chains: {
    parameters: {
      query?: {
        status?:
          | "CHAIN_STATUS_UNSPECIFIED"
          | "CHAIN_STATUS_ACTIVATED"
          | "CHAIN_STATUS_DEACTIVATED";
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            chains?: string[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ChainsByAsset: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        asset: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            chains?: string[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  FeeInfo2: {
    parameters: {
      query?: {
        chain?: string;
        asset?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            fee_info?: {
              chain?: string;
              asset?: string;
              /** Format: byte */
              fee_rate?: string;
              /** Format: byte */
              min_fee?: string;
              /** Format: byte */
              max_fee?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  FeeInfo: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
        asset: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            fee_info?: {
              chain?: string;
              asset?: string;
              /** Format: byte */
              fee_rate?: string;
              /** Format: byte */
              min_fee?: string;
              /** Format: byte */
              max_fee?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  LatestDepositAddress: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        recipient_addr: string;
        recipient_chain: string;
        deposit_chain: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            deposit_addr?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Message: {
    parameters: {
      query?: {
        id?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            message?: {
              id?: string;
              /** CrossChainAddress represents a generalized address on any registered chain */
              sender?: {
                /** Chain represents the properties of a registered blockchain */
                chain?: {
                  /** The descriptor of the chain, e.g. "evm|11155111" */
                  name?: string;
                  /** Format: boolean */
                  supports_foreign_assets?: boolean;
                  /**
                   * @default KEY_TYPE_UNSPECIFIED
                   * @enum {string}
                   */
                  key_type:
                    | "KEY_TYPE_UNSPECIFIED"
                    | "KEY_TYPE_NONE"
                    | "KEY_TYPE_THRESHOLD"
                    | "KEY_TYPE_MULTISIG";
                  /** the module has two types: chains and scalarnet */
                  module?: string;
                };
                address?: string;
              };
              /** CrossChainAddress represents a generalized address on any registered chain */
              recipient?: {
                /** Chain represents the properties of a registered blockchain */
                chain?: {
                  /** The descriptor of the chain, e.g. "evm|11155111" */
                  name?: string;
                  /** Format: boolean */
                  supports_foreign_assets?: boolean;
                  /**
                   * @default KEY_TYPE_UNSPECIFIED
                   * @enum {string}
                   */
                  key_type:
                    | "KEY_TYPE_UNSPECIFIED"
                    | "KEY_TYPE_NONE"
                    | "KEY_TYPE_THRESHOLD"
                    | "KEY_TYPE_MULTISIG";
                  /** the module has two types: chains and scalarnet */
                  module?: string;
                };
                address?: string;
              };
              /** Format: byte */
              payload_hash?: string;
              /**
               * @default STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "STATUS_UNSPECIFIED"
                | "STATUS_APPROVED"
                | "STATUS_PROCESSING"
                | "STATUS_EXECUTED"
                | "STATUS_FAILED";
              /** @description Coin defines a token with a denomination and an amount.
               *
               *     NOTE: The amount field is an Int which implements the custom method
               *     signatures required by gogoproto. */
              asset?: {
                denom?: string;
                amount?: string;
              };
              /** Format: byte */
              source_tx_id?: string;
              /** Format: uint64 */
              source_tx_index?: string;
              /**
               * Additional data for the message, metadata is encoded in the payload, it can
               *     be fee information, etc. It will be used later when enqueuing the command
               *     and batch command. Currently, the main purpose is use to form the psbt for
               *     btc
               * Format: byte
               */
              payload?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  NexusParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Params represent the genesis parameters for the module */
            params?: {
              chain_activation_threshold?: {
                /**
                 * split threshold into Numerator and denominator to avoid floating point
                 *     errors down the line
                 * Format: int64
                 */
                numerator?: string;
                /** Format: int64 */
                denominator?: string;
              };
              chain_maintainer_missing_vote_threshold?: {
                /**
                 * split threshold into Numerator and denominator to avoid floating point
                 *     errors down the line
                 * Format: int64
                 */
                numerator?: string;
                /** Format: int64 */
                denominator?: string;
              };
              chain_maintainer_incorrect_vote_threshold?: {
                /**
                 * split threshold into Numerator and denominator to avoid floating point
                 *     errors down the line
                 * Format: int64
                 */
                numerator?: string;
                /** Format: int64 */
                denominator?: string;
              };
              /** Format: int32 */
              chain_maintainer_check_window?: number;
              /** Format: byte */
              gateway?: string;
              /** Format: uint64 */
              end_blocker_limit?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RecipientAddress: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        deposit_chain: string;
        deposit_addr: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            recipient_addr?: string;
            recipient_chain?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  TransferFee2: {
    parameters: {
      query?: {
        source_chain?: string;
        destination_chain?: string;
        amount?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description Coin defines a token with a denomination and an amount.
             *
             *     NOTE: The amount field is an Int which implements the custom method
             *     signatures required by gogoproto. */
            fee?: {
              denom?: string;
              amount?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  TransferFee: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        source_chain: string;
        destination_chain: string;
        amount: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description Coin defines a token with a denomination and an amount.
             *
             *     NOTE: The amount field is an Int which implements the custom method
             *     signatures required by gogoproto. */
            fee?: {
              denom?: string;
              amount?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  TransferRateLimit: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        chain: string;
        asset: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            transfer_rate_limit?: {
              /** Format: byte */
              limit?: string;
              window?: string;
              /** Format: byte */
              incoming?: string;
              /** Format: byte */
              outgoing?: string;
              /** time_left indicates the time left in the rate limit window */
              time_left?: string;
              /** Format: byte */
              from?: string;
              /** Format: byte */
              to?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  TransfersForChain: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        chain: string;
        state:
          | "TRANSFER_STATE_UNSPECIFIED"
          | "TRANSFER_STATE_PENDING"
          | "TRANSFER_STATE_ARCHIVED"
          | "TRANSFER_STATE_INSUFFICIENT_AMOUNT"
          | "TRANSFER_STATE_FAILED";
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            transfers?: {
              /** CrossChainAddress represents a generalized address on any registered chain */
              recipient?: {
                /** Chain represents the properties of a registered blockchain */
                chain?: {
                  /** The descriptor of the chain, e.g. "evm|11155111" */
                  name?: string;
                  /** Format: boolean */
                  supports_foreign_assets?: boolean;
                  /**
                   * @default KEY_TYPE_UNSPECIFIED
                   * @enum {string}
                   */
                  key_type:
                    | "KEY_TYPE_UNSPECIFIED"
                    | "KEY_TYPE_NONE"
                    | "KEY_TYPE_THRESHOLD"
                    | "KEY_TYPE_MULTISIG";
                  /** the module has two types: chains and scalarnet */
                  module?: string;
                };
                address?: string;
              };
              /** @description Coin defines a token with a denomination and an amount.
               *
               *     NOTE: The amount field is an Int which implements the custom method
               *     signatures required by gogoproto. */
              asset?: {
                denom?: string;
                amount?: string;
              };
              /** Format: uint64 */
              id?: string;
              /**
               * @default TRANSFER_STATE_UNSPECIFIED
               * @enum {string}
               */
              state:
                | "TRANSFER_STATE_UNSPECIFIED"
                | "TRANSFER_STATE_PENDING"
                | "TRANSFER_STATE_ARCHIVED"
                | "TRANSFER_STATE_INSUFFICIENT_AMOUNT"
                | "TRANSFER_STATE_FAILED";
              /** Format: byte */
              source_tx_hash?: string;
            }[];
            /** @description PageResponse is to be embedded in gRPC response messages where the
             *     corresponding request message has used PageRequest.
             *
             *      message SomeResponse {
             *              repeated Bar results = 1;
             *              PageResponse page = 2;
             *      } */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RefundMsg: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
           *     URL that describes the type of the serialized message.
           *
           *     Protobuf library provides support to pack/unpack Any values in the form
           *     of utility functions or additional generated methods of the Any type.
           *
           *     Example 1: Pack and unpack a message in C++.
           *
           *         Foo foo = ...;
           *         Any any;
           *         any.PackFrom(foo);
           *         ...
           *         if (any.UnpackTo(&foo)) {
           *           ...
           *         }
           *
           *     Example 2: Pack and unpack a message in Java.
           *
           *         Foo foo = ...;
           *         Any any = Any.pack(foo);
           *         ...
           *         if (any.is(Foo.class)) {
           *           foo = any.unpack(Foo.class);
           *         }
           *
           *      Example 3: Pack and unpack a message in Python.
           *
           *         foo = Foo(...)
           *         any = Any()
           *         any.Pack(foo)
           *         ...
           *         if any.Is(Foo.DESCRIPTOR):
           *           any.Unpack(foo)
           *           ...
           *
           *      Example 4: Pack and unpack a message in Go
           *
           *          foo := &pb.Foo{...}
           *          any, err := anypb.New(foo)
           *          if err != nil {
           *            ...
           *          }
           *          ...
           *          foo := &pb.Foo{}
           *          if err := any.UnmarshalTo(foo); err != nil {
           *            ...
           *          }
           *
           *     The pack methods provided by protobuf library will by default use
           *     'type.googleapis.com/full.type.name' as the type URL and the unpack
           *     methods only use the fully qualified type name after the last '/'
           *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
           *     name "y.z".
           *
           *
           *     JSON
           *     ====
           *     The JSON representation of an `Any` value uses the regular
           *     representation of the deserialized, embedded message, with an
           *     additional field `@type` which contains the type URL. Example:
           *
           *         package google.profile;
           *         message Person {
           *           string first_name = 1;
           *           string last_name = 2;
           *         }
           *
           *         {
           *           "@type": "type.googleapis.com/google.profile.Person",
           *           "firstName": <string>,
           *           "lastName": <string>
           *         }
           *
           *     If the embedded message type is well-known and has a custom JSON
           *     representation, that representation will be embedded adding a field
           *     `value` which holds the custom JSON in addition to the `@type`
           *     field. Example (for message [google.protobuf.Duration][]):
           *
           *         {
           *           "@type": "type.googleapis.com/google.protobuf.Duration",
           *           "value": "1.212s"
           *         } */
          inner_message?: {
            /** @description A URL/resource name that uniquely identifies the type of the serialized
             *     protocol buffer message. This string must contain at least
             *     one "/" character. The last segment of the URL's path must represent
             *     the fully qualified name of the type (as in
             *     `path/google.protobuf.Duration`). The name should be in a canonical form
             *     (e.g., leading "." is not accepted).
             *
             *     In practice, teams usually precompile into the binary all types that they
             *     expect it to use in the context of Any. However, for URLs which use the
             *     scheme `http`, `https`, or no scheme, one can optionally set up a type
             *     server that maps type URLs to message definitions as follows:
             *
             *     * If no scheme is provided, `https` is assumed.
             *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *       value in binary format, or produce an error.
             *     * Applications are allowed to cache lookup results based on the
             *       URL, or have them precompiled into a binary to avoid any
             *       lookup. Therefore, binary compatibility needs to be preserved
             *       on changes to types. (Use versioned type names to manage
             *       breaking changes.)
             *
             *     Note: this functionality is not currently available in the official
             *     protobuf release, and it is not used for type URLs beginning with
             *     type.googleapis.com.
             *
             *     Schemes other than `http`, `https` (or the empty scheme) might be
             *     used with implementation specific semantics. */
            type_url?: string;
            /**
             * Format: byte
             * @description Must be a valid serialized protocol buffer of the above specified type.
             */
            value?: string;
          };
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Format: byte */
            data?: string;
            log?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  InflationRate2: {
    parameters: {
      query?: {
        validator?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Format: byte */
            inflation_rate?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  InflationRate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        validator: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Format: byte */
            inflation_rate?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RewardParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Params represent the genesis parameters for the module */
            params?: {
              /** Format: byte */
              external_chain_voting_inflation_rate?: string;
              /** Format: byte */
              key_mgmt_relative_inflation_rate?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DeactivateProxy: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components["requestBodies"]["KeygenOptInBody"];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RegisterProxy: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          /** Format: byte */
          proxy_addr?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SnapshotParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Params represent the genesis parameters for the module */
            params?: {
              /** Format: int64 */
              min_proxy_balance?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  HeartBeat: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          /** Deprecated: this field will be removed in the next release */
          key_ids?: string[];
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  TSSParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Params is the parameter set for this module */
            params?: {
              /** KeyRequirements defines the requirement for each key role */
              key_requirements?: {
                /**
                 * @default KEY_ROLE_UNSPECIFIED
                 * @enum {string}
                 */
                key_role:
                  | "KEY_ROLE_UNSPECIFIED"
                  | "KEY_ROLE_MASTER_KEY"
                  | "KEY_ROLE_SECONDARY_KEY"
                  | "KEY_ROLE_EXTERNAL_KEY";
                /**
                 * @default KEY_TYPE_UNSPECIFIED
                 * @enum {string}
                 */
                key_type:
                  | "KEY_TYPE_UNSPECIFIED"
                  | "KEY_TYPE_NONE"
                  | "KEY_TYPE_THRESHOLD"
                  | "KEY_TYPE_MULTISIG";
                min_keygen_threshold?: {
                  /**
                   * split threshold into Numerator and denominator to avoid floating point
                   *     errors down the line
                   * Format: int64
                   */
                  numerator?: string;
                  /** Format: int64 */
                  denominator?: string;
                };
                safety_threshold?: {
                  /**
                   * split threshold into Numerator and denominator to avoid floating point
                   *     errors down the line
                   * Format: int64
                   */
                  numerator?: string;
                  /** Format: int64 */
                  denominator?: string;
                };
                /**
                 * @default KEY_SHARE_DISTRIBUTION_POLICY_UNSPECIFIED
                 * @enum {string}
                 */
                key_share_distribution_policy:
                  | "KEY_SHARE_DISTRIBUTION_POLICY_UNSPECIFIED"
                  | "KEY_SHARE_DISTRIBUTION_POLICY_WEIGHTED_BY_STAKE"
                  | "KEY_SHARE_DISTRIBUTION_POLICY_ONE_PER_VALIDATOR";
                /** Format: int64 */
                max_total_share_count?: string;
                /** Format: int64 */
                min_total_share_count?: string;
                keygen_voting_threshold?: {
                  /**
                   * split threshold into Numerator and denominator to avoid floating point
                   *     errors down the line
                   * Format: int64
                   */
                  numerator?: string;
                  /** Format: int64 */
                  denominator?: string;
                };
                sign_voting_threshold?: {
                  /**
                   * split threshold into Numerator and denominator to avoid floating point
                   *     errors down the line
                   * Format: int64
                   */
                  numerator?: string;
                  /** Format: int64 */
                  denominator?: string;
                };
                /** Format: int64 */
                keygen_timeout?: string;
                /** Format: int64 */
                sign_timeout?: string;
              }[];
              /**
               * SuspendDurationInBlocks defines the number of blocks a
               *     validator is disallowed to participate in any TSS ceremony after
               *     committing a malicious behaviour during signing
               * Format: int64
               */
              suspend_duration_in_blocks?: string;
              /**
               * HeartBeatPeriodInBlocks defines the time period in blocks for tss to
               *     emit the event asking validators to send their heartbeats
               * Format: int64
               */
              heartbeat_period_in_blocks?: string;
              max_missed_blocks_per_window?: {
                /**
                 * split threshold into Numerator and denominator to avoid floating point
                 *     errors down the line
                 * Format: int64
                 */
                numerator?: string;
                /** Format: int64 */
                denominator?: string;
              };
              /** Format: int64 */
              unbonding_locking_key_rotation_count?: string;
              external_multisig_threshold?: {
                /**
                 * split threshold into Numerator and denominator to avoid floating point
                 *     errors down the line
                 * Format: int64
                 */
                numerator?: string;
                /** Format: int64 */
                denominator?: string;
              };
              /** Format: int64 */
              max_sign_queue_size?: string;
              /** Format: int64 */
              max_simultaneous_sign_shares?: string;
              /** Format: int64 */
              tss_signed_blocks_window?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DeregisterController: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          /** Format: byte */
          controller?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RegisterController: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          /** Format: byte */
          controller?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  UpdateGovernanceKey: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          /** @description LegacyAminoPubKey specifies a public key type
           *     which nests multiple public keys and a threshold,
           *     it uses legacy amino address rules. */
          governance_key?: {
            /** Format: int64 */
            threshold?: number;
            public_keys?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": Record<string, never>;
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  GovernanceKey: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description LegacyAminoPubKey specifies a public key type
             *     which nests multiple public keys and a threshold,
             *     it uses legacy amino address rules. */
            governance_key?: {
              /** Format: int64 */
              threshold?: number;
              public_keys?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  PermissionParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Params represent the genesis parameters for the module */
            params?: Record<string, never>;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  VoteParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Params represent the genesis parameters for the module */
            params?: {
              default_voting_threshold?: {
                /**
                 * split threshold into Numerator and denominator to avoid floating point
                 *     errors down the line
                 * Format: int64
                 */
                numerator?: string;
                /** Format: int64 */
                denominator?: string;
              };
              /** Format: int64 */
              end_blocker_limit?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ScalarVote: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** Format: byte */
          sender?: string;
          /** Format: uint64 */
          poll_id?: string;
          /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
           *     URL that describes the type of the serialized message.
           *
           *     Protobuf library provides support to pack/unpack Any values in the form
           *     of utility functions or additional generated methods of the Any type.
           *
           *     Example 1: Pack and unpack a message in C++.
           *
           *         Foo foo = ...;
           *         Any any;
           *         any.PackFrom(foo);
           *         ...
           *         if (any.UnpackTo(&foo)) {
           *           ...
           *         }
           *
           *     Example 2: Pack and unpack a message in Java.
           *
           *         Foo foo = ...;
           *         Any any = Any.pack(foo);
           *         ...
           *         if (any.is(Foo.class)) {
           *           foo = any.unpack(Foo.class);
           *         }
           *
           *      Example 3: Pack and unpack a message in Python.
           *
           *         foo = Foo(...)
           *         any = Any()
           *         any.Pack(foo)
           *         ...
           *         if any.Is(Foo.DESCRIPTOR):
           *           any.Unpack(foo)
           *           ...
           *
           *      Example 4: Pack and unpack a message in Go
           *
           *          foo := &pb.Foo{...}
           *          any, err := anypb.New(foo)
           *          if err != nil {
           *            ...
           *          }
           *          ...
           *          foo := &pb.Foo{}
           *          if err := any.UnmarshalTo(foo); err != nil {
           *            ...
           *          }
           *
           *     The pack methods provided by protobuf library will by default use
           *     'type.googleapis.com/full.type.name' as the type URL and the unpack
           *     methods only use the fully qualified type name after the last '/'
           *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
           *     name "y.z".
           *
           *
           *     JSON
           *     ====
           *     The JSON representation of an `Any` value uses the regular
           *     representation of the deserialized, embedded message, with an
           *     additional field `@type` which contains the type URL. Example:
           *
           *         package google.profile;
           *         message Person {
           *           string first_name = 1;
           *           string last_name = 2;
           *         }
           *
           *         {
           *           "@type": "type.googleapis.com/google.profile.Person",
           *           "firstName": <string>,
           *           "lastName": <string>
           *         }
           *
           *     If the embedded message type is well-known and has a custom JSON
           *     representation, that representation will be embedded adding a field
           *     `value` which holds the custom JSON in addition to the `@type`
           *     field. Example (for message [google.protobuf.Duration][]):
           *
           *         {
           *           "@type": "type.googleapis.com/google.protobuf.Duration",
           *           "value": "1.212s"
           *         } */
          vote?: {
            /** @description A URL/resource name that uniquely identifies the type of the serialized
             *     protocol buffer message. This string must contain at least
             *     one "/" character. The last segment of the URL's path must represent
             *     the fully qualified name of the type (as in
             *     `path/google.protobuf.Duration`). The name should be in a canonical form
             *     (e.g., leading "." is not accepted).
             *
             *     In practice, teams usually precompile into the binary all types that they
             *     expect it to use in the context of Any. However, for URLs which use the
             *     scheme `http`, `https`, or no scheme, one can optionally set up a type
             *     server that maps type URLs to message definitions as follows:
             *
             *     * If no scheme is provided, `https` is assumed.
             *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *       value in binary format, or produce an error.
             *     * Applications are allowed to cache lookup results based on the
             *       URL, or have them precompiled into a binary to avoid any
             *       lookup. Therefore, binary compatibility needs to be preserved
             *       on changes to types. (Use versioned type names to manage
             *       breaking changes.)
             *
             *     Note: this functionality is not currently available in the official
             *     protobuf release, and it is not used for type URLs beginning with
             *     type.googleapis.com.
             *
             *     Schemes other than `http`, `https` (or the empty scheme) might be
             *     used with implementation specific semantics. */
            type_url?: string;
            /**
             * Format: byte
             * @description Must be a valid serialized protocol buffer of the above specified type.
             */
            value?: string;
          };
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            log?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Accounts: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** accounts are the existing accounts */
            accounts?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Account: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description address defines the address to query for. */
        address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
             *     URL that describes the type of the serialized message.
             *
             *     Protobuf library provides support to pack/unpack Any values in the form
             *     of utility functions or additional generated methods of the Any type.
             *
             *     Example 1: Pack and unpack a message in C++.
             *
             *         Foo foo = ...;
             *         Any any;
             *         any.PackFrom(foo);
             *         ...
             *         if (any.UnpackTo(&foo)) {
             *           ...
             *         }
             *
             *     Example 2: Pack and unpack a message in Java.
             *
             *         Foo foo = ...;
             *         Any any = Any.pack(foo);
             *         ...
             *         if (any.is(Foo.class)) {
             *           foo = any.unpack(Foo.class);
             *         }
             *
             *      Example 3: Pack and unpack a message in Python.
             *
             *         foo = Foo(...)
             *         any = Any()
             *         any.Pack(foo)
             *         ...
             *         if any.Is(Foo.DESCRIPTOR):
             *           any.Unpack(foo)
             *           ...
             *
             *      Example 4: Pack and unpack a message in Go
             *
             *          foo := &pb.Foo{...}
             *          any, err := anypb.New(foo)
             *          if err != nil {
             *            ...
             *          }
             *          ...
             *          foo := &pb.Foo{}
             *          if err := any.UnmarshalTo(foo); err != nil {
             *            ...
             *          }
             *
             *     The pack methods provided by protobuf library will by default use
             *     'type.googleapis.com/full.type.name' as the type URL and the unpack
             *     methods only use the fully qualified type name after the last '/'
             *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
             *     name "y.z".
             *
             *
             *     JSON
             *     ====
             *     The JSON representation of an `Any` value uses the regular
             *     representation of the deserialized, embedded message, with an
             *     additional field `@type` which contains the type URL. Example:
             *
             *         package google.profile;
             *         message Person {
             *           string first_name = 1;
             *           string last_name = 2;
             *         }
             *
             *         {
             *           "@type": "type.googleapis.com/google.profile.Person",
             *           "firstName": <string>,
             *           "lastName": <string>
             *         }
             *
             *     If the embedded message type is well-known and has a custom JSON
             *     representation, that representation will be embedded adding a field
             *     `value` which holds the custom JSON in addition to the `@type`
             *     field. Example (for message [google.protobuf.Duration][]):
             *
             *         {
             *           "@type": "type.googleapis.com/google.protobuf.Duration",
             *           "value": "1.212s"
             *         } */
            account?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ModuleAccountByName: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
             *     URL that describes the type of the serialized message.
             *
             *     Protobuf library provides support to pack/unpack Any values in the form
             *     of utility functions or additional generated methods of the Any type.
             *
             *     Example 1: Pack and unpack a message in C++.
             *
             *         Foo foo = ...;
             *         Any any;
             *         any.PackFrom(foo);
             *         ...
             *         if (any.UnpackTo(&foo)) {
             *           ...
             *         }
             *
             *     Example 2: Pack and unpack a message in Java.
             *
             *         Foo foo = ...;
             *         Any any = Any.pack(foo);
             *         ...
             *         if (any.is(Foo.class)) {
             *           foo = any.unpack(Foo.class);
             *         }
             *
             *      Example 3: Pack and unpack a message in Python.
             *
             *         foo = Foo(...)
             *         any = Any()
             *         any.Pack(foo)
             *         ...
             *         if any.Is(Foo.DESCRIPTOR):
             *           any.Unpack(foo)
             *           ...
             *
             *      Example 4: Pack and unpack a message in Go
             *
             *          foo := &pb.Foo{...}
             *          any, err := anypb.New(foo)
             *          if err != nil {
             *            ...
             *          }
             *          ...
             *          foo := &pb.Foo{}
             *          if err := any.UnmarshalTo(foo); err != nil {
             *            ...
             *          }
             *
             *     The pack methods provided by protobuf library will by default use
             *     'type.googleapis.com/full.type.name' as the type URL and the unpack
             *     methods only use the fully qualified type name after the last '/'
             *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
             *     name "y.z".
             *
             *
             *     JSON
             *     ====
             *     The JSON representation of an `Any` value uses the regular
             *     representation of the deserialized, embedded message, with an
             *     additional field `@type` which contains the type URL. Example:
             *
             *         package google.profile;
             *         message Person {
             *           string first_name = 1;
             *           string last_name = 2;
             *         }
             *
             *         {
             *           "@type": "type.googleapis.com/google.profile.Person",
             *           "firstName": <string>,
             *           "lastName": <string>
             *         }
             *
             *     If the embedded message type is well-known and has a custom JSON
             *     representation, that representation will be embedded adding a field
             *     `value` which holds the custom JSON in addition to the `@type`
             *     field. Example (for message [google.protobuf.Duration][]):
             *
             *         {
             *           "@type": "type.googleapis.com/google.protobuf.Duration",
             *           "value": "1.212s"
             *         } */
            account?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  AuthParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description params defines the parameters of the module. */
            params?: {
              /** Format: uint64 */
              max_memo_characters?: string;
              /** Format: uint64 */
              tx_sig_limit?: string;
              /** Format: uint64 */
              tx_size_cost_per_byte?: string;
              /** Format: uint64 */
              sig_verify_cost_ed25519?: string;
              /** Format: uint64 */
              sig_verify_cost_secp256k1?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  AllBalances: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description address is the address to query balances for. */
        address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description balances is the balances of all the coins. */
            balances?: {
              denom?: string;
              amount?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Balance: {
    parameters: {
      query?: {
        /** @description denom is the coin denom to query balances for. */
        denom?: string;
      };
      header?: never;
      path: {
        /** @description address is the address to query balances for. */
        address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description Coin defines a token with a denomination and an amount.
             *
             *     NOTE: The amount field is an Int which implements the custom method
             *     signatures required by gogoproto. */
            balance?: {
              denom?: string;
              amount?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DenomsMetadata: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description metadata provides the client information for all the registered tokens. */
            metadatas?: {
              description?: string;
              /** denom_units represents the list of DenomUnit's for a given coin */
              denom_units?: {
                /** @description denom represents the string name of the given denom unit (e.g uatom). */
                denom?: string;
                /**
                 * Format: int64
                 * @description exponent represents power of 10 exponent that one must
                 *     raise the base_denom to in order to equal the given DenomUnit's denom
                 *     1 denom = 1^exponent base_denom
                 *     (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
                 *     exponent = 6, thus: 1 atom = 10^6 uatom).
                 */
                exponent?: number;
                /** aliases is a list of string aliases for the given denom */
                aliases?: string[];
              }[];
              /** @description base represents the base denom (should be the DenomUnit with exponent = 0). */
              base?: string;
              /** @description display indicates the suggested denom that should be
               *     displayed in clients. */
              display?: string;
              /**
               * name defines the name of the token (eg: Cosmos Atom)
               * @description Since: cosmos-sdk 0.43
               */
              name?: string;
              /** @description symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
               *     be the same as the display.
               *
               *     Since: cosmos-sdk 0.43 */
              symbol?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DenomMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description denom is the coin denom to query the metadata for. */
        denom: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description Metadata represents a struct that describes
             *     a basic token. */
            metadata?: {
              description?: string;
              /** denom_units represents the list of DenomUnit's for a given coin */
              denom_units?: {
                /** @description denom represents the string name of the given denom unit (e.g uatom). */
                denom?: string;
                /**
                 * Format: int64
                 * @description exponent represents power of 10 exponent that one must
                 *     raise the base_denom to in order to equal the given DenomUnit's denom
                 *     1 denom = 1^exponent base_denom
                 *     (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
                 *     exponent = 6, thus: 1 atom = 10^6 uatom).
                 */
                exponent?: number;
                /** aliases is a list of string aliases for the given denom */
                aliases?: string[];
              }[];
              /** @description base represents the base denom (should be the DenomUnit with exponent = 0). */
              base?: string;
              /** @description display indicates the suggested denom that should be
               *     displayed in clients. */
              display?: string;
              /**
               * name defines the name of the token (eg: Cosmos Atom)
               * @description Since: cosmos-sdk 0.43
               */
              name?: string;
              /** @description symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
               *     be the same as the display.
               *
               *     Since: cosmos-sdk 0.43 */
              symbol?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  BankParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description Params defines the parameters for the bank module. */
            params?: {
              send_enabled?: {
                denom?: string;
                /** Format: boolean */
                enabled?: boolean;
              }[];
              /** Format: boolean */
              default_send_enabled?: boolean;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SpendableBalances: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description address is the address to query spendable balances for. */
        address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description balances is the spendable balances of all the coins. */
            balances?: {
              denom?: string;
              amount?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  TotalSupply: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** supply is the supply of the coins */
            supply?: {
              denom?: string;
              amount?: string;
            }[];
            /** @description pagination defines the pagination in the response.
             *
             *     Since: cosmos-sdk 0.43 */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SupplyOf: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description denom is the coin denom to query balances for. */
        denom: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description Coin defines a token with a denomination and an amount.
             *
             *     NOTE: The amount field is an Int which implements the custom method
             *     signatures required by gogoproto. */
            amount?: {
              denom?: string;
              amount?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  GetLatestBlock: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** BlockID */
            block_id?: {
              /** Format: byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** Format: int64 */
                total?: number;
                /** Format: byte */
                hash?: string;
              };
            };
            block?: {
              /** @description Header defines the structure of a block header. */
              header?: {
                /**
                 * basic block info
                 * @description Consensus captures the consensus rules for processing a block in the blockchain,
                 *     including all blockchain data structures and the rules of the application's
                 *     state transition machine.
                 */
                version?: {
                  /** Format: uint64 */
                  block?: string;
                  /** Format: uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** Format: int64 */
                height?: string;
                /** Format: date-time */
                time?: string;
                /** BlockID */
                last_block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * Format: byte
                 */
                last_commit_hash?: string;
                /** Format: byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * Format: byte
                 */
                validators_hash?: string;
                /** Format: byte */
                next_validators_hash?: string;
                /** Format: byte */
                consensus_hash?: string;
                /** Format: byte */
                app_hash?: string;
                /** Format: byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * Format: byte
                 */
                evidence_hash?: string;
                /** Format: byte */
                proposer_address?: string;
              };
              /** Data contains the set of transactions included in the block */
              data?: {
                /** @description Txs that will be applied by state @ block.Height+1.
                 *     NOTE: not all txs here are valid.  We're just agreeing on the order first.
                 *     This means that block.AppHash does not include these txs. */
                txs?: string[];
              };
              evidence?: {
                evidence?: {
                  /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
                  duplicate_vote_evidence?: {
                    /** @description Vote represents a prevote, precommit, or commit vote from validators for
                     *     consensus. */
                    vote_a?: {
                      /**
                       * @description SignedMsgType is a type of signed message in the consensus.
                       *
                       *      - SIGNED_MSG_TYPE_PREVOTE: Votes
                       *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                       * @default SIGNED_MSG_TYPE_UNKNOWN
                       * @enum {string}
                       */
                      type:
                        | "SIGNED_MSG_TYPE_UNKNOWN"
                        | "SIGNED_MSG_TYPE_PREVOTE"
                        | "SIGNED_MSG_TYPE_PRECOMMIT"
                        | "SIGNED_MSG_TYPE_PROPOSAL";
                      /** Format: int64 */
                      height?: string;
                      /** Format: int32 */
                      round?: number;
                      /** BlockID */
                      block_id?: {
                        /** Format: byte */
                        hash?: string;
                        /** PartsetHeader */
                        part_set_header?: {
                          /** Format: int64 */
                          total?: number;
                          /** Format: byte */
                          hash?: string;
                        };
                      };
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: int32 */
                      validator_index?: number;
                      /** Format: byte */
                      signature?: string;
                    };
                    /** @description Vote represents a prevote, precommit, or commit vote from validators for
                     *     consensus. */
                    vote_b?: {
                      /**
                       * @description SignedMsgType is a type of signed message in the consensus.
                       *
                       *      - SIGNED_MSG_TYPE_PREVOTE: Votes
                       *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                       * @default SIGNED_MSG_TYPE_UNKNOWN
                       * @enum {string}
                       */
                      type:
                        | "SIGNED_MSG_TYPE_UNKNOWN"
                        | "SIGNED_MSG_TYPE_PREVOTE"
                        | "SIGNED_MSG_TYPE_PRECOMMIT"
                        | "SIGNED_MSG_TYPE_PROPOSAL";
                      /** Format: int64 */
                      height?: string;
                      /** Format: int32 */
                      round?: number;
                      /** BlockID */
                      block_id?: {
                        /** Format: byte */
                        hash?: string;
                        /** PartsetHeader */
                        part_set_header?: {
                          /** Format: int64 */
                          total?: number;
                          /** Format: byte */
                          hash?: string;
                        };
                      };
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: int32 */
                      validator_index?: number;
                      /** Format: byte */
                      signature?: string;
                    };
                    /** Format: int64 */
                    total_voting_power?: string;
                    /** Format: int64 */
                    validator_power?: string;
                    /** Format: date-time */
                    timestamp?: string;
                  };
                  /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
                  light_client_attack_evidence?: {
                    conflicting_block?: {
                      signed_header?: {
                        /** @description Header defines the structure of a block header. */
                        header?: {
                          /**
                           * basic block info
                           * @description Consensus captures the consensus rules for processing a block in the blockchain,
                           *     including all blockchain data structures and the rules of the application's
                           *     state transition machine.
                           */
                          version?: {
                            /** Format: uint64 */
                            block?: string;
                            /** Format: uint64 */
                            app?: string;
                          };
                          chain_id?: string;
                          /** Format: int64 */
                          height?: string;
                          /** Format: date-time */
                          time?: string;
                          /** BlockID */
                          last_block_id?: {
                            /** Format: byte */
                            hash?: string;
                            /** PartsetHeader */
                            part_set_header?: {
                              /** Format: int64 */
                              total?: number;
                              /** Format: byte */
                              hash?: string;
                            };
                          };
                          /**
                           * hashes of block data
                           * Format: byte
                           */
                          last_commit_hash?: string;
                          /** Format: byte */
                          data_hash?: string;
                          /**
                           * hashes from the app output from the prev block
                           * Format: byte
                           */
                          validators_hash?: string;
                          /** Format: byte */
                          next_validators_hash?: string;
                          /** Format: byte */
                          consensus_hash?: string;
                          /** Format: byte */
                          app_hash?: string;
                          /** Format: byte */
                          last_results_hash?: string;
                          /**
                           * consensus info
                           * Format: byte
                           */
                          evidence_hash?: string;
                          /** Format: byte */
                          proposer_address?: string;
                        };
                        /** @description Commit contains the evidence that a block was committed by a set of validators. */
                        commit?: {
                          /** Format: int64 */
                          height?: string;
                          /** Format: int32 */
                          round?: number;
                          /** BlockID */
                          block_id?: {
                            /** Format: byte */
                            hash?: string;
                            /** PartsetHeader */
                            part_set_header?: {
                              /** Format: int64 */
                              total?: number;
                              /** Format: byte */
                              hash?: string;
                            };
                          };
                          signatures?: {
                            /**
                             * BlockIdFlag indicates which BlcokID the signature is for
                             * @default BLOCK_ID_FLAG_UNKNOWN
                             * @enum {string}
                             */
                            block_id_flag:
                              | "BLOCK_ID_FLAG_UNKNOWN"
                              | "BLOCK_ID_FLAG_ABSENT"
                              | "BLOCK_ID_FLAG_COMMIT"
                              | "BLOCK_ID_FLAG_NIL";
                            /** Format: byte */
                            validator_address?: string;
                            /** Format: date-time */
                            timestamp?: string;
                            /** Format: byte */
                            signature?: string;
                          }[];
                        };
                      };
                      validator_set?: {
                        validators?: {
                          /** Format: byte */
                          address?: string;
                          /** PublicKey defines the keys available for use with Validators */
                          pub_key?: {
                            /** Format: byte */
                            ed25519?: string;
                            /** Format: byte */
                            secp256k1?: string;
                          };
                          /** Format: int64 */
                          voting_power?: string;
                          /** Format: int64 */
                          proposer_priority?: string;
                        }[];
                        proposer?: {
                          /** Format: byte */
                          address?: string;
                          /** PublicKey defines the keys available for use with Validators */
                          pub_key?: {
                            /** Format: byte */
                            ed25519?: string;
                            /** Format: byte */
                            secp256k1?: string;
                          };
                          /** Format: int64 */
                          voting_power?: string;
                          /** Format: int64 */
                          proposer_priority?: string;
                        };
                        /** Format: int64 */
                        total_voting_power?: string;
                      };
                    };
                    /** Format: int64 */
                    common_height?: string;
                    byzantine_validators?: {
                      /** Format: byte */
                      address?: string;
                      /** PublicKey defines the keys available for use with Validators */
                      pub_key?: {
                        /** Format: byte */
                        ed25519?: string;
                        /** Format: byte */
                        secp256k1?: string;
                      };
                      /** Format: int64 */
                      voting_power?: string;
                      /** Format: int64 */
                      proposer_priority?: string;
                    }[];
                    /** Format: int64 */
                    total_voting_power?: string;
                    /** Format: date-time */
                    timestamp?: string;
                  };
                }[];
              };
              /** @description Commit contains the evidence that a block was committed by a set of validators. */
              last_commit?: {
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                signatures?: {
                  /**
                   * BlockIdFlag indicates which BlcokID the signature is for
                   * @default BLOCK_ID_FLAG_UNKNOWN
                   * @enum {string}
                   */
                  block_id_flag:
                    | "BLOCK_ID_FLAG_UNKNOWN"
                    | "BLOCK_ID_FLAG_ABSENT"
                    | "BLOCK_ID_FLAG_COMMIT"
                    | "BLOCK_ID_FLAG_NIL";
                  /** Format: byte */
                  validator_address?: string;
                  /** Format: date-time */
                  timestamp?: string;
                  /** Format: byte */
                  signature?: string;
                }[];
              };
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  GetBlockByHeight: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        height: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** BlockID */
            block_id?: {
              /** Format: byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** Format: int64 */
                total?: number;
                /** Format: byte */
                hash?: string;
              };
            };
            block?: {
              /** @description Header defines the structure of a block header. */
              header?: {
                /**
                 * basic block info
                 * @description Consensus captures the consensus rules for processing a block in the blockchain,
                 *     including all blockchain data structures and the rules of the application's
                 *     state transition machine.
                 */
                version?: {
                  /** Format: uint64 */
                  block?: string;
                  /** Format: uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** Format: int64 */
                height?: string;
                /** Format: date-time */
                time?: string;
                /** BlockID */
                last_block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * Format: byte
                 */
                last_commit_hash?: string;
                /** Format: byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * Format: byte
                 */
                validators_hash?: string;
                /** Format: byte */
                next_validators_hash?: string;
                /** Format: byte */
                consensus_hash?: string;
                /** Format: byte */
                app_hash?: string;
                /** Format: byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * Format: byte
                 */
                evidence_hash?: string;
                /** Format: byte */
                proposer_address?: string;
              };
              /** Data contains the set of transactions included in the block */
              data?: {
                /** @description Txs that will be applied by state @ block.Height+1.
                 *     NOTE: not all txs here are valid.  We're just agreeing on the order first.
                 *     This means that block.AppHash does not include these txs. */
                txs?: string[];
              };
              evidence?: {
                evidence?: {
                  /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
                  duplicate_vote_evidence?: {
                    /** @description Vote represents a prevote, precommit, or commit vote from validators for
                     *     consensus. */
                    vote_a?: {
                      /**
                       * @description SignedMsgType is a type of signed message in the consensus.
                       *
                       *      - SIGNED_MSG_TYPE_PREVOTE: Votes
                       *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                       * @default SIGNED_MSG_TYPE_UNKNOWN
                       * @enum {string}
                       */
                      type:
                        | "SIGNED_MSG_TYPE_UNKNOWN"
                        | "SIGNED_MSG_TYPE_PREVOTE"
                        | "SIGNED_MSG_TYPE_PRECOMMIT"
                        | "SIGNED_MSG_TYPE_PROPOSAL";
                      /** Format: int64 */
                      height?: string;
                      /** Format: int32 */
                      round?: number;
                      /** BlockID */
                      block_id?: {
                        /** Format: byte */
                        hash?: string;
                        /** PartsetHeader */
                        part_set_header?: {
                          /** Format: int64 */
                          total?: number;
                          /** Format: byte */
                          hash?: string;
                        };
                      };
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: int32 */
                      validator_index?: number;
                      /** Format: byte */
                      signature?: string;
                    };
                    /** @description Vote represents a prevote, precommit, or commit vote from validators for
                     *     consensus. */
                    vote_b?: {
                      /**
                       * @description SignedMsgType is a type of signed message in the consensus.
                       *
                       *      - SIGNED_MSG_TYPE_PREVOTE: Votes
                       *      - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                       * @default SIGNED_MSG_TYPE_UNKNOWN
                       * @enum {string}
                       */
                      type:
                        | "SIGNED_MSG_TYPE_UNKNOWN"
                        | "SIGNED_MSG_TYPE_PREVOTE"
                        | "SIGNED_MSG_TYPE_PRECOMMIT"
                        | "SIGNED_MSG_TYPE_PROPOSAL";
                      /** Format: int64 */
                      height?: string;
                      /** Format: int32 */
                      round?: number;
                      /** BlockID */
                      block_id?: {
                        /** Format: byte */
                        hash?: string;
                        /** PartsetHeader */
                        part_set_header?: {
                          /** Format: int64 */
                          total?: number;
                          /** Format: byte */
                          hash?: string;
                        };
                      };
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: int32 */
                      validator_index?: number;
                      /** Format: byte */
                      signature?: string;
                    };
                    /** Format: int64 */
                    total_voting_power?: string;
                    /** Format: int64 */
                    validator_power?: string;
                    /** Format: date-time */
                    timestamp?: string;
                  };
                  /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
                  light_client_attack_evidence?: {
                    conflicting_block?: {
                      signed_header?: {
                        /** @description Header defines the structure of a block header. */
                        header?: {
                          /**
                           * basic block info
                           * @description Consensus captures the consensus rules for processing a block in the blockchain,
                           *     including all blockchain data structures and the rules of the application's
                           *     state transition machine.
                           */
                          version?: {
                            /** Format: uint64 */
                            block?: string;
                            /** Format: uint64 */
                            app?: string;
                          };
                          chain_id?: string;
                          /** Format: int64 */
                          height?: string;
                          /** Format: date-time */
                          time?: string;
                          /** BlockID */
                          last_block_id?: {
                            /** Format: byte */
                            hash?: string;
                            /** PartsetHeader */
                            part_set_header?: {
                              /** Format: int64 */
                              total?: number;
                              /** Format: byte */
                              hash?: string;
                            };
                          };
                          /**
                           * hashes of block data
                           * Format: byte
                           */
                          last_commit_hash?: string;
                          /** Format: byte */
                          data_hash?: string;
                          /**
                           * hashes from the app output from the prev block
                           * Format: byte
                           */
                          validators_hash?: string;
                          /** Format: byte */
                          next_validators_hash?: string;
                          /** Format: byte */
                          consensus_hash?: string;
                          /** Format: byte */
                          app_hash?: string;
                          /** Format: byte */
                          last_results_hash?: string;
                          /**
                           * consensus info
                           * Format: byte
                           */
                          evidence_hash?: string;
                          /** Format: byte */
                          proposer_address?: string;
                        };
                        /** @description Commit contains the evidence that a block was committed by a set of validators. */
                        commit?: {
                          /** Format: int64 */
                          height?: string;
                          /** Format: int32 */
                          round?: number;
                          /** BlockID */
                          block_id?: {
                            /** Format: byte */
                            hash?: string;
                            /** PartsetHeader */
                            part_set_header?: {
                              /** Format: int64 */
                              total?: number;
                              /** Format: byte */
                              hash?: string;
                            };
                          };
                          signatures?: {
                            /**
                             * BlockIdFlag indicates which BlcokID the signature is for
                             * @default BLOCK_ID_FLAG_UNKNOWN
                             * @enum {string}
                             */
                            block_id_flag:
                              | "BLOCK_ID_FLAG_UNKNOWN"
                              | "BLOCK_ID_FLAG_ABSENT"
                              | "BLOCK_ID_FLAG_COMMIT"
                              | "BLOCK_ID_FLAG_NIL";
                            /** Format: byte */
                            validator_address?: string;
                            /** Format: date-time */
                            timestamp?: string;
                            /** Format: byte */
                            signature?: string;
                          }[];
                        };
                      };
                      validator_set?: {
                        validators?: {
                          /** Format: byte */
                          address?: string;
                          /** PublicKey defines the keys available for use with Validators */
                          pub_key?: {
                            /** Format: byte */
                            ed25519?: string;
                            /** Format: byte */
                            secp256k1?: string;
                          };
                          /** Format: int64 */
                          voting_power?: string;
                          /** Format: int64 */
                          proposer_priority?: string;
                        }[];
                        proposer?: {
                          /** Format: byte */
                          address?: string;
                          /** PublicKey defines the keys available for use with Validators */
                          pub_key?: {
                            /** Format: byte */
                            ed25519?: string;
                            /** Format: byte */
                            secp256k1?: string;
                          };
                          /** Format: int64 */
                          voting_power?: string;
                          /** Format: int64 */
                          proposer_priority?: string;
                        };
                        /** Format: int64 */
                        total_voting_power?: string;
                      };
                    };
                    /** Format: int64 */
                    common_height?: string;
                    byzantine_validators?: {
                      /** Format: byte */
                      address?: string;
                      /** PublicKey defines the keys available for use with Validators */
                      pub_key?: {
                        /** Format: byte */
                        ed25519?: string;
                        /** Format: byte */
                        secp256k1?: string;
                      };
                      /** Format: int64 */
                      voting_power?: string;
                      /** Format: int64 */
                      proposer_priority?: string;
                    }[];
                    /** Format: int64 */
                    total_voting_power?: string;
                    /** Format: date-time */
                    timestamp?: string;
                  };
                }[];
              };
              /** @description Commit contains the evidence that a block was committed by a set of validators. */
              last_commit?: {
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                signatures?: {
                  /**
                   * BlockIdFlag indicates which BlcokID the signature is for
                   * @default BLOCK_ID_FLAG_UNKNOWN
                   * @enum {string}
                   */
                  block_id_flag:
                    | "BLOCK_ID_FLAG_UNKNOWN"
                    | "BLOCK_ID_FLAG_ABSENT"
                    | "BLOCK_ID_FLAG_COMMIT"
                    | "BLOCK_ID_FLAG_NIL";
                  /** Format: byte */
                  validator_address?: string;
                  /** Format: date-time */
                  timestamp?: string;
                  /** Format: byte */
                  signature?: string;
                }[];
              };
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  GetNodeInfo: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            default_node_info?: {
              protocol_version?: {
                /** Format: uint64 */
                p2p?: string;
                /** Format: uint64 */
                block?: string;
                /** Format: uint64 */
                app?: string;
              };
              default_node_id?: string;
              listen_addr?: string;
              network?: string;
              version?: string;
              /** Format: byte */
              channels?: string;
              moniker?: string;
              other?: {
                tx_index?: string;
                rpc_address?: string;
              };
            };
            /** @description VersionInfo is the type for the GetNodeInfoResponse message. */
            application_version?: {
              name?: string;
              app_name?: string;
              version?: string;
              git_commit?: string;
              build_tags?: string;
              go_version?: string;
              build_deps?: {
                /** module path */
                path?: string;
                /** module version */
                version?: string;
                /** checksum */
                sum?: string;
              }[];
              /** Since: cosmos-sdk 0.43 */
              cosmos_sdk_version?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  GetSyncing: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Format: boolean */
            syncing?: boolean;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  GetLatestValidatorSet: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Format: int64 */
            block_height?: string;
            validators?: {
              address?: string;
              /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         } */
              pub_key?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /** Format: int64 */
              voting_power?: string;
              /** Format: int64 */
              proposer_priority?: string;
            }[];
            /** @description pagination defines an pagination for the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  GetValidatorSetByHeight: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        height: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** Format: int64 */
            block_height?: string;
            validators?: {
              address?: string;
              /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         } */
              pub_key?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /** Format: int64 */
              voting_power?: string;
              /** Format: int64 */
              proposer_priority?: string;
            }[];
            /** @description pagination defines an pagination for the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  CommunityPool: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description pool defines community pool's coins. */
            pool?: {
              denom?: string;
              amount?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DelegationTotalRewards: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description delegator_address defines the delegator address to query for. */
        delegator_address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description rewards defines all the rewards accrued by a delegator. */
            rewards?: {
              validator_address?: string;
              reward?: {
                denom?: string;
                amount?: string;
              }[];
            }[];
            /** @description total defines the sum of all the rewards. */
            total?: {
              denom?: string;
              amount?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DelegationRewards: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description delegator_address defines the delegator address to query for. */
        delegator_address: string;
        /** @description validator_address defines the validator address to query for. */
        validator_address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description rewards defines the rewards accrued by a delegation. */
            rewards?: {
              denom?: string;
              amount?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DelegatorValidators: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description delegator_address defines the delegator address to query for. */
        delegator_address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description validators defines the validators a delegator is delegating for. */
            validators?: string[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DelegatorWithdrawAddress: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description delegator_address defines the delegator address to query for. */
        delegator_address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description withdraw_address defines the delegator address to query for. */
            withdraw_address?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DistributionParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description params defines the parameters of the module. */
            params?: {
              community_tax?: string;
              base_proposer_reward?: string;
              bonus_proposer_reward?: string;
              /** Format: boolean */
              withdraw_addr_enabled?: boolean;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ValidatorCommission: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description validator_address defines the validator address to query for. */
        validator_address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description commission defines the commision the validator received. */
            commission?: {
              commission?: {
                denom?: string;
                amount?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ValidatorOutstandingRewards: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description validator_address defines the validator address to query for. */
        validator_address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
             *     for a validator inexpensive to track, allows simple sanity checks. */
            rewards?: {
              rewards?: {
                denom?: string;
                amount?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ValidatorSlashes: {
    parameters: {
      query?: {
        /** @description starting_height defines the optional starting height to query the slashes. */
        starting_height?: string;
        /** @description starting_height defines the optional ending height to query the slashes. */
        ending_height?: string;
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description validator_address defines the validator address to query for. */
        validator_address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description slashes defines the slashes the validator received. */
            slashes?: {
              /** Format: uint64 */
              validator_period?: string;
              fraction?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Allowance: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description granter is the address of the user granting an allowance of their funds. */
        granter: string;
        /** @description grantee is the address of the user being granted an allowance of another user's funds. */
        grantee: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * Grant is stored in the KVStore to record a grant with full context
             * @description allowance is a allowance granted for grantee by granter.
             */
            allowance?: {
              /** @description granter is the address of the user granting an allowance of their funds. */
              granter?: string;
              /** @description grantee is the address of the user being granted an allowance of another user's funds. */
              grantee?: string;
              /** @description allowance can be any of basic and filtered fee allowance. */
              allowance?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Allowances: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        grantee: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description allowances are allowance's granted for grantee by granter. */
            allowances?: {
              /** @description granter is the address of the user granting an allowance of their funds. */
              granter?: string;
              /** @description grantee is the address of the user being granted an allowance of another user's funds. */
              grantee?: string;
              /** @description allowance can be any of basic and filtered fee allowance. */
              allowance?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            }[];
            /** @description pagination defines an pagination for the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  AllowancesByGranter: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        granter: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description allowances that have been issued by the granter. */
            allowances?: {
              /** @description granter is the address of the user granting an allowance of their funds. */
              granter?: string;
              /** @description grantee is the address of the user being granted an allowance of another user's funds. */
              grantee?: string;
              /** @description allowance can be any of basic and filtered fee allowance. */
              allowance?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            }[];
            /** @description pagination defines an pagination for the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  AllEvidence: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description evidence returns all evidences. */
            evidence?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Evidence: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description evidence_hash defines the hash of the requested evidence. */
        evidence_hash: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
             *     URL that describes the type of the serialized message.
             *
             *     Protobuf library provides support to pack/unpack Any values in the form
             *     of utility functions or additional generated methods of the Any type.
             *
             *     Example 1: Pack and unpack a message in C++.
             *
             *         Foo foo = ...;
             *         Any any;
             *         any.PackFrom(foo);
             *         ...
             *         if (any.UnpackTo(&foo)) {
             *           ...
             *         }
             *
             *     Example 2: Pack and unpack a message in Java.
             *
             *         Foo foo = ...;
             *         Any any = Any.pack(foo);
             *         ...
             *         if (any.is(Foo.class)) {
             *           foo = any.unpack(Foo.class);
             *         }
             *
             *      Example 3: Pack and unpack a message in Python.
             *
             *         foo = Foo(...)
             *         any = Any()
             *         any.Pack(foo)
             *         ...
             *         if any.Is(Foo.DESCRIPTOR):
             *           any.Unpack(foo)
             *           ...
             *
             *      Example 4: Pack and unpack a message in Go
             *
             *          foo := &pb.Foo{...}
             *          any, err := anypb.New(foo)
             *          if err != nil {
             *            ...
             *          }
             *          ...
             *          foo := &pb.Foo{}
             *          if err := any.UnmarshalTo(foo); err != nil {
             *            ...
             *          }
             *
             *     The pack methods provided by protobuf library will by default use
             *     'type.googleapis.com/full.type.name' as the type URL and the unpack
             *     methods only use the fully qualified type name after the last '/'
             *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
             *     name "y.z".
             *
             *
             *     JSON
             *     ====
             *     The JSON representation of an `Any` value uses the regular
             *     representation of the deserialized, embedded message, with an
             *     additional field `@type` which contains the type URL. Example:
             *
             *         package google.profile;
             *         message Person {
             *           string first_name = 1;
             *           string last_name = 2;
             *         }
             *
             *         {
             *           "@type": "type.googleapis.com/google.profile.Person",
             *           "firstName": <string>,
             *           "lastName": <string>
             *         }
             *
             *     If the embedded message type is well-known and has a custom JSON
             *     representation, that representation will be embedded adding a field
             *     `value` which holds the custom JSON in addition to the `@type`
             *     field. Example (for message [google.protobuf.Duration][]):
             *
             *         {
             *           "@type": "type.googleapis.com/google.protobuf.Duration",
             *           "value": "1.212s"
             *         } */
            evidence?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  GovParams: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description params_type defines which parameters to query for, can be one of "voting",
         *     "tallying" or "deposit". */
        params_type: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description voting_params defines the parameters related to voting. */
            voting_params?: {
              /** @description Length of the voting period. */
              voting_period?: string;
            };
            /** @description deposit_params defines the parameters related to deposit. */
            deposit_params?: {
              /** @description Minimum deposit for a proposal to enter voting period. */
              min_deposit?: {
                denom?: string;
                amount?: string;
              }[];
              /** @description Maximum period for Atom holders to deposit on a proposal. Initial value: 2
               *      months. */
              max_deposit_period?: string;
            };
            /** @description tally_params defines the parameters related to tally. */
            tally_params?: {
              /**
               * Format: byte
               * @description Minimum percentage of total stake needed to vote for a result to be
               *      considered valid.
               */
              quorum?: string;
              /**
               * Format: byte
               * @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
               */
              threshold?: string;
              /**
               * Format: byte
               * @description Minimum value of Veto votes to Total votes ratio for proposal to be
               *      vetoed. Default value: 1/3.
               */
              veto_threshold?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Proposals: {
    parameters: {
      query?: {
        /** @description proposal_status defines the status of the proposals.
         *
         *      - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
         *      - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
         *     period.
         *      - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
         *     period.
         *      - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
         *     passed.
         *      - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
         *     been rejected.
         *      - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
         *     failed. */
        proposal_status?:
          | "PROPOSAL_STATUS_UNSPECIFIED"
          | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
          | "PROPOSAL_STATUS_VOTING_PERIOD"
          | "PROPOSAL_STATUS_PASSED"
          | "PROPOSAL_STATUS_REJECTED"
          | "PROPOSAL_STATUS_FAILED";
        /** @description voter defines the voter address for the proposals. */
        voter?: string;
        /** @description depositor defines the deposit addresses from the proposals. */
        depositor?: string;
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            proposals?: {
              /** Format: uint64 */
              proposal_id?: string;
              /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         } */
              content?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /**
               * @description ProposalStatus enumerates the valid statuses of a proposal.
               *
               *      - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
               *      - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
               *     period.
               *      - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
               *     period.
               *      - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
               *     passed.
               *      - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
               *     been rejected.
               *      - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
               *     failed.
               * @default PROPOSAL_STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "PROPOSAL_STATUS_UNSPECIFIED"
                | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
                | "PROPOSAL_STATUS_VOTING_PERIOD"
                | "PROPOSAL_STATUS_PASSED"
                | "PROPOSAL_STATUS_REJECTED"
                | "PROPOSAL_STATUS_FAILED";
              /** @description TallyResult defines a standard tally for a governance proposal. */
              final_tally_result?: {
                yes?: string;
                abstain?: string;
                no?: string;
                no_with_veto?: string;
              };
              /** Format: date-time */
              submit_time?: string;
              /** Format: date-time */
              deposit_end_time?: string;
              total_deposit?: {
                denom?: string;
                amount?: string;
              }[];
              /** Format: date-time */
              voting_start_time?: string;
              /** Format: date-time */
              voting_end_time?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Proposal: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description Proposal defines the core field members of a governance proposal. */
            proposal?: {
              /** Format: uint64 */
              proposal_id?: string;
              /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         } */
              content?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /**
               * @description ProposalStatus enumerates the valid statuses of a proposal.
               *
               *      - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
               *      - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
               *     period.
               *      - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
               *     period.
               *      - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
               *     passed.
               *      - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
               *     been rejected.
               *      - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
               *     failed.
               * @default PROPOSAL_STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "PROPOSAL_STATUS_UNSPECIFIED"
                | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
                | "PROPOSAL_STATUS_VOTING_PERIOD"
                | "PROPOSAL_STATUS_PASSED"
                | "PROPOSAL_STATUS_REJECTED"
                | "PROPOSAL_STATUS_FAILED";
              /** @description TallyResult defines a standard tally for a governance proposal. */
              final_tally_result?: {
                yes?: string;
                abstain?: string;
                no?: string;
                no_with_veto?: string;
              };
              /** Format: date-time */
              submit_time?: string;
              /** Format: date-time */
              deposit_end_time?: string;
              total_deposit?: {
                denom?: string;
                amount?: string;
              }[];
              /** Format: date-time */
              voting_start_time?: string;
              /** Format: date-time */
              voting_end_time?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Deposits: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            deposits?: {
              /** Format: uint64 */
              proposal_id?: string;
              depositor?: string;
              amount?: {
                denom?: string;
                amount?: string;
              }[];
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Deposit: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
        /** @description depositor defines the deposit addresses from the proposals. */
        depositor: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description Deposit defines an amount deposited by an account address to an active
             *     proposal. */
            deposit?: {
              /** Format: uint64 */
              proposal_id?: string;
              depositor?: string;
              amount?: {
                denom?: string;
                amount?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  TallyResult: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description TallyResult defines a standard tally for a governance proposal. */
            tally?: {
              yes?: string;
              abstain?: string;
              no?: string;
              no_with_veto?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Votes: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description votes defined the queried votes. */
            votes?: {
              /** Format: uint64 */
              proposal_id?: string;
              voter?: string;
              /**
               * @description Deprecated: Prefer to use `options` instead. This field is set in queries
               *     if and only if `len(options) == 1` and that option has weight 1. In all
               *     other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
               * @default VOTE_OPTION_UNSPECIFIED
               * @enum {string}
               */
              option:
                | "VOTE_OPTION_UNSPECIFIED"
                | "VOTE_OPTION_YES"
                | "VOTE_OPTION_ABSTAIN"
                | "VOTE_OPTION_NO"
                | "VOTE_OPTION_NO_WITH_VETO";
              /** Since: cosmos-sdk 0.43 */
              options?: {
                /**
                 * @description VoteOption enumerates the valid vote options for a given governance proposal.
                 *
                 *      - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
                 *      - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
                 *      - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
                 *      - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
                 *      - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
                 * @default VOTE_OPTION_UNSPECIFIED
                 * @enum {string}
                 */
                option:
                  | "VOTE_OPTION_UNSPECIFIED"
                  | "VOTE_OPTION_YES"
                  | "VOTE_OPTION_ABSTAIN"
                  | "VOTE_OPTION_NO"
                  | "VOTE_OPTION_NO_WITH_VETO";
                weight?: string;
              }[];
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Vote: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
        /** @description voter defines the oter address for the proposals. */
        voter: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description Vote defines a vote on a governance proposal.
             *     A Vote consists of a proposal ID, the voter, and the vote option. */
            vote?: {
              /** Format: uint64 */
              proposal_id?: string;
              voter?: string;
              /**
               * @description Deprecated: Prefer to use `options` instead. This field is set in queries
               *     if and only if `len(options) == 1` and that option has weight 1. In all
               *     other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
               * @default VOTE_OPTION_UNSPECIFIED
               * @enum {string}
               */
              option:
                | "VOTE_OPTION_UNSPECIFIED"
                | "VOTE_OPTION_YES"
                | "VOTE_OPTION_ABSTAIN"
                | "VOTE_OPTION_NO"
                | "VOTE_OPTION_NO_WITH_VETO";
              /** Since: cosmos-sdk 0.43 */
              options?: {
                /**
                 * @description VoteOption enumerates the valid vote options for a given governance proposal.
                 *
                 *      - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
                 *      - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
                 *      - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
                 *      - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
                 *      - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
                 * @default VOTE_OPTION_UNSPECIFIED
                 * @enum {string}
                 */
                option:
                  | "VOTE_OPTION_UNSPECIFIED"
                  | "VOTE_OPTION_YES"
                  | "VOTE_OPTION_ABSTAIN"
                  | "VOTE_OPTION_NO"
                  | "VOTE_OPTION_NO_WITH_VETO";
                weight?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  AnnualProvisions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * Format: byte
             * @description annual_provisions is the current minting annual provisions value.
             */
            annual_provisions?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Inflation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * Format: byte
             * @description inflation is the current minting inflation value.
             */
            inflation?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  MintParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description params defines the parameters of the module. */
            params?: {
              /** type of coin to mint */
              mint_denom?: string;
              /** maximum annual change in inflation rate */
              inflation_rate_change?: string;
              /** maximum inflation rate */
              inflation_max?: string;
              /** minimum inflation rate */
              inflation_min?: string;
              /** goal of percent bonded atoms */
              goal_bonded?: string;
              /**
               * expected blocks per year
               * Format: uint64
               */
              blocks_per_year?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Params: {
    parameters: {
      query?: {
        /** @description subspace defines the module to query the parameter for. */
        subspace?: string;
        /** @description key defines the key of the parameter in the subspace. */
        key?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description param defines the queried parameter. */
            param?: {
              subspace?: string;
              key?: string;
              value?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SlashingParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description Params represents the parameters used for by the slashing module. */
            params?: {
              /** Format: int64 */
              signed_blocks_window?: string;
              /** Format: byte */
              min_signed_per_window?: string;
              downtime_jail_duration?: string;
              /** Format: byte */
              slash_fraction_double_sign?: string;
              /** Format: byte */
              slash_fraction_downtime?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SigningInfos: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** info is the signing info of all validators */
            info?: {
              address?: string;
              /**
               * Height at which validator was first a candidate OR was unjailed
               * Format: int64
               */
              start_height?: string;
              /**
               * Format: int64
               * @description Index which is incremented each time the validator was a bonded
               *     in a block and may have signed a precommit or not. This in conjunction with the
               *     `SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`.
               */
              index_offset?: string;
              /**
               * Format: date-time
               * @description Timestamp until which the validator is jailed due to liveness downtime.
               */
              jailed_until?: string;
              /**
               * Format: boolean
               * @description Whether or not a validator has been tombstoned (killed out of validator set). It is set
               *     once the validator commits an equivocation or for any other configured misbehiavor.
               */
              tombstoned?: boolean;
              /**
               * Format: int64
               * @description A counter kept to avoid unnecessary array reads.
               *     Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`.
               */
              missed_blocks_counter?: string;
            }[];
            /** @description PageResponse is to be embedded in gRPC response messages where the
             *     corresponding request message has used PageRequest.
             *
             *      message SomeResponse {
             *              repeated Bar results = 1;
             *              PageResponse page = 2;
             *      } */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SigningInfo: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description cons_address is the address to query signing info of */
        cons_address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * val_signing_info is the signing info of requested val cons address
             * @description ValidatorSigningInfo defines a validator's signing info for monitoring their
             *     liveness activity.
             */
            val_signing_info?: {
              address?: string;
              /**
               * Height at which validator was first a candidate OR was unjailed
               * Format: int64
               */
              start_height?: string;
              /**
               * Format: int64
               * @description Index which is incremented each time the validator was a bonded
               *     in a block and may have signed a precommit or not. This in conjunction with the
               *     `SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`.
               */
              index_offset?: string;
              /**
               * Format: date-time
               * @description Timestamp until which the validator is jailed due to liveness downtime.
               */
              jailed_until?: string;
              /**
               * Format: boolean
               * @description Whether or not a validator has been tombstoned (killed out of validator set). It is set
               *     once the validator commits an equivocation or for any other configured misbehiavor.
               */
              tombstoned?: boolean;
              /**
               * Format: int64
               * @description A counter kept to avoid unnecessary array reads.
               *     Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`.
               */
              missed_blocks_counter?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DelegatorDelegations: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description delegation_responses defines all the delegations' info of a delegator. */
            delegation_responses?: {
              /** @description Delegation represents the bond with tokens held by an account. It is
               *     owned by one delegator, and is associated with the voting power of one
               *     validator. */
              delegation?: {
                /** @description delegator_address is the bech32-encoded address of the delegator. */
                delegator_address?: string;
                /** @description validator_address is the bech32-encoded address of the validator. */
                validator_address?: string;
                /** @description shares define the delegation shares received. */
                shares?: string;
              };
              /** @description Coin defines a token with a denomination and an amount.
               *
               *     NOTE: The amount field is an Int which implements the custom method
               *     signatures required by gogoproto. */
              balance?: {
                denom?: string;
                amount?: string;
              };
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Redelegations: {
    parameters: {
      query?: {
        /** @description src_validator_addr defines the validator address to redelegate from. */
        src_validator_addr?: string;
        /** @description dst_validator_addr defines the validator address to redelegate to. */
        dst_validator_addr?: string;
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            redelegation_responses?: {
              /** @description Redelegation contains the list of a particular delegator's redelegating bonds
               *     from a particular source validator to a particular destination validator. */
              redelegation?: {
                /** @description delegator_address is the bech32-encoded address of the delegator. */
                delegator_address?: string;
                /** @description validator_src_address is the validator redelegation source operator address. */
                validator_src_address?: string;
                /** @description validator_dst_address is the validator redelegation destination operator address. */
                validator_dst_address?: string;
                /** @description entries are the redelegation entries. */
                entries?: {
                  /**
                   * Format: int64
                   * @description creation_height  defines the height which the redelegation took place.
                   */
                  creation_height?: string;
                  /**
                   * Format: date-time
                   * @description completion_time defines the unix time for redelegation completion.
                   */
                  completion_time?: string;
                  /** @description initial_balance defines the initial balance when redelegation started. */
                  initial_balance?: string;
                  /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
                  shares_dst?: string;
                }[];
              };
              entries?: {
                /** @description RedelegationEntry defines a redelegation object with relevant metadata. */
                redelegation_entry?: {
                  /**
                   * Format: int64
                   * @description creation_height  defines the height which the redelegation took place.
                   */
                  creation_height?: string;
                  /**
                   * Format: date-time
                   * @description completion_time defines the unix time for redelegation completion.
                   */
                  completion_time?: string;
                  /** @description initial_balance defines the initial balance when redelegation started. */
                  initial_balance?: string;
                  /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
                  shares_dst?: string;
                };
                balance?: string;
              }[];
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DelegatorUnbondingDelegations: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            unbonding_responses?: {
              /** @description delegator_address is the bech32-encoded address of the delegator. */
              delegator_address?: string;
              /** @description validator_address is the bech32-encoded address of the validator. */
              validator_address?: string;
              /** @description entries are the unbonding delegation entries. */
              entries?: {
                /**
                 * Format: int64
                 * @description creation_height is the height which the unbonding took place.
                 */
                creation_height?: string;
                /**
                 * Format: date-time
                 * @description completion_time is the unix time for unbonding completion.
                 */
                completion_time?: string;
                /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
                initial_balance?: string;
                /** @description balance defines the tokens to receive at completion. */
                balance?: string;
              }[];
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  StakingDelegatorValidators: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description validators defines the the validators' info of a delegator. */
            validators?: {
              /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
              operator_address?: string;
              /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         } */
              consensus_pubkey?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /**
               * Format: boolean
               * @description jailed defined whether the validator has been jailed from bonded status or not.
               */
              jailed?: boolean;
              /**
               * @description status is the validator status (bonded/unbonding/unbonded).
               * @default BOND_STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "BOND_STATUS_UNSPECIFIED"
                | "BOND_STATUS_UNBONDED"
                | "BOND_STATUS_UNBONDING"
                | "BOND_STATUS_BONDED";
              /** @description tokens define the delegated tokens (incl. self-delegation). */
              tokens?: string;
              /** @description delegator_shares defines total shares issued to a validator's delegators. */
              delegator_shares?: string;
              /** @description description defines the description terms for the validator. */
              description?: {
                /** @description moniker defines a human-readable name for the validator. */
                moniker?: string;
                /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
                identity?: string;
                /** @description website defines an optional website link. */
                website?: string;
                /** @description security_contact defines an optional email for security contact. */
                security_contact?: string;
                /** @description details define other optional details. */
                details?: string;
              };
              /**
               * Format: int64
               * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
               */
              unbonding_height?: string;
              /**
               * Format: date-time
               * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
               */
              unbonding_time?: string;
              /** @description commission defines the commission parameters. */
              commission?: {
                /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
                commission_rates?: {
                  /** @description rate is the commission rate charged to delegators, as a fraction. */
                  rate?: string;
                  /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                  max_rate?: string;
                  /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                  max_change_rate?: string;
                };
                /**
                 * Format: date-time
                 * @description update_time is the last time the commission rate was changed.
                 */
                update_time?: string;
              };
              /** @description min_self_delegation is the validator's self declared minimum self delegation. */
              min_self_delegation?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DelegatorValidator: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
        /** @description validator_addr defines the validator address to query for. */
        validator_addr: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description Validator defines a validator, together with the total amount of the
             *     Validator's bond shares and their exchange rate to coins. Slashing results in
             *     a decrease in the exchange rate, allowing correct calculation of future
             *     undelegations without iterating over delegators. When coins are delegated to
             *     this validator, the validator is credited with a delegation whose number of
             *     bond shares is based on the amount of coins delegated divided by the current
             *     exchange rate. Voting power can be calculated as total bonded shares
             *     multiplied by exchange rate. */
            validator?: {
              /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
              operator_address?: string;
              /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         } */
              consensus_pubkey?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /**
               * Format: boolean
               * @description jailed defined whether the validator has been jailed from bonded status or not.
               */
              jailed?: boolean;
              /**
               * @description status is the validator status (bonded/unbonding/unbonded).
               * @default BOND_STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "BOND_STATUS_UNSPECIFIED"
                | "BOND_STATUS_UNBONDED"
                | "BOND_STATUS_UNBONDING"
                | "BOND_STATUS_BONDED";
              /** @description tokens define the delegated tokens (incl. self-delegation). */
              tokens?: string;
              /** @description delegator_shares defines total shares issued to a validator's delegators. */
              delegator_shares?: string;
              /** @description description defines the description terms for the validator. */
              description?: {
                /** @description moniker defines a human-readable name for the validator. */
                moniker?: string;
                /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
                identity?: string;
                /** @description website defines an optional website link. */
                website?: string;
                /** @description security_contact defines an optional email for security contact. */
                security_contact?: string;
                /** @description details define other optional details. */
                details?: string;
              };
              /**
               * Format: int64
               * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
               */
              unbonding_height?: string;
              /**
               * Format: date-time
               * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
               */
              unbonding_time?: string;
              /** @description commission defines the commission parameters. */
              commission?: {
                /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
                commission_rates?: {
                  /** @description rate is the commission rate charged to delegators, as a fraction. */
                  rate?: string;
                  /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                  max_rate?: string;
                  /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                  max_change_rate?: string;
                };
                /**
                 * Format: date-time
                 * @description update_time is the last time the commission rate was changed.
                 */
                update_time?: string;
              };
              /** @description min_self_delegation is the validator's self declared minimum self delegation. */
              min_self_delegation?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  HistoricalInfo: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description height defines at which height to query the historical info. */
        height: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description hist defines the historical info at the given height. */
            hist?: {
              /** @description Header defines the structure of a block header. */
              header?: {
                /**
                 * basic block info
                 * @description Consensus captures the consensus rules for processing a block in the blockchain,
                 *     including all blockchain data structures and the rules of the application's
                 *     state transition machine.
                 */
                version?: {
                  /** Format: uint64 */
                  block?: string;
                  /** Format: uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** Format: int64 */
                height?: string;
                /** Format: date-time */
                time?: string;
                /** prev block info */
                last_block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * Format: byte
                 */
                last_commit_hash?: string;
                /** Format: byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * Format: byte
                 */
                validators_hash?: string;
                /** Format: byte */
                next_validators_hash?: string;
                /** Format: byte */
                consensus_hash?: string;
                /** Format: byte */
                app_hash?: string;
                /** Format: byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * Format: byte
                 */
                evidence_hash?: string;
                /** Format: byte */
                proposer_address?: string;
              };
              valset?: {
                /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
                operator_address?: string;
                /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
                 *     URL that describes the type of the serialized message.
                 *
                 *     Protobuf library provides support to pack/unpack Any values in the form
                 *     of utility functions or additional generated methods of the Any type.
                 *
                 *     Example 1: Pack and unpack a message in C++.
                 *
                 *         Foo foo = ...;
                 *         Any any;
                 *         any.PackFrom(foo);
                 *         ...
                 *         if (any.UnpackTo(&foo)) {
                 *           ...
                 *         }
                 *
                 *     Example 2: Pack and unpack a message in Java.
                 *
                 *         Foo foo = ...;
                 *         Any any = Any.pack(foo);
                 *         ...
                 *         if (any.is(Foo.class)) {
                 *           foo = any.unpack(Foo.class);
                 *         }
                 *
                 *      Example 3: Pack and unpack a message in Python.
                 *
                 *         foo = Foo(...)
                 *         any = Any()
                 *         any.Pack(foo)
                 *         ...
                 *         if any.Is(Foo.DESCRIPTOR):
                 *           any.Unpack(foo)
                 *           ...
                 *
                 *      Example 4: Pack and unpack a message in Go
                 *
                 *          foo := &pb.Foo{...}
                 *          any, err := anypb.New(foo)
                 *          if err != nil {
                 *            ...
                 *          }
                 *          ...
                 *          foo := &pb.Foo{}
                 *          if err := any.UnmarshalTo(foo); err != nil {
                 *            ...
                 *          }
                 *
                 *     The pack methods provided by protobuf library will by default use
                 *     'type.googleapis.com/full.type.name' as the type URL and the unpack
                 *     methods only use the fully qualified type name after the last '/'
                 *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
                 *     name "y.z".
                 *
                 *
                 *     JSON
                 *     ====
                 *     The JSON representation of an `Any` value uses the regular
                 *     representation of the deserialized, embedded message, with an
                 *     additional field `@type` which contains the type URL. Example:
                 *
                 *         package google.profile;
                 *         message Person {
                 *           string first_name = 1;
                 *           string last_name = 2;
                 *         }
                 *
                 *         {
                 *           "@type": "type.googleapis.com/google.profile.Person",
                 *           "firstName": <string>,
                 *           "lastName": <string>
                 *         }
                 *
                 *     If the embedded message type is well-known and has a custom JSON
                 *     representation, that representation will be embedded adding a field
                 *     `value` which holds the custom JSON in addition to the `@type`
                 *     field. Example (for message [google.protobuf.Duration][]):
                 *
                 *         {
                 *           "@type": "type.googleapis.com/google.protobuf.Duration",
                 *           "value": "1.212s"
                 *         } */
                consensus_pubkey?: {
                  /** @description A URL/resource name that uniquely identifies the type of the serialized
                   *     protocol buffer message. This string must contain at least
                   *     one "/" character. The last segment of the URL's path must represent
                   *     the fully qualified name of the type (as in
                   *     `path/google.protobuf.Duration`). The name should be in a canonical form
                   *     (e.g., leading "." is not accepted).
                   *
                   *     In practice, teams usually precompile into the binary all types that they
                   *     expect it to use in the context of Any. However, for URLs which use the
                   *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                   *     server that maps type URLs to message definitions as follows:
                   *
                   *     * If no scheme is provided, `https` is assumed.
                   *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                   *       value in binary format, or produce an error.
                   *     * Applications are allowed to cache lookup results based on the
                   *       URL, or have them precompiled into a binary to avoid any
                   *       lookup. Therefore, binary compatibility needs to be preserved
                   *       on changes to types. (Use versioned type names to manage
                   *       breaking changes.)
                   *
                   *     Note: this functionality is not currently available in the official
                   *     protobuf release, and it is not used for type URLs beginning with
                   *     type.googleapis.com.
                   *
                   *     Schemes other than `http`, `https` (or the empty scheme) might be
                   *     used with implementation specific semantics. */
                  type_url?: string;
                  /**
                   * Format: byte
                   * @description Must be a valid serialized protocol buffer of the above specified type.
                   */
                  value?: string;
                };
                /**
                 * Format: boolean
                 * @description jailed defined whether the validator has been jailed from bonded status or not.
                 */
                jailed?: boolean;
                /**
                 * @description status is the validator status (bonded/unbonding/unbonded).
                 * @default BOND_STATUS_UNSPECIFIED
                 * @enum {string}
                 */
                status:
                  | "BOND_STATUS_UNSPECIFIED"
                  | "BOND_STATUS_UNBONDED"
                  | "BOND_STATUS_UNBONDING"
                  | "BOND_STATUS_BONDED";
                /** @description tokens define the delegated tokens (incl. self-delegation). */
                tokens?: string;
                /** @description delegator_shares defines total shares issued to a validator's delegators. */
                delegator_shares?: string;
                /** @description description defines the description terms for the validator. */
                description?: {
                  /** @description moniker defines a human-readable name for the validator. */
                  moniker?: string;
                  /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
                  identity?: string;
                  /** @description website defines an optional website link. */
                  website?: string;
                  /** @description security_contact defines an optional email for security contact. */
                  security_contact?: string;
                  /** @description details define other optional details. */
                  details?: string;
                };
                /**
                 * Format: int64
                 * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
                 */
                unbonding_height?: string;
                /**
                 * Format: date-time
                 * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
                 */
                unbonding_time?: string;
                /** @description commission defines the commission parameters. */
                commission?: {
                  /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
                  commission_rates?: {
                    /** @description rate is the commission rate charged to delegators, as a fraction. */
                    rate?: string;
                    /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                    max_rate?: string;
                    /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                    max_change_rate?: string;
                  };
                  /**
                   * Format: date-time
                   * @description update_time is the last time the commission rate was changed.
                   */
                  update_time?: string;
                };
                /** @description min_self_delegation is the validator's self declared minimum self delegation. */
                min_self_delegation?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  StakingParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description params holds all the parameters of this module. */
            params?: {
              /** @description unbonding_time is the time duration of unbonding. */
              unbonding_time?: string;
              /**
               * Format: int64
               * @description max_validators is the maximum number of validators.
               */
              max_validators?: number;
              /**
               * Format: int64
               * @description max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
               */
              max_entries?: number;
              /**
               * Format: int64
               * @description historical_entries is the number of historical entries to persist.
               */
              historical_entries?: number;
              /** @description bond_denom defines the bondable coin denomination. */
              bond_denom?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  StakingPool: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description pool defines the pool info. */
            pool?: {
              not_bonded_tokens?: string;
              bonded_tokens?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Validators: {
    parameters: {
      query?: {
        /** @description status enables to query for validators matching a given status. */
        status?: string;
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description validators contains all the queried validators. */
            validators?: {
              /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
              operator_address?: string;
              /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         } */
              consensus_pubkey?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /**
               * Format: boolean
               * @description jailed defined whether the validator has been jailed from bonded status or not.
               */
              jailed?: boolean;
              /**
               * @description status is the validator status (bonded/unbonding/unbonded).
               * @default BOND_STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "BOND_STATUS_UNSPECIFIED"
                | "BOND_STATUS_UNBONDED"
                | "BOND_STATUS_UNBONDING"
                | "BOND_STATUS_BONDED";
              /** @description tokens define the delegated tokens (incl. self-delegation). */
              tokens?: string;
              /** @description delegator_shares defines total shares issued to a validator's delegators. */
              delegator_shares?: string;
              /** @description description defines the description terms for the validator. */
              description?: {
                /** @description moniker defines a human-readable name for the validator. */
                moniker?: string;
                /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
                identity?: string;
                /** @description website defines an optional website link. */
                website?: string;
                /** @description security_contact defines an optional email for security contact. */
                security_contact?: string;
                /** @description details define other optional details. */
                details?: string;
              };
              /**
               * Format: int64
               * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
               */
              unbonding_height?: string;
              /**
               * Format: date-time
               * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
               */
              unbonding_time?: string;
              /** @description commission defines the commission parameters. */
              commission?: {
                /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
                commission_rates?: {
                  /** @description rate is the commission rate charged to delegators, as a fraction. */
                  rate?: string;
                  /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                  max_rate?: string;
                  /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                  max_change_rate?: string;
                };
                /**
                 * Format: date-time
                 * @description update_time is the last time the commission rate was changed.
                 */
                update_time?: string;
              };
              /** @description min_self_delegation is the validator's self declared minimum self delegation. */
              min_self_delegation?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Validator: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description validator_addr defines the validator address to query for. */
        validator_addr: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description Validator defines a validator, together with the total amount of the
             *     Validator's bond shares and their exchange rate to coins. Slashing results in
             *     a decrease in the exchange rate, allowing correct calculation of future
             *     undelegations without iterating over delegators. When coins are delegated to
             *     this validator, the validator is credited with a delegation whose number of
             *     bond shares is based on the amount of coins delegated divided by the current
             *     exchange rate. Voting power can be calculated as total bonded shares
             *     multiplied by exchange rate. */
            validator?: {
              /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
              operator_address?: string;
              /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         } */
              consensus_pubkey?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /**
               * Format: boolean
               * @description jailed defined whether the validator has been jailed from bonded status or not.
               */
              jailed?: boolean;
              /**
               * @description status is the validator status (bonded/unbonding/unbonded).
               * @default BOND_STATUS_UNSPECIFIED
               * @enum {string}
               */
              status:
                | "BOND_STATUS_UNSPECIFIED"
                | "BOND_STATUS_UNBONDED"
                | "BOND_STATUS_UNBONDING"
                | "BOND_STATUS_BONDED";
              /** @description tokens define the delegated tokens (incl. self-delegation). */
              tokens?: string;
              /** @description delegator_shares defines total shares issued to a validator's delegators. */
              delegator_shares?: string;
              /** @description description defines the description terms for the validator. */
              description?: {
                /** @description moniker defines a human-readable name for the validator. */
                moniker?: string;
                /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
                identity?: string;
                /** @description website defines an optional website link. */
                website?: string;
                /** @description security_contact defines an optional email for security contact. */
                security_contact?: string;
                /** @description details define other optional details. */
                details?: string;
              };
              /**
               * Format: int64
               * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
               */
              unbonding_height?: string;
              /**
               * Format: date-time
               * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
               */
              unbonding_time?: string;
              /** @description commission defines the commission parameters. */
              commission?: {
                /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
                commission_rates?: {
                  /** @description rate is the commission rate charged to delegators, as a fraction. */
                  rate?: string;
                  /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                  max_rate?: string;
                  /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                  max_change_rate?: string;
                };
                /**
                 * Format: date-time
                 * @description update_time is the last time the commission rate was changed.
                 */
                update_time?: string;
              };
              /** @description min_self_delegation is the validator's self declared minimum self delegation. */
              min_self_delegation?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ValidatorDelegations: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description validator_addr defines the validator address to query for. */
        validator_addr: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            delegation_responses?: {
              /** @description Delegation represents the bond with tokens held by an account. It is
               *     owned by one delegator, and is associated with the voting power of one
               *     validator. */
              delegation?: {
                /** @description delegator_address is the bech32-encoded address of the delegator. */
                delegator_address?: string;
                /** @description validator_address is the bech32-encoded address of the validator. */
                validator_address?: string;
                /** @description shares define the delegation shares received. */
                shares?: string;
              };
              /** @description Coin defines a token with a denomination and an amount.
               *
               *     NOTE: The amount field is an Int which implements the custom method
               *     signatures required by gogoproto. */
              balance?: {
                denom?: string;
                amount?: string;
              };
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Delegation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description validator_addr defines the validator address to query for. */
        validator_addr: string;
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description DelegationResponse is equivalent to Delegation except that it contains a
             *     balance in addition to shares which is more suitable for client responses. */
            delegation_response?: {
              /** @description Delegation represents the bond with tokens held by an account. It is
               *     owned by one delegator, and is associated with the voting power of one
               *     validator. */
              delegation?: {
                /** @description delegator_address is the bech32-encoded address of the delegator. */
                delegator_address?: string;
                /** @description validator_address is the bech32-encoded address of the validator. */
                validator_address?: string;
                /** @description shares define the delegation shares received. */
                shares?: string;
              };
              /** @description Coin defines a token with a denomination and an amount.
               *
               *     NOTE: The amount field is an Int which implements the custom method
               *     signatures required by gogoproto. */
              balance?: {
                denom?: string;
                amount?: string;
              };
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  UnbondingDelegation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description validator_addr defines the validator address to query for. */
        validator_addr: string;
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description UnbondingDelegation stores all of a single delegator's unbonding bonds
             *     for a single validator in an time-ordered list. */
            unbond?: {
              /** @description delegator_address is the bech32-encoded address of the delegator. */
              delegator_address?: string;
              /** @description validator_address is the bech32-encoded address of the validator. */
              validator_address?: string;
              /** @description entries are the unbonding delegation entries. */
              entries?: {
                /**
                 * Format: int64
                 * @description creation_height is the height which the unbonding took place.
                 */
                creation_height?: string;
                /**
                 * Format: date-time
                 * @description completion_time is the unix time for unbonding completion.
                 */
                completion_time?: string;
                /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
                initial_balance?: string;
                /** @description balance defines the tokens to receive at completion. */
                balance?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ValidatorUnbondingDelegations: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description validator_addr defines the validator address to query for. */
        validator_addr: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            unbonding_responses?: {
              /** @description delegator_address is the bech32-encoded address of the delegator. */
              delegator_address?: string;
              /** @description validator_address is the bech32-encoded address of the validator. */
              validator_address?: string;
              /** @description entries are the unbonding delegation entries. */
              entries?: {
                /**
                 * Format: int64
                 * @description creation_height is the height which the unbonding took place.
                 */
                creation_height?: string;
                /**
                 * Format: date-time
                 * @description completion_time is the unix time for unbonding completion.
                 */
                completion_time?: string;
                /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
                initial_balance?: string;
                /** @description balance defines the tokens to receive at completion. */
                balance?: string;
              }[];
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Simulate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["cosmos.tx.v1beta1.SimulateRequest"];
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description gas_info is the information about gas used in the simulation. */
            gas_info?: {
              /**
               * Format: uint64
               * @description GasWanted is the maximum units of work we allow this tx to perform.
               */
              gas_wanted?: string;
              /**
               * Format: uint64
               * @description GasUsed is the amount of gas actually consumed.
               */
              gas_used?: string;
            };
            /** @description result is the result of the simulation. */
            result?: {
              /**
               * Format: byte
               * @description Data is any data returned from message or handler execution. It MUST be
               *     length prefixed in order to separate data from multiple message executions.
               */
              data?: string;
              /** @description Log contains the log information from message or handler execution. */
              log?: string;
              /** @description Events contains a slice of Event objects that were emitted during message
               *     or handler execution. */
              events?: {
                type?: string;
                attributes?: {
                  /** Format: byte */
                  key?: string;
                  /** Format: byte */
                  value?: string;
                  /** Format: boolean */
                  index?: boolean;
                }[];
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  GetTxsEvent: {
    parameters: {
      query?: {
        /** @description events is the list of transaction event type. */
        events?: string[];
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
        /** @description  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.
         *      - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order
         *      - ORDER_BY_DESC: ORDER_BY_DESC defines descending order */
        order_by?: "ORDER_BY_UNSPECIFIED" | "ORDER_BY_ASC" | "ORDER_BY_DESC";
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["cosmos.tx.v1beta1.GetTxsEventResponse"];
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  BroadcastTx: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: byte
           * @description tx_bytes is the raw transaction.
           */
          tx_bytes?: string;
          /**
           * @description BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.
           *
           *      - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering
           *      - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for
           *     the tx to be committed in a block.
           *      - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for
           *     a CheckTx execution response only.
           *      - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns
           *     immediately.
           * @default BROADCAST_MODE_UNSPECIFIED
           * @enum {string}
           */
          mode?:
            | "BROADCAST_MODE_UNSPECIFIED"
            | "BROADCAST_MODE_BLOCK"
            | "BROADCAST_MODE_SYNC"
            | "BROADCAST_MODE_ASYNC";
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description TxResponse defines a structure containing relevant tx data and metadata. The
             *     tags are stringified and the log is JSON decoded. */
            tx_response?: {
              /**
               * The block height
               * Format: int64
               */
              height?: string;
              /** @description The transaction hash. */
              txhash?: string;
              /** Namespace for the Code */
              codespace?: string;
              /**
               * Format: int64
               * @description Response code.
               */
              code?: number;
              /** @description Result bytes, if any. */
              data?: string;
              /** @description The output of the application's logger (raw string). May be
               *     non-deterministic. */
              raw_log?: string;
              /** @description The output of the application's logger (typed). May be non-deterministic. */
              logs?: {
                /** Format: int64 */
                msg_index?: number;
                log?: string;
                /** @description Events contains a slice of Event objects that were emitted during some
                 *     execution. */
                events?: {
                  type?: string;
                  attributes?: {
                    key?: string;
                    value?: string;
                  }[];
                }[];
              }[];
              /** @description Additional information. May be non-deterministic. */
              info?: string;
              /**
               * Format: int64
               * @description Amount of gas requested for transaction.
               */
              gas_wanted?: string;
              /**
               * Format: int64
               * @description Amount of gas consumed by transaction.
               */
              gas_used?: string;
              /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         } */
              tx?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /** @description Time of the previous block. For heights > 1, it's the weighted median of
               *     the timestamps of the valid votes in the block.LastCommit. For height == 1,
               *     it's genesis time. */
              timestamp?: string;
              /** @description Events defines all the events emitted by processing a transaction. Note,
               *     these events include those emitted by processing all the messages and those
               *     emitted from the ante handler. Whereas Logs contains the events, with
               *     additional metadata, emitted only by processing the messages.
               *
               *     Since: cosmos-sdk 0.42.11, 0.44.5, 0.45 */
              events?: {
                type?: string;
                attributes?: {
                  /** Format: byte */
                  key?: string;
                  /** Format: byte */
                  value?: string;
                  /** Format: boolean */
                  index?: boolean;
                }[];
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  GetBlockWithTxs: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description height is the height of the block to query. */
        height: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["cosmos.tx.v1beta1.GetBlockWithTxsResponse"];
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  GetTx: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description hash is the tx hash to query, encoded as a hex string. */
        hash: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": components["schemas"]["cosmos.tx.v1beta1.GetTxResponse"];
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  AppliedPlan: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description name is the name of the applied plan to query for. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * Format: int64
             * @description height is the block height at which the plan was applied.
             */
            height?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  CurrentPlan: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description plan is the current upgrade plan. */
            plan?: {
              /** @description Sets the name for the upgrade. This name will be used by the upgraded
               *     version of the software to apply any special "on-upgrade" commands during
               *     the first BeginBlock method after the upgrade is applied. It is also used
               *     to detect whether a software version can handle a given upgrade. If no
               *     upgrade handler with this name has been set in the software, it will be
               *     assumed that the software is out-of-date when the upgrade Time or Height is
               *     reached and the software will exit. */
              name?: string;
              /**
               * Format: date-time
               * @description Deprecated: Time based upgrades have been deprecated. Time based upgrade logic
               *     has been removed from the SDK.
               *     If this field is not empty, an error will be thrown.
               */
              time?: string;
              /**
               * Format: int64
               * @description The height at which the upgrade must be performed.
               *     Only used if Time is not set.
               */
              height?: string;
              /** Any application specific upgrade info to be included on-chain
               *     such as a git commit that validators could automatically upgrade to */
              info?: string;
              /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         } */
              upgraded_client_state?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ModuleVersions: {
    parameters: {
      query?: {
        /** @description module_name is a field to query a specific module
         *     consensus version from state. Leaving this empty will
         *     fetch the full list of module versions from state. */
        module_name?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description module_versions is a list of module names with their consensus versions. */
            module_versions?: {
              /** name of the app module */
              name?: string;
              /**
               * consensus version of the app module
               * Format: uint64
               */
              version?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DeprecatedUpgradedConsensusState: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description last height of the current chain must be sent in request
         *     as this is the height under which next consensus state is stored */
        last_height: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * Since: cosmos-sdk 0.43
             * Format: byte
             */
            upgraded_consensus_state?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Channels: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description list of stored channels of the chain. */
            channels?: {
              /**
               * current state of the channel end
               * @description State defines if a channel is in one of the following states:
               *     CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
               *
               *      - STATE_UNINITIALIZED_UNSPECIFIED: Default State
               *      - STATE_INIT: A channel has just started the opening handshake.
               *      - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
               *      - STATE_OPEN: A channel has completed the handshake. Open channels are
               *     ready to send and receive packets.
               *      - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
               *     packets.
               * @default STATE_UNINITIALIZED_UNSPECIFIED
               * @enum {string}
               */
              state:
                | "STATE_UNINITIALIZED_UNSPECIFIED"
                | "STATE_INIT"
                | "STATE_TRYOPEN"
                | "STATE_OPEN"
                | "STATE_CLOSED";
              /**
               * whether the channel is ordered or unordered
               * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
               *      - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
               *     which they were sent.
               *      - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
               * @default ORDER_NONE_UNSPECIFIED
               * @enum {string}
               */
              ordering:
                | "ORDER_NONE_UNSPECIFIED"
                | "ORDER_UNORDERED"
                | "ORDER_ORDERED";
              /** counterparty channel end */
              counterparty?: {
                /** @description port on the counterparty chain which owns the other end of the channel. */
                port_id?: string;
                /** channel end on the counterparty chain */
                channel_id?: string;
              };
              /** list of connection identifiers, in order, along which packets sent on
               *     this channel will travel */
              connection_hops?: string[];
              /** opaque channel version, which is agreed upon during the handshake */
              version?: string;
              /** port identifier */
              port_id?: string;
              /** channel identifier */
              channel_id?: string;
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             *     corresponding request message has used PageRequest.
             *
             *      message SomeResponse {
             *              repeated Bar results = 1;
             *              PageResponse page = 2;
             *      }
             */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Channel: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * channel associated with the request identifiers
             * @description Channel defines pipeline for exactly-once packet delivery between specific
             *     modules on separate blockchains, which has at least one end capable of
             *     sending packets and one end capable of receiving packets.
             */
            channel?: {
              /**
               * current state of the channel end
               * @description State defines if a channel is in one of the following states:
               *     CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
               *
               *      - STATE_UNINITIALIZED_UNSPECIFIED: Default State
               *      - STATE_INIT: A channel has just started the opening handshake.
               *      - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
               *      - STATE_OPEN: A channel has completed the handshake. Open channels are
               *     ready to send and receive packets.
               *      - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
               *     packets.
               * @default STATE_UNINITIALIZED_UNSPECIFIED
               * @enum {string}
               */
              state:
                | "STATE_UNINITIALIZED_UNSPECIFIED"
                | "STATE_INIT"
                | "STATE_TRYOPEN"
                | "STATE_OPEN"
                | "STATE_CLOSED";
              /**
               * whether the channel is ordered or unordered
               * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
               *      - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
               *     which they were sent.
               *      - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
               * @default ORDER_NONE_UNSPECIFIED
               * @enum {string}
               */
              ordering:
                | "ORDER_NONE_UNSPECIFIED"
                | "ORDER_UNORDERED"
                | "ORDER_ORDERED";
              /** counterparty channel end */
              counterparty?: {
                /** @description port on the counterparty chain which owns the other end of the channel. */
                port_id?: string;
                /** channel end on the counterparty chain */
                channel_id?: string;
              };
              /** list of connection identifiers, in order, along which packets sent on
               *     this channel will travel */
              connection_hops?: string[];
              /** opaque channel version, which is agreed upon during the handshake */
              version?: string;
            };
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ChannelClientState: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * client state associated with the channel
             * @description IdentifiedClientState defines a client state with an additional client
             *     identifier field.
             */
            identified_client_state?: {
              /** client identifier */
              client_id?: string;
              /**
               * client state
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         }
               */
              client_state?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            };
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ChannelConsensusState: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
        /** @description revision number of the consensus state */
        revision_number: string;
        /** @description revision height of the consensus state */
        revision_height: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * consensus state associated with the channel
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             *     URL that describes the type of the serialized message.
             *
             *     Protobuf library provides support to pack/unpack Any values in the form
             *     of utility functions or additional generated methods of the Any type.
             *
             *     Example 1: Pack and unpack a message in C++.
             *
             *         Foo foo = ...;
             *         Any any;
             *         any.PackFrom(foo);
             *         ...
             *         if (any.UnpackTo(&foo)) {
             *           ...
             *         }
             *
             *     Example 2: Pack and unpack a message in Java.
             *
             *         Foo foo = ...;
             *         Any any = Any.pack(foo);
             *         ...
             *         if (any.is(Foo.class)) {
             *           foo = any.unpack(Foo.class);
             *         }
             *
             *      Example 3: Pack and unpack a message in Python.
             *
             *         foo = Foo(...)
             *         any = Any()
             *         any.Pack(foo)
             *         ...
             *         if any.Is(Foo.DESCRIPTOR):
             *           any.Unpack(foo)
             *           ...
             *
             *      Example 4: Pack and unpack a message in Go
             *
             *          foo := &pb.Foo{...}
             *          any, err := anypb.New(foo)
             *          if err != nil {
             *            ...
             *          }
             *          ...
             *          foo := &pb.Foo{}
             *          if err := any.UnmarshalTo(foo); err != nil {
             *            ...
             *          }
             *
             *     The pack methods provided by protobuf library will by default use
             *     'type.googleapis.com/full.type.name' as the type URL and the unpack
             *     methods only use the fully qualified type name after the last '/'
             *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
             *     name "y.z".
             *
             *
             *     JSON
             *     ====
             *     The JSON representation of an `Any` value uses the regular
             *     representation of the deserialized, embedded message, with an
             *     additional field `@type` which contains the type URL. Example:
             *
             *         package google.profile;
             *         message Person {
             *           string first_name = 1;
             *           string last_name = 2;
             *         }
             *
             *         {
             *           "@type": "type.googleapis.com/google.profile.Person",
             *           "firstName": <string>,
             *           "lastName": <string>
             *         }
             *
             *     If the embedded message type is well-known and has a custom JSON
             *     representation, that representation will be embedded adding a field
             *     `value` which holds the custom JSON in addition to the `@type`
             *     field. Example (for message [google.protobuf.Duration][]):
             *
             *         {
             *           "@type": "type.googleapis.com/google.protobuf.Duration",
             *           "value": "1.212s"
             *         }
             */
            consensus_state?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
            /** client ID associated with the consensus state */
            client_id?: string;
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  NextSequenceReceive: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * next sequence receive number
             * Format: uint64
             */
            next_sequence_receive?: string;
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  PacketAcknowledgements: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
        /** @description list of packet sequences. */
        packet_commitment_sequences?: string[];
      };
      header?: never;
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            acknowledgements?: {
              /** @description channel port identifier. */
              port_id?: string;
              /** @description channel unique identifier. */
              channel_id?: string;
              /**
               * Format: uint64
               * @description packet sequence.
               */
              sequence?: string;
              /**
               * Format: byte
               * @description embedded data that represents packet state.
               */
              data?: string;
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             *     corresponding request message has used PageRequest.
             *
             *      message SomeResponse {
             *              repeated Bar results = 1;
             *              PageResponse page = 2;
             *      }
             */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  PacketAcknowledgement: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
        /** @description packet sequence */
        sequence: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * packet associated with the request fields
             * Format: byte
             */
            acknowledgement?: string;
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  PacketCommitments: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            commitments?: {
              /** @description channel port identifier. */
              port_id?: string;
              /** @description channel unique identifier. */
              channel_id?: string;
              /**
               * Format: uint64
               * @description packet sequence.
               */
              sequence?: string;
              /**
               * Format: byte
               * @description embedded data that represents packet state.
               */
              data?: string;
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             *     corresponding request message has used PageRequest.
             *
             *      message SomeResponse {
             *              repeated Bar results = 1;
             *              PageResponse page = 2;
             *      }
             */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  UnreceivedAcks: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
        /** @description list of acknowledgement sequences */
        packet_ack_sequences: string[];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** list of unreceived acknowledgement sequences */
            sequences?: string[];
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  UnreceivedPackets: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
        /** @description list of packet sequences */
        packet_commitment_sequences: string[];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** list of unreceived packet sequences */
            sequences?: string[];
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  PacketCommitment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
        /** @description packet sequence */
        sequence: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * packet associated with the request fields
             * Format: byte
             */
            commitment?: string;
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  PacketReceipt: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
        /** @description packet sequence */
        sequence: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * success flag for if receipt exists
             * Format: boolean
             */
            received?: boolean;
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ConnectionChannels: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description connection unique identifier */
        connection: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description list of channels associated with a connection. */
            channels?: {
              /**
               * current state of the channel end
               * @description State defines if a channel is in one of the following states:
               *     CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
               *
               *      - STATE_UNINITIALIZED_UNSPECIFIED: Default State
               *      - STATE_INIT: A channel has just started the opening handshake.
               *      - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
               *      - STATE_OPEN: A channel has completed the handshake. Open channels are
               *     ready to send and receive packets.
               *      - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
               *     packets.
               * @default STATE_UNINITIALIZED_UNSPECIFIED
               * @enum {string}
               */
              state:
                | "STATE_UNINITIALIZED_UNSPECIFIED"
                | "STATE_INIT"
                | "STATE_TRYOPEN"
                | "STATE_OPEN"
                | "STATE_CLOSED";
              /**
               * whether the channel is ordered or unordered
               * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
               *      - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
               *     which they were sent.
               *      - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
               * @default ORDER_NONE_UNSPECIFIED
               * @enum {string}
               */
              ordering:
                | "ORDER_NONE_UNSPECIFIED"
                | "ORDER_UNORDERED"
                | "ORDER_ORDERED";
              /** counterparty channel end */
              counterparty?: {
                /** @description port on the counterparty chain which owns the other end of the channel. */
                port_id?: string;
                /** channel end on the counterparty chain */
                channel_id?: string;
              };
              /** list of connection identifiers, in order, along which packets sent on
               *     this channel will travel */
              connection_hops?: string[];
              /** opaque channel version, which is agreed upon during the handshake */
              version?: string;
              /** port identifier */
              port_id?: string;
              /** channel identifier */
              channel_id?: string;
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             *     corresponding request message has used PageRequest.
             *
             *      message SomeResponse {
             *              repeated Bar results = 1;
             *              PageResponse page = 2;
             *      }
             */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ClientParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description params defines the parameters of the module. */
            params?: {
              /** @description allowed_clients defines the list of allowed client state types. */
              allowed_clients?: string[];
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ClientStates: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description list of stored ClientStates of the chain. */
            client_states?: {
              /** client identifier */
              client_id?: string;
              /**
               * client state
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         }
               */
              client_state?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             *     corresponding request message has used PageRequest.
             *
             *      message SomeResponse {
             *              repeated Bar results = 1;
             *              PageResponse page = 2;
             *      }
             */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ClientState: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description client state unique identifier */
        client_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * client state associated with the request identifier
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             *     URL that describes the type of the serialized message.
             *
             *     Protobuf library provides support to pack/unpack Any values in the form
             *     of utility functions or additional generated methods of the Any type.
             *
             *     Example 1: Pack and unpack a message in C++.
             *
             *         Foo foo = ...;
             *         Any any;
             *         any.PackFrom(foo);
             *         ...
             *         if (any.UnpackTo(&foo)) {
             *           ...
             *         }
             *
             *     Example 2: Pack and unpack a message in Java.
             *
             *         Foo foo = ...;
             *         Any any = Any.pack(foo);
             *         ...
             *         if (any.is(Foo.class)) {
             *           foo = any.unpack(Foo.class);
             *         }
             *
             *      Example 3: Pack and unpack a message in Python.
             *
             *         foo = Foo(...)
             *         any = Any()
             *         any.Pack(foo)
             *         ...
             *         if any.Is(Foo.DESCRIPTOR):
             *           any.Unpack(foo)
             *           ...
             *
             *      Example 4: Pack and unpack a message in Go
             *
             *          foo := &pb.Foo{...}
             *          any, err := anypb.New(foo)
             *          if err != nil {
             *            ...
             *          }
             *          ...
             *          foo := &pb.Foo{}
             *          if err := any.UnmarshalTo(foo); err != nil {
             *            ...
             *          }
             *
             *     The pack methods provided by protobuf library will by default use
             *     'type.googleapis.com/full.type.name' as the type URL and the unpack
             *     methods only use the fully qualified type name after the last '/'
             *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
             *     name "y.z".
             *
             *
             *     JSON
             *     ====
             *     The JSON representation of an `Any` value uses the regular
             *     representation of the deserialized, embedded message, with an
             *     additional field `@type` which contains the type URL. Example:
             *
             *         package google.profile;
             *         message Person {
             *           string first_name = 1;
             *           string last_name = 2;
             *         }
             *
             *         {
             *           "@type": "type.googleapis.com/google.profile.Person",
             *           "firstName": <string>,
             *           "lastName": <string>
             *         }
             *
             *     If the embedded message type is well-known and has a custom JSON
             *     representation, that representation will be embedded adding a field
             *     `value` which holds the custom JSON in addition to the `@type`
             *     field. Example (for message [google.protobuf.Duration][]):
             *
             *         {
             *           "@type": "type.googleapis.com/google.protobuf.Duration",
             *           "value": "1.212s"
             *         }
             */
            client_state?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ClientStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description client unique identifier */
        client_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            status?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ConsensusStates: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description client identifier */
        client_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** consensus states associated with the identifier */
            consensus_states?: {
              /**
               * consensus state height
               * @description Normally the RevisionHeight is incremented at each height while keeping
               *     RevisionNumber the same. However some consensus algorithms may choose to
               *     reset the height in certain conditions e.g. hard forks, state-machine
               *     breaking changes In these cases, the RevisionNumber is incremented so that
               *     height continues to be monitonically increasing even as the RevisionHeight
               *     gets reset
               */
              height?: {
                /**
                 * the revision that the client is currently on
                 * Format: uint64
                 */
                revision_number?: string;
                /**
                 * the height within the given revision
                 * Format: uint64
                 */
                revision_height?: string;
              };
              /**
               * consensus state
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         }
               */
              consensus_state?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             *     corresponding request message has used PageRequest.
             *
             *      message SomeResponse {
             *              repeated Bar results = 1;
             *              PageResponse page = 2;
             *      }
             */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ConsensusStateHeights: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description client identifier */
        client_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** consensus state heights */
            consensus_state_heights?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             *     corresponding request message has used PageRequest.
             *
             *      message SomeResponse {
             *              repeated Bar results = 1;
             *              PageResponse page = 2;
             *      }
             */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ConsensusState: {
    parameters: {
      query?: {
        /** @description latest_height overrrides the height field and queries the latest stored
         *     ConsensusState. */
        latest_height?: boolean;
      };
      header?: never;
      path: {
        /** @description client identifier */
        client_id: string;
        /** @description consensus state revision number */
        revision_number: string;
        /** @description consensus state revision height */
        revision_height: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * consensus state associated with the client identifier at the given height
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             *     URL that describes the type of the serialized message.
             *
             *     Protobuf library provides support to pack/unpack Any values in the form
             *     of utility functions or additional generated methods of the Any type.
             *
             *     Example 1: Pack and unpack a message in C++.
             *
             *         Foo foo = ...;
             *         Any any;
             *         any.PackFrom(foo);
             *         ...
             *         if (any.UnpackTo(&foo)) {
             *           ...
             *         }
             *
             *     Example 2: Pack and unpack a message in Java.
             *
             *         Foo foo = ...;
             *         Any any = Any.pack(foo);
             *         ...
             *         if (any.is(Foo.class)) {
             *           foo = any.unpack(Foo.class);
             *         }
             *
             *      Example 3: Pack and unpack a message in Python.
             *
             *         foo = Foo(...)
             *         any = Any()
             *         any.Pack(foo)
             *         ...
             *         if any.Is(Foo.DESCRIPTOR):
             *           any.Unpack(foo)
             *           ...
             *
             *      Example 4: Pack and unpack a message in Go
             *
             *          foo := &pb.Foo{...}
             *          any, err := anypb.New(foo)
             *          if err != nil {
             *            ...
             *          }
             *          ...
             *          foo := &pb.Foo{}
             *          if err := any.UnmarshalTo(foo); err != nil {
             *            ...
             *          }
             *
             *     The pack methods provided by protobuf library will by default use
             *     'type.googleapis.com/full.type.name' as the type URL and the unpack
             *     methods only use the fully qualified type name after the last '/'
             *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
             *     name "y.z".
             *
             *
             *     JSON
             *     ====
             *     The JSON representation of an `Any` value uses the regular
             *     representation of the deserialized, embedded message, with an
             *     additional field `@type` which contains the type URL. Example:
             *
             *         package google.profile;
             *         message Person {
             *           string first_name = 1;
             *           string last_name = 2;
             *         }
             *
             *         {
             *           "@type": "type.googleapis.com/google.profile.Person",
             *           "firstName": <string>,
             *           "lastName": <string>
             *         }
             *
             *     If the embedded message type is well-known and has a custom JSON
             *     representation, that representation will be embedded adding a field
             *     `value` which holds the custom JSON in addition to the `@type`
             *     field. Example (for message [google.protobuf.Duration][]):
             *
             *         {
             *           "@type": "type.googleapis.com/google.protobuf.Duration",
             *           "value": "1.212s"
             *         }
             */
            consensus_state?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * Height is a monotonically increasing data type
             *     that can be compared against another Height for the purposes of updating and
             *     freezing clients
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  UpgradedClientState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * client state associated with the request identifier
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             *     URL that describes the type of the serialized message.
             *
             *     Protobuf library provides support to pack/unpack Any values in the form
             *     of utility functions or additional generated methods of the Any type.
             *
             *     Example 1: Pack and unpack a message in C++.
             *
             *         Foo foo = ...;
             *         Any any;
             *         any.PackFrom(foo);
             *         ...
             *         if (any.UnpackTo(&foo)) {
             *           ...
             *         }
             *
             *     Example 2: Pack and unpack a message in Java.
             *
             *         Foo foo = ...;
             *         Any any = Any.pack(foo);
             *         ...
             *         if (any.is(Foo.class)) {
             *           foo = any.unpack(Foo.class);
             *         }
             *
             *      Example 3: Pack and unpack a message in Python.
             *
             *         foo = Foo(...)
             *         any = Any()
             *         any.Pack(foo)
             *         ...
             *         if any.Is(Foo.DESCRIPTOR):
             *           any.Unpack(foo)
             *           ...
             *
             *      Example 4: Pack and unpack a message in Go
             *
             *          foo := &pb.Foo{...}
             *          any, err := anypb.New(foo)
             *          if err != nil {
             *            ...
             *          }
             *          ...
             *          foo := &pb.Foo{}
             *          if err := any.UnmarshalTo(foo); err != nil {
             *            ...
             *          }
             *
             *     The pack methods provided by protobuf library will by default use
             *     'type.googleapis.com/full.type.name' as the type URL and the unpack
             *     methods only use the fully qualified type name after the last '/'
             *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
             *     name "y.z".
             *
             *
             *     JSON
             *     ====
             *     The JSON representation of an `Any` value uses the regular
             *     representation of the deserialized, embedded message, with an
             *     additional field `@type` which contains the type URL. Example:
             *
             *         package google.profile;
             *         message Person {
             *           string first_name = 1;
             *           string last_name = 2;
             *         }
             *
             *         {
             *           "@type": "type.googleapis.com/google.profile.Person",
             *           "firstName": <string>,
             *           "lastName": <string>
             *         }
             *
             *     If the embedded message type is well-known and has a custom JSON
             *     representation, that representation will be embedded adding a field
             *     `value` which holds the custom JSON in addition to the `@type`
             *     field. Example (for message [google.protobuf.Duration][]):
             *
             *         {
             *           "@type": "type.googleapis.com/google.protobuf.Duration",
             *           "value": "1.212s"
             *         }
             */
            upgraded_client_state?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  UpgradedConsensusState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * Consensus state associated with the request identifier
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             *     URL that describes the type of the serialized message.
             *
             *     Protobuf library provides support to pack/unpack Any values in the form
             *     of utility functions or additional generated methods of the Any type.
             *
             *     Example 1: Pack and unpack a message in C++.
             *
             *         Foo foo = ...;
             *         Any any;
             *         any.PackFrom(foo);
             *         ...
             *         if (any.UnpackTo(&foo)) {
             *           ...
             *         }
             *
             *     Example 2: Pack and unpack a message in Java.
             *
             *         Foo foo = ...;
             *         Any any = Any.pack(foo);
             *         ...
             *         if (any.is(Foo.class)) {
             *           foo = any.unpack(Foo.class);
             *         }
             *
             *      Example 3: Pack and unpack a message in Python.
             *
             *         foo = Foo(...)
             *         any = Any()
             *         any.Pack(foo)
             *         ...
             *         if any.Is(Foo.DESCRIPTOR):
             *           any.Unpack(foo)
             *           ...
             *
             *      Example 4: Pack and unpack a message in Go
             *
             *          foo := &pb.Foo{...}
             *          any, err := anypb.New(foo)
             *          if err != nil {
             *            ...
             *          }
             *          ...
             *          foo := &pb.Foo{}
             *          if err := any.UnmarshalTo(foo); err != nil {
             *            ...
             *          }
             *
             *     The pack methods provided by protobuf library will by default use
             *     'type.googleapis.com/full.type.name' as the type URL and the unpack
             *     methods only use the fully qualified type name after the last '/'
             *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
             *     name "y.z".
             *
             *
             *     JSON
             *     ====
             *     The JSON representation of an `Any` value uses the regular
             *     representation of the deserialized, embedded message, with an
             *     additional field `@type` which contains the type URL. Example:
             *
             *         package google.profile;
             *         message Person {
             *           string first_name = 1;
             *           string last_name = 2;
             *         }
             *
             *         {
             *           "@type": "type.googleapis.com/google.profile.Person",
             *           "firstName": <string>,
             *           "lastName": <string>
             *         }
             *
             *     If the embedded message type is well-known and has a custom JSON
             *     representation, that representation will be embedded adding a field
             *     `value` which holds the custom JSON in addition to the `@type`
             *     field. Example (for message [google.protobuf.Duration][]):
             *
             *         {
             *           "@type": "type.googleapis.com/google.protobuf.Duration",
             *           "value": "1.212s"
             *         }
             */
            upgraded_consensus_state?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ClientConnections: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description client identifier associated with a connection */
        client_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description slice of all the connection paths associated with a client. */
            connection_paths?: string[];
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was generated
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Connections: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description list of stored connections of the chain. */
            connections?: {
              /** @description connection identifier. */
              id?: string;
              /** @description client associated with this connection. */
              client_id?: string;
              /** IBC version which can be utilised to determine encodings or protocols for
               *     channels or packets utilising this connection */
              versions?: {
                /** unique version identifier */
                identifier?: string;
                /** list of features compatible with the specified identifier */
                features?: string[];
              }[];
              /**
               * @description current state of the connection end.
               * @default STATE_UNINITIALIZED_UNSPECIFIED
               * @enum {string}
               */
              state:
                | "STATE_UNINITIALIZED_UNSPECIFIED"
                | "STATE_INIT"
                | "STATE_TRYOPEN"
                | "STATE_OPEN";
              /** @description counterparty chain associated with this connection. */
              counterparty?: {
                /** @description identifies the client on the counterparty chain associated with a given
                 *     connection. */
                client_id?: string;
                /** @description identifies the connection end on the counterparty chain associated with a
                 *     given connection. */
                connection_id?: string;
                /**
                 * MerklePrefix is merkle path prefixed to the key.
                 *     The constructed key from the Path and the key will be append(Path.KeyPath,
                 *     append(Path.KeyPrefix, key...))
                 * @description commitment merkle prefix of the counterparty chain.
                 */
                prefix?: {
                  /** Format: byte */
                  key_prefix?: string;
                };
              };
              /**
               * Format: uint64
               * @description delay period associated with this connection.
               */
              delay_period?: string;
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             *     corresponding request message has used PageRequest.
             *
             *      message SomeResponse {
             *              repeated Bar results = 1;
             *              PageResponse page = 2;
             *      }
             */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Connection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description connection unique identifier */
        connection_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * connection associated with the request identifier
             * @description ConnectionEnd defines a stateful object on a chain connected to another
             *     separate one.
             *     NOTE: there must only be 2 defined ConnectionEnds to establish
             *     a connection between two chains.
             */
            connection?: {
              /** @description client associated with this connection. */
              client_id?: string;
              /** @description IBC version which can be utilised to determine encodings or protocols for
               *     channels or packets utilising this connection. */
              versions?: {
                /** unique version identifier */
                identifier?: string;
                /** list of features compatible with the specified identifier */
                features?: string[];
              }[];
              /**
               * @description current state of the connection end.
               * @default STATE_UNINITIALIZED_UNSPECIFIED
               * @enum {string}
               */
              state:
                | "STATE_UNINITIALIZED_UNSPECIFIED"
                | "STATE_INIT"
                | "STATE_TRYOPEN"
                | "STATE_OPEN";
              /** @description counterparty chain associated with this connection. */
              counterparty?: {
                /** @description identifies the client on the counterparty chain associated with a given
                 *     connection. */
                client_id?: string;
                /** @description identifies the connection end on the counterparty chain associated with a
                 *     given connection. */
                connection_id?: string;
                /**
                 * MerklePrefix is merkle path prefixed to the key.
                 *     The constructed key from the Path and the key will be append(Path.KeyPath,
                 *     append(Path.KeyPrefix, key...))
                 * @description commitment merkle prefix of the counterparty chain.
                 */
                prefix?: {
                  /** Format: byte */
                  key_prefix?: string;
                };
              };
              /**
               * Format: uint64
               * @description delay period that must pass before a consensus state can be used for
               *     packet-verification NOTE: delay period logic is only implemented by some
               *     clients.
               */
              delay_period?: string;
            };
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ConnectionClientState: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description connection identifier */
        connection_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * client state associated with the channel
             * @description IdentifiedClientState defines a client state with an additional client
             *     identifier field.
             */
            identified_client_state?: {
              /** client identifier */
              client_id?: string;
              /**
               * client state
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         }
               */
              client_state?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            };
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ConnectionConsensusState: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description connection identifier */
        connection_id: string;
        revision_number: string;
        revision_height: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * consensus state associated with the channel
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             *     URL that describes the type of the serialized message.
             *
             *     Protobuf library provides support to pack/unpack Any values in the form
             *     of utility functions or additional generated methods of the Any type.
             *
             *     Example 1: Pack and unpack a message in C++.
             *
             *         Foo foo = ...;
             *         Any any;
             *         any.PackFrom(foo);
             *         ...
             *         if (any.UnpackTo(&foo)) {
             *           ...
             *         }
             *
             *     Example 2: Pack and unpack a message in Java.
             *
             *         Foo foo = ...;
             *         Any any = Any.pack(foo);
             *         ...
             *         if (any.is(Foo.class)) {
             *           foo = any.unpack(Foo.class);
             *         }
             *
             *      Example 3: Pack and unpack a message in Python.
             *
             *         foo = Foo(...)
             *         any = Any()
             *         any.Pack(foo)
             *         ...
             *         if any.Is(Foo.DESCRIPTOR):
             *           any.Unpack(foo)
             *           ...
             *
             *      Example 4: Pack and unpack a message in Go
             *
             *          foo := &pb.Foo{...}
             *          any, err := anypb.New(foo)
             *          if err != nil {
             *            ...
             *          }
             *          ...
             *          foo := &pb.Foo{}
             *          if err := any.UnmarshalTo(foo); err != nil {
             *            ...
             *          }
             *
             *     The pack methods provided by protobuf library will by default use
             *     'type.googleapis.com/full.type.name' as the type URL and the unpack
             *     methods only use the fully qualified type name after the last '/'
             *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
             *     name "y.z".
             *
             *
             *     JSON
             *     ====
             *     The JSON representation of an `Any` value uses the regular
             *     representation of the deserialized, embedded message, with an
             *     additional field `@type` which contains the type URL. Example:
             *
             *         package google.profile;
             *         message Person {
             *           string first_name = 1;
             *           string last_name = 2;
             *         }
             *
             *         {
             *           "@type": "type.googleapis.com/google.profile.Person",
             *           "firstName": <string>,
             *           "lastName": <string>
             *         }
             *
             *     If the embedded message type is well-known and has a custom JSON
             *     representation, that representation will be embedded adding a field
             *     `value` which holds the custom JSON in addition to the `@type`
             *     field. Example (for message [google.protobuf.Duration][]):
             *
             *         {
             *           "@type": "type.googleapis.com/google.protobuf.Duration",
             *           "value": "1.212s"
             *         }
             */
            consensus_state?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
            /** client ID associated with the consensus state */
            client_id?: string;
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             *     RevisionNumber the same. However some consensus algorithms may choose to
             *     reset the height in certain conditions e.g. hard forks, state-machine
             *     breaking changes In these cases, the RevisionNumber is incremented so that
             *     height continues to be monitonically increasing even as the RevisionHeight
             *     gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  EscrowAddress: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description unique channel identifier */
        channel_id: string;
        /** @description unique port identifier */
        port_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** the escrow account address */
            escrow_address?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DenomHash: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The denomination trace ([port_id]/[channel_id])+/[denom] */
        trace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description hash (in hex format) of the denomination trace information. */
            hash?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DenomTraces: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description denom_traces returns all denominations trace information. */
            denom_traces?: {
              /** @description path defines the chain of port/channel identifiers used for tracing the
               *     source of the fungible token. */
              path?: string;
              /** @description base denomination of the relayed fungible token. */
              base_denom?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  DenomTrace: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information. */
        hash: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description DenomTrace contains the base denomination for ICS20 fungible tokens and the
             *     source tracing information path. */
            denom_trace?: {
              /** @description path defines the chain of port/channel identifiers used for tracing the
               *     source of the fungible token. */
              path?: string;
              /** @description base denomination of the relayed fungible token. */
              base_denom?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  IBCTransferParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description params defines the parameters of the module. */
            params?: {
              /**
               * Format: boolean
               * @description send_enabled enables or disables all cross-chain token transfers from this
               *     chain.
               */
              send_enabled?: boolean;
              /**
               * Format: boolean
               * @description receive_enabled enables or disables all cross-chain token transfers to this
               *     chain.
               */
              receive_enabled?: boolean;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Codes: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            code_infos?: {
              /** Format: uint64 */
              code_id?: string;
              creator?: string;
              /** Format: byte */
              data_hash?: string;
              /** @description AccessConfig access control type. */
              instantiate_permission?: {
                /**
                 * AccessType permission types
                 * @description - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
                 *      - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
                 *      - ACCESS_TYPE_ONLY_ADDRESS: AccessTypeOnlyAddress restricted to a single address
                 *     Deprecated: use AccessTypeAnyOfAddresses instead
                 *      - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
                 *      - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
                 * @default ACCESS_TYPE_UNSPECIFIED
                 * @enum {string}
                 */
                permission:
                  | "ACCESS_TYPE_UNSPECIFIED"
                  | "ACCESS_TYPE_NOBODY"
                  | "ACCESS_TYPE_ONLY_ADDRESS"
                  | "ACCESS_TYPE_EVERYBODY"
                  | "ACCESS_TYPE_ANY_OF_ADDRESSES";
                /** Address
                 *     Deprecated: replaced by addresses */
                address?: string;
                addresses?: string[];
              };
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  Code: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        code_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** CodeInfoResponse contains code meta data from CodeInfo */
            code_info?: {
              /** Format: uint64 */
              code_id?: string;
              creator?: string;
              /** Format: byte */
              data_hash?: string;
              /** @description AccessConfig access control type. */
              instantiate_permission?: {
                /**
                 * AccessType permission types
                 * @description - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
                 *      - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
                 *      - ACCESS_TYPE_ONLY_ADDRESS: AccessTypeOnlyAddress restricted to a single address
                 *     Deprecated: use AccessTypeAnyOfAddresses instead
                 *      - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
                 *      - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
                 * @default ACCESS_TYPE_UNSPECIFIED
                 * @enum {string}
                 */
                permission:
                  | "ACCESS_TYPE_UNSPECIFIED"
                  | "ACCESS_TYPE_NOBODY"
                  | "ACCESS_TYPE_ONLY_ADDRESS"
                  | "ACCESS_TYPE_EVERYBODY"
                  | "ACCESS_TYPE_ANY_OF_ADDRESSES";
                /** Address
                 *     Deprecated: replaced by addresses */
                address?: string;
                addresses?: string[];
              };
            };
            /** Format: byte */
            data?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ContractsByCode: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        code_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** contracts are a set of contract addresses */
            contracts?: string[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  WasmParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** @description params defines the parameters of the module. */
            params?: {
              /** @description AccessConfig access control type. */
              code_upload_access?: {
                /**
                 * AccessType permission types
                 * @description - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
                 *      - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
                 *      - ACCESS_TYPE_ONLY_ADDRESS: AccessTypeOnlyAddress restricted to a single address
                 *     Deprecated: use AccessTypeAnyOfAddresses instead
                 *      - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
                 *      - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
                 * @default ACCESS_TYPE_UNSPECIFIED
                 * @enum {string}
                 */
                permission:
                  | "ACCESS_TYPE_UNSPECIFIED"
                  | "ACCESS_TYPE_NOBODY"
                  | "ACCESS_TYPE_ONLY_ADDRESS"
                  | "ACCESS_TYPE_EVERYBODY"
                  | "ACCESS_TYPE_ANY_OF_ADDRESSES";
                /** Address
                 *     Deprecated: replaced by addresses */
                address?: string;
                addresses?: string[];
              };
              /**
               * AccessType permission types
               * @description - ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value
               *      - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden
               *      - ACCESS_TYPE_ONLY_ADDRESS: AccessTypeOnlyAddress restricted to a single address
               *     Deprecated: use AccessTypeAnyOfAddresses instead
               *      - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted
               *      - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses
               * @default ACCESS_TYPE_UNSPECIFIED
               * @enum {string}
               */
              instantiate_default_permission:
                | "ACCESS_TYPE_UNSPECIFIED"
                | "ACCESS_TYPE_NOBODY"
                | "ACCESS_TYPE_ONLY_ADDRESS"
                | "ACCESS_TYPE_EVERYBODY"
                | "ACCESS_TYPE_ANY_OF_ADDRESSES";
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  PinnedCodes: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            code_ids?: string[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ContractInfo: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description address is the address of the contract to query */
        address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** address is the address of the contract */
            address?: string;
            /** ContractInfo stores a WASM contract instance */
            contract_info?: {
              /**
               * CodeID is the reference to the stored Wasm code
               * Format: uint64
               */
              code_id?: string;
              /** Creator address who initially instantiated the contract */
              creator?: string;
              /** Admin is an optional address that can execute migrations */
              admin?: string;
              /** @description Label is optional metadata to be stored with a contract instance. */
              label?: string;
              /** @description Created Tx position when the contract was instantiated. */
              created?: {
                /**
                 * BlockHeight is the block the contract was created at
                 * Format: uint64
                 */
                block_height?: string;
                /**
                 * TxIndex is a monotonic counter within the block (actual transaction index,
                 *     or gas consumed)
                 * Format: uint64
                 */
                tx_index?: string;
              };
              ibc_port_id?: string;
              /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
               *     URL that describes the type of the serialized message.
               *
               *     Protobuf library provides support to pack/unpack Any values in the form
               *     of utility functions or additional generated methods of the Any type.
               *
               *     Example 1: Pack and unpack a message in C++.
               *
               *         Foo foo = ...;
               *         Any any;
               *         any.PackFrom(foo);
               *         ...
               *         if (any.UnpackTo(&foo)) {
               *           ...
               *         }
               *
               *     Example 2: Pack and unpack a message in Java.
               *
               *         Foo foo = ...;
               *         Any any = Any.pack(foo);
               *         ...
               *         if (any.is(Foo.class)) {
               *           foo = any.unpack(Foo.class);
               *         }
               *
               *      Example 3: Pack and unpack a message in Python.
               *
               *         foo = Foo(...)
               *         any = Any()
               *         any.Pack(foo)
               *         ...
               *         if any.Is(Foo.DESCRIPTOR):
               *           any.Unpack(foo)
               *           ...
               *
               *      Example 4: Pack and unpack a message in Go
               *
               *          foo := &pb.Foo{...}
               *          any, err := anypb.New(foo)
               *          if err != nil {
               *            ...
               *          }
               *          ...
               *          foo := &pb.Foo{}
               *          if err := any.UnmarshalTo(foo); err != nil {
               *            ...
               *          }
               *
               *     The pack methods provided by protobuf library will by default use
               *     'type.googleapis.com/full.type.name' as the type URL and the unpack
               *     methods only use the fully qualified type name after the last '/'
               *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
               *     name "y.z".
               *
               *
               *     JSON
               *     ====
               *     The JSON representation of an `Any` value uses the regular
               *     representation of the deserialized, embedded message, with an
               *     additional field `@type` which contains the type URL. Example:
               *
               *         package google.profile;
               *         message Person {
               *           string first_name = 1;
               *           string last_name = 2;
               *         }
               *
               *         {
               *           "@type": "type.googleapis.com/google.profile.Person",
               *           "firstName": <string>,
               *           "lastName": <string>
               *         }
               *
               *     If the embedded message type is well-known and has a custom JSON
               *     representation, that representation will be embedded adding a field
               *     `value` which holds the custom JSON in addition to the `@type`
               *     field. Example (for message [google.protobuf.Duration][]):
               *
               *         {
               *           "@type": "type.googleapis.com/google.protobuf.Duration",
               *           "value": "1.212s"
               *         } */
              extension?: {
                /** @description A URL/resource name that uniquely identifies the type of the serialized
                 *     protocol buffer message. This string must contain at least
                 *     one "/" character. The last segment of the URL's path must represent
                 *     the fully qualified name of the type (as in
                 *     `path/google.protobuf.Duration`). The name should be in a canonical form
                 *     (e.g., leading "." is not accepted).
                 *
                 *     In practice, teams usually precompile into the binary all types that they
                 *     expect it to use in the context of Any. However, for URLs which use the
                 *     scheme `http`, `https`, or no scheme, one can optionally set up a type
                 *     server that maps type URLs to message definitions as follows:
                 *
                 *     * If no scheme is provided, `https` is assumed.
                 *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *       value in binary format, or produce an error.
                 *     * Applications are allowed to cache lookup results based on the
                 *       URL, or have them precompiled into a binary to avoid any
                 *       lookup. Therefore, binary compatibility needs to be preserved
                 *       on changes to types. (Use versioned type names to manage
                 *       breaking changes.)
                 *
                 *     Note: this functionality is not currently available in the official
                 *     protobuf release, and it is not used for type URLs beginning with
                 *     type.googleapis.com.
                 *
                 *     Schemes other than `http`, `https` (or the empty scheme) might be
                 *     used with implementation specific semantics. */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ContractHistory: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description address is the address of the contract to query */
        address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            entries?: {
              /**
               * ContractCodeHistoryOperationType actions that caused a code change
               * @description - CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED: ContractCodeHistoryOperationTypeUnspecified placeholder for empty value
               *      - CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT: ContractCodeHistoryOperationTypeInit on chain contract instantiation
               *      - CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE: ContractCodeHistoryOperationTypeMigrate code migration
               *      - CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS: ContractCodeHistoryOperationTypeGenesis based on genesis data
               * @default CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED
               * @enum {string}
               */
              operation:
                | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"
                | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT"
                | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE"
                | "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
              /**
               * CodeID is the reference to the stored WASM code
               * Format: uint64
               */
              code_id?: string;
              /** @description Updated Tx position when the operation was executed. */
              updated?: {
                /**
                 * BlockHeight is the block the contract was created at
                 * Format: uint64
                 */
                block_height?: string;
                /**
                 * TxIndex is a monotonic counter within the block (actual transaction index,
                 *     or gas consumed)
                 * Format: uint64
                 */
                tx_index?: string;
              };
              /** Format: byte */
              msg?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  RawContractState: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description address is the address of the contract */
        address: string;
        query_data: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * Data contains the raw store data
             * Format: byte
             */
            data?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  SmartContractState: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description address is the address of the contract */
        address: string;
        /** @description QueryData contains the query data passed to the contract */
        query_data: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /**
             * Data contains the json data returned from the smart contract
             * Format: byte
             */
            data?: string;
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  AllContractState: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description address is the address of the contract */
        address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            models?: {
              /**
               * hex-encode key to read it better (this is often ascii)
               * Format: byte
               */
              key?: string;
              /**
               * base64-encode raw value
               * Format: byte
               */
              value?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  ContractsByCreator: {
    parameters: {
      query?: {
        /** @description key is a value returned in PageResponse.next_key to begin
         *     querying the next page most efficiently. Only one of offset or key
         *     should be set. */
        "pagination.key"?: string;
        /** @description offset is a numeric offset that can be used when key is unavailable.
         *     It is less efficient than using key. Only one of offset or key should
         *     be set. */
        "pagination.offset"?: string;
        /** @description limit is the total number of results to be returned in the result page.
         *     If left empty it will default to a value to be set by each app. */
        "pagination.limit"?: string;
        /** @description count_total is set to true  to indicate that the result set should include
         *     a count of the total number of items available for pagination in UIs.
         *     count_total is only respected when offset is used. It is ignored when key
         *     is set. */
        "pagination.count_total"?: boolean;
        /** @description reverse is set to true if results are to be returned in the descending order.
         *
         *     Since: cosmos-sdk 0.43 */
        "pagination.reverse"?: boolean;
      };
      header?: never;
      path: {
        /** @description CreatorAddress is the address of contract creator */
        creator_address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            /** ContractAddresses result set */
            contract_addresses?: string[];
            /** @description Pagination defines the pagination in the response. */
            pagination?: {
              /**
               * next_key is the key to be passed to PageRequest.key to
               *     query the next page most efficiently
               * Format: byte
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               *     was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /** @description A URL/resource name that uniquely identifies the type of the serialized
               *     protocol buffer message. This string must contain at least
               *     one "/" character. The last segment of the URL's path must represent
               *     the fully qualified name of the type (as in
               *     `path/google.protobuf.Duration`). The name should be in a canonical form
               *     (e.g., leading "." is not accepted).
               *
               *     In practice, teams usually precompile into the binary all types that they
               *     expect it to use in the context of Any. However, for URLs which use the
               *     scheme `http`, `https`, or no scheme, one can optionally set up a type
               *     server that maps type URLs to message definitions as follows:
               *
               *     * If no scheme is provided, `https` is assumed.
               *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *       value in binary format, or produce an error.
               *     * Applications are allowed to cache lookup results based on the
               *       URL, or have them precompiled into a binary to avoid any
               *       lookup. Therefore, binary compatibility needs to be preserved
               *       on changes to types. (Use versioned type names to manage
               *       breaking changes.)
               *
               *     Note: this functionality is not currently available in the official
               *     protobuf release, and it is not used for type URLs beginning with
               *     type.googleapis.com.
               *
               *     Schemes other than `http`, `https` (or the empty scheme) might be
               *     used with implementation specific semantics. */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
}
